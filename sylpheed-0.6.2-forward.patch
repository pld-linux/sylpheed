diff -urN sylpheed-0.6.2.orig/src/compose.c sylpheed-0.6.2/src/compose.c
--- sylpheed-0.6.2.orig/src/compose.c	Tue Sep 11 16:14:03 2001
+++ sylpheed-0.6.2/src/compose.c	Fri Oct  5 14:13:33 2001
@@ -533,7 +533,206 @@
 	gtk_text_insert(text, NULL, NULL, NULL, "\n", 1); \
 }
 
-void compose_forward(MsgInfo *msginfo, gboolean as_attach)
+
+static gchar *procmime_get_file_name(MimeInfo *mimeinfo)
+{
+	gchar *base;
+	gchar *filename;
+
+	g_return_val_if_fail(mimeinfo != NULL, NULL);
+
+	if (MIME_TEXT_HTML == mimeinfo->mime_type)
+		base = "mimetmp.html";
+	else {
+		base = mimeinfo->filename ? mimeinfo->filename
+			: mimeinfo->name ? mimeinfo->name : "mimetmp";
+		base = g_basename(base);
+		if (*base == '\0') base = "mimetmp";
+	}
+
+	filename = g_strconcat(get_mime_tmp_dir(), G_DIR_SEPARATOR_S,
+			       base, NULL);
+
+	return filename;
+}
+
+static gchar * mime_extract_file(gchar * source, MimeInfo *partinfo)
+{
+	gchar *filename;
+
+	if (!partinfo) return;
+
+	filename = procmime_get_file_name(partinfo);
+
+	if (procmime_get_part(filename, source, partinfo) < 0)
+		alertpanel_error
+			(_("Can't get the part of multipart message."));
+
+	//	g_free(filename);
+	return filename;
+}
+
+static void compose_forward_attach_parts(Compose * compose,
+					 MsgInfo * msginfo)
+{
+
+	FILE *fp;
+	gchar *file;
+	MimeInfo *mimeinfo;
+	MsgInfo *tmpmsginfo;
+	gchar *p;
+	gchar *boundary;
+	gint boundary_len = 0;
+	gchar buf[BUFFSIZE];
+	glong fpos, prev_fpos;
+	gint npart;
+	gchar * source;
+	gchar * filename;
+
+	g_return_if_fail(msginfo != NULL);
+	
+#if USE_GPGME
+	for (;;) {
+		if ((fp = procmsg_open_message(msginfo)) == NULL) return;
+		mimeinfo = procmime_scan_mime_header(fp);
+		if (!mimeinfo) break;
+
+		if (!MSG_IS_ENCRYPTED(msginfo->flags) &&
+		    rfc2015_is_encrypted(mimeinfo)) {
+			MSG_SET_FLAGS(msginfo->flags, MSG_ENCRYPTED);
+		}
+		if (MSG_IS_ENCRYPTED(msginfo->flags) &&
+		    !msginfo->plaintext_file  &&
+		    !msginfo->decryption_failed) {
+			rfc2015_decrypt_message(msginfo, mimeinfo, fp);
+			if (msginfo->plaintext_file &&
+			    !msginfo->decryption_failed) {
+				fclose(fp);
+				continue;
+			}
+		}
+		
+		break;
+	}
+#else /* !USE_GPGME */
+	if ((fp = procmsg_open_message(msginfo)) == NULL) return;
+	mimeinfo = procmime_scan_mime_header(fp);
+#endif /* USE_GPGME */
+
+	fclose(fp);
+	if (!mimeinfo) return;
+
+	if ((fp = procmsg_open_message(msginfo)) == NULL) return;
+
+	g_return_if_fail(mimeinfo != NULL);
+	g_return_if_fail(mimeinfo->mime_type != MIME_TEXT);
+
+	if (mimeinfo->mime_type == MIME_MULTIPART) {
+		g_return_if_fail(mimeinfo->boundary != NULL);
+		g_return_if_fail(mimeinfo->sub == NULL);
+	}
+	g_return_if_fail(fp != NULL);
+
+	boundary = mimeinfo->boundary;
+
+	if (boundary) {
+		boundary_len = strlen(boundary);
+
+		/* look for first boundary */
+		while ((p = fgets(buf, sizeof(buf), fp)) != NULL)
+			if (IS_BOUNDARY(buf, boundary, boundary_len)) break;
+		if (!p) {
+			fclose(fp);
+			return;
+		}
+	}
+
+	if ((fpos = ftell(fp)) < 0) {
+		perror("ftell");
+		fclose(fp);
+		return;
+	}
+
+	for (npart = 0;; npart++) {
+		MimeInfo *partinfo;
+		gboolean eom = FALSE;
+
+		prev_fpos = fpos;
+
+		partinfo = procmime_scan_mime_header(fp);
+		if (!partinfo) break;
+
+		if (npart != 0)
+			procmime_mimeinfo_insert(mimeinfo, partinfo);
+		else
+			procmime_mimeinfo_free(partinfo);
+
+		/* look for next boundary */
+		buf[0] = '\0';
+		while ((p = fgets(buf, sizeof(buf), fp)) != NULL) {
+			if (IS_BOUNDARY(buf, boundary, boundary_len)) {
+				if (buf[2 + boundary_len]     == '-' &&
+				    buf[2 + boundary_len + 1] == '-')
+					eom = TRUE;
+				break;
+			}
+		}
+		if (p == NULL)
+			eom = TRUE;	/* broken MIME message */
+		fpos = ftell(fp);
+
+		partinfo->size = fpos - prev_fpos - strlen(buf);
+
+		if (eom) break;
+	}
+	//g_message ("** at " __PRETTY_FUNCTION__ ":%d:", __LINE__);
+
+	source = procmsg_get_message_file_path(msginfo);
+
+	g_return_if_fail(mimeinfo != NULL);
+
+	if (!mimeinfo->main && mimeinfo->parent)
+		{
+			filename = mime_extract_file(source, mimeinfo);
+
+			compose_attach_append(compose, filename,
+					      mimeinfo->mime_type);
+
+			g_free(filename);
+		}
+
+	if (mimeinfo->sub && mimeinfo->sub->children)
+		{
+			filename = mime_extract_file(source, mimeinfo->sub);
+
+			compose_attach_append(compose, filename,
+					      mimeinfo->sub->mime_type);
+
+			g_free(filename);
+		}
+
+	if (mimeinfo->children) {
+		MimeInfo *child;
+
+		child = mimeinfo->children;
+		while (child) {
+			filename = mime_extract_file(source, child);
+
+			compose_attach_append(compose, filename,
+					      child->mime_type);
+
+			g_free(filename);
+
+			child = child->next;
+		}
+	}
+
+	fclose(fp);
+
+	procmime_mimeinfo_free_all(mimeinfo);
+}
+
+void compose_forward(MsgInfo *msginfo, gboolean quote, gboolean as_attach)
 {
 	Compose *compose;
 	PrefsAccount *account;
@@ -578,21 +777,36 @@
 			g_warning(_("Can't get text part\n"));
 		else {
 			/* insert header */
-			gtk_text_insert(text, NULL, NULL, NULL,
-					_("\n\nBegin forwarded message:\n\n"), -1);
-			INSERT_FW_HEADER(date,       "Date: ");
-			INSERT_FW_HEADER(from,       "From: ");
-			INSERT_FW_HEADER(to,         "To: ");
-			INSERT_FW_HEADER(newsgroups, "Newsgroups: ");
-			INSERT_FW_HEADER(subject,    "Subject: ");
-			gtk_text_insert(text, NULL, NULL, NULL, "\n\n", 2);
+			
+			gchar * forward_str;
 
-			/* forward body */
-			while (fgets(buf, sizeof(buf), fp) != NULL)
+			if (compose_parse_header(compose, msginfo) >= 0) {
+				forward_str = compose_quote_parse_fmt
+					(compose, msginfo,
+					 prefs_common.forwardfmt);
 				gtk_text_insert(text, NULL, NULL, NULL,
-						buf, -1);
+						forward_str, -1);
+				g_free(forward_str);
+			}
+
+			if (quote)
+				{
+					compose_quote_file(compose, msginfo,
+							   fp);
+				}
+			else
+				{
+					/* forward body */
+					while (fgets(buf, sizeof(buf), fp)
+					       != NULL)
+						gtk_text_insert(text, NULL,
+								NULL, NULL,
+								buf, -1);
+				}
+
 			fclose(fp);
 		}
+		compose_forward_attach_parts(compose, msginfo);
 	}
 
 	if (prefs_common.auto_sig)
@@ -1009,6 +1223,13 @@
 				break;
 			case 't':
 				str = msginfo->to;
+				sp++;
+				break;
+			case 'g':
+				str = compose->followup_to ?
+					compose->followup_to :
+						compose->newsgroups ?
+					compose->newsgroups : "";
 				sp++;
 				break;
 			case 'c':
diff -urN sylpheed-0.6.2.orig/src/compose.c.orig sylpheed-0.6.2/src/compose.c.orig
--- sylpheed-0.6.2.orig/src/compose.c.orig	Thu Jan  1 01:00:00 1970
+++ sylpheed-0.6.2/src/compose.c.orig	Tue Sep 11 16:14:03 2001
@@ -0,0 +1,4317 @@
+/*
+ * Sylpheed -- a GTK+ based, lightweight, and fast e-mail client
+ * Copyright (C) 1999-2001 Hiroyuki Yamamoto
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifdef HAVE_CONFIG_H
+#  include "config.h"
+#endif
+
+#include "defs.h"
+
+#include <glib.h>
+#include <gdk/gdkkeysyms.h>
+#include <gtk/gtkmain.h>
+#include <gtk/gtkmenu.h>
+#include <gtk/gtkmenuitem.h>
+#include <gtk/gtkitemfactory.h>
+#include <gtk/gtkcheckmenuitem.h>
+#include <gtk/gtkoptionmenu.h>
+#include <gtk/gtkwidget.h>
+#include <gtk/gtkclist.h>
+#include <gtk/gtkctree.h>
+#include <gtk/gtkvpaned.h>
+#include <gtk/gtktext.h>
+#include <gtk/gtkentry.h>
+#include <gtk/gtkeditable.h>
+#include <gtk/gtkwindow.h>
+#include <gtk/gtksignal.h>
+#include <gtk/gtkvbox.h>
+#include <gtk/gtkcontainer.h>
+#include <gtk/gtkhandlebox.h>
+#include <gtk/gtktoolbar.h>
+#include <gtk/gtktable.h>
+#include <gtk/gtkhbox.h>
+#include <gtk/gtklabel.h>
+#include <gtk/gtkscrolledwindow.h>
+#include <gtk/gtkthemes.h>
+#include <gtk/gtkdnd.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <ctype.h>
+#include <unistd.h>
+#include <time.h>
+/* #include <sys/utsname.h> */
+#include <stdlib.h>
+#include <sys/wait.h>
+#include <signal.h>
+#include <errno.h>
+
+#if (HAVE_WCTYPE_H && HAVE_WCHAR_H)
+#  include <wchar.h>
+#  include <wctype.h>
+#endif
+
+#include "intl.h"
+#include "main.h"
+#include "mainwindow.h"
+#include "compose.h"
+#include "addressbook.h"
+#include "folderview.h"
+#include "procmsg.h"
+#include "menu.h"
+#include "send.h"
+#include "news.h"
+#include "customheader.h"
+#include "prefs_common.h"
+#include "prefs_account.h"
+#include "account.h"
+#include "filesel.h"
+#include "procheader.h"
+#include "procmime.h"
+#include "statusbar.h"
+#include "about.h"
+#include "base64.h"
+#include "codeconv.h"
+#include "utils.h"
+#include "gtkutils.h"
+#include "socket.h"
+#include "alertpanel.h"
+#include "manage_window.h"
+#include "gtkshruler.h"
+#include "folder.h"
+#include "addr_compl.h"
+
+#if USE_GPGME
+#  include "rfc2015.h"
+#endif
+
+typedef enum
+{
+	COL_MIMETYPE = 0,
+	COL_SIZE     = 1,
+	COL_NAME     = 2
+} AttachColumnPos;
+
+#define N_ATTACH_COLS		3
+
+#define B64_LINE_SIZE		57
+#define B64_BUFFSIZE		77
+
+#define MAX_REFERENCES_LEN	999
+
+static GdkColor quote_color = {0, 0, 0, 0xbfff};
+
+static GList *compose_list = NULL;
+
+static Compose *compose_create			(PrefsAccount	*account,
+						 ComposeMode	 mode);
+static void compose_toolbar_create		(Compose	*compose,
+						 GtkWidget	*container);
+static GtkWidget *compose_account_option_menu_create
+						(Compose	*compose);
+static void compose_destroy			(Compose	*compose);
+
+static gint compose_parse_header		(Compose	*compose,
+						 MsgInfo	*msginfo);
+static gchar *compose_parse_references		(const gchar	*ref,
+						 const gchar	*msgid);
+static void compose_quote_file			(Compose	*compose,
+						 MsgInfo	*msginfo,
+						 FILE		*fp);
+static gchar *compose_quote_parse_fmt		(Compose	*compose,
+						 MsgInfo	*msginfo,
+						 const gchar	*fmt);
+static void compose_reply_set_entry		(Compose	*compose,
+						 MsgInfo	*msginfo,
+						 gboolean	 to_all,
+						 gboolean	 ignore_replyto);
+static void compose_reedit_set_entry		(Compose	*compose,
+						 MsgInfo	*msginfo);
+static void compose_insert_sig			(Compose	*compose);
+static void compose_insert_file			(Compose	*compose,
+						 const gchar	*file);
+static void compose_attach_append		(Compose	*compose,
+						 const gchar	*file,
+						 ContentType	 cnttype);
+static void compose_wrap_line			(Compose	*compose);
+static void compose_wrap_line_all		(Compose	*compose);
+static void compose_set_title			(Compose	*compose);
+
+static gint compose_send			(Compose	*compose);
+static gint compose_write_to_file		(Compose	*compose,
+						 const gchar	*file,
+						 gboolean	 is_draft);
+static gint compose_write_body_to_file		(Compose	*compose,
+						 const gchar	*file);
+static gint compose_save_to_outbox		(Compose	*compose,
+						 const gchar	*file);
+static gint compose_remove_reedit_target	(Compose	*compose);
+static gint compose_queue			(Compose	*compose,
+						 const gchar	*file);
+static void compose_write_attach		(Compose	*compose,
+						 FILE		*fp);
+static gint compose_write_headers		(Compose	*compose,
+						 FILE		*fp,
+						 const gchar	*charset,
+						 EncodingType	 encoding,
+						 gboolean	 is_draft);
+
+static void compose_convert_header		(gchar		*dest,
+						 gint		 len,
+						 gchar		*src,
+						 gint		 header_len);
+static void compose_generate_msgid		(Compose	*compose,
+						 gchar		*buf,
+						 gint		 len);
+
+static void compose_attach_info_free		(AttachInfo	*ainfo);
+static void compose_attach_remove_selected	(Compose	*compose);
+
+static void compose_attach_property		(Compose	*compose);
+static void compose_attach_property_create	(gboolean	*cancelled);
+static void attach_property_ok			(GtkWidget	*widget,
+						 gboolean	*cancelled);
+static void attach_property_cancel		(GtkWidget	*widget,
+						 gboolean	*cancelled);
+static gint attach_property_delete_event	(GtkWidget	*widget,
+						 GdkEventAny	*event,
+						 gboolean	*cancelled);
+static void attach_property_key_pressed		(GtkWidget	*widget,
+						 GdkEventKey	*event,
+						 gboolean	*cancelled);
+
+static void compose_exec_ext_editor		(Compose	   *compose);
+static gint compose_exec_ext_editor_real	(const gchar	   *file);
+static gboolean compose_ext_editor_kill		(Compose	   *compose);
+static void compose_input_cb			(gpointer	    data,
+						 gint		    source,
+						 GdkInputCondition  condition);
+static void compose_set_ext_editor_sensitive	(Compose	   *compose,
+						 gboolean	    sensitive);
+
+static gint calc_cursor_xpos	(GtkText	*text,
+				 gint		 extra,
+				 gint		 char_width);
+
+/* callback functions */
+
+static gboolean compose_edit_size_alloc (GtkEditable	*widget,
+					 GtkAllocation	*allocation,
+					 GtkSHRuler	*shruler);
+
+static void toolbar_send_cb		(GtkWidget	*widget,
+					 gpointer	 data);
+static void toolbar_send_later_cb	(GtkWidget	*widget,
+					 gpointer	 data);
+static void toolbar_draft_cb		(GtkWidget	*widget,
+					 gpointer	 data);
+static void toolbar_insert_cb		(GtkWidget	*widget,
+					 gpointer	 data);
+static void toolbar_attach_cb		(GtkWidget	*widget,
+					 gpointer	 data);
+static void toolbar_sig_cb		(GtkWidget	*widget,
+					 gpointer	 data);
+static void toolbar_ext_editor_cb	(GtkWidget	*widget,
+					 gpointer	 data);
+static void toolbar_linewrap_cb		(GtkWidget	*widget,
+					 gpointer	 data);
+static void toolbar_address_cb		(GtkWidget	*widget,
+					 gpointer	 data);
+
+static void account_activated		(GtkMenuItem	*menuitem,
+					 gpointer	 data);
+
+static void attach_selected		(GtkCList	*clist,
+					 gint		 row,
+					 gint		 column,
+					 GdkEvent	*event,
+					 gpointer	 data);
+static void attach_button_pressed	(GtkWidget	*widget,
+					 GdkEventButton	*event,
+					 gpointer	 data);
+static void attach_key_pressed		(GtkWidget	*widget,
+					 GdkEventKey	*event,
+					 gpointer	 data);
+
+static void compose_send_cb		(gpointer	 data,
+					 guint		 action,
+					 GtkWidget	*widget);
+static void compose_send_later_cb	(gpointer	 data,
+					 guint		 action,
+					 GtkWidget	*widget);
+
+static void compose_draft_cb		(gpointer	 data,
+					 guint		 action,
+					 GtkWidget	*widget);
+
+static void compose_attach_cb		(gpointer	 data,
+					 guint		 action,
+					 GtkWidget	*widget);
+static void compose_insert_file_cb	(gpointer	 data,
+					 guint		 action,
+					 GtkWidget	*widget);
+
+static void compose_close_cb		(gpointer	 data,
+					 guint		 action,
+					 GtkWidget	*widget);
+static void compose_address_cb		(gpointer	 data,
+					 guint		 action,
+					 GtkWidget	*widget);
+
+static void compose_ext_editor_cb	(gpointer	 data,
+					 guint		 action,
+					 GtkWidget	*widget);
+
+static gint compose_delete_cb		(GtkWidget	*widget,
+					 GdkEventAny	*event,
+					 gpointer	 data);
+static void compose_destroy_cb		(GtkWidget	*widget,
+					 Compose	*compose);
+
+static void compose_cut_cb		(Compose	*compose);
+static void compose_copy_cb		(Compose	*compose);
+static void compose_paste_cb		(Compose	*compose);
+static void compose_allsel_cb		(Compose	*compose);
+
+static void compose_grab_focus_cb	(GtkWidget	*widget,
+					 Compose	*compose);
+
+static void compose_changed_cb		(GtkEditable	*editable,
+					 Compose	*compose);
+static void compose_button_press_cb	(GtkWidget	*widget,
+					 GdkEventButton	*event,
+					 Compose	*compose);
+#if 0
+static void compose_key_press_cb	(GtkWidget	*widget,
+					 GdkEventKey	*event,
+					 Compose	*compose);
+#endif
+
+static void compose_toggle_to_cb	(gpointer	 data,
+					 guint		 action,
+					 GtkWidget	*widget);
+static void compose_toggle_cc_cb	(gpointer	 data,
+					 guint		 action,
+					 GtkWidget	*widget);
+static void compose_toggle_bcc_cb	(gpointer	 data,
+					 guint		 action,
+					 GtkWidget	*widget);
+static void compose_toggle_replyto_cb	(gpointer	 data,
+					 guint		 action,
+					 GtkWidget	*widget);
+static void compose_toggle_followupto_cb(gpointer	 data,
+					 guint		 action,
+					 GtkWidget	*widget);
+static void compose_toggle_attach_cb	(gpointer	 data,
+					 guint		 action,
+					 GtkWidget	*widget);
+static void compose_toggle_ruler_cb	(gpointer	 data,
+					 guint		 action,
+					 GtkWidget	*widget);
+#if USE_GPGME
+static void compose_toggle_sign_cb	(gpointer	 data,
+					 guint		 action,
+					 GtkWidget	*widget);
+static void compose_toggle_encrypt_cb	(gpointer	 data,
+					 guint		 action,
+					 GtkWidget	*widget);
+#endif
+
+static void compose_attach_drag_received_cb (GtkWidget		*widget,
+					     GdkDragContext	*drag_context,
+					     gint		 x,
+					     gint		 y,
+					     GtkSelectionData	*data,
+					     guint		 info,
+					     guint		 time,
+					     gpointer		 user_data);
+static void compose_insert_drag_received_cb (GtkWidget		*widget,
+					     GdkDragContext	*drag_context,
+					     gint		 x,
+					     gint		 y,
+					     GtkSelectionData	*data,
+					     guint		 info,
+					     guint		 time,
+					     gpointer		 user_data);
+
+static void to_activated		(GtkWidget	*widget,
+					 Compose	*compose);
+static void newsgroups_activated	(GtkWidget	*widget,
+					 Compose	*compose);
+static void subject_activated		(GtkWidget	*widget,
+					 Compose	*compose);
+static void cc_activated		(GtkWidget	*widget,
+					 Compose	*compose);
+static void bcc_activated		(GtkWidget	*widget,
+					 Compose	*compose);
+static void replyto_activated		(GtkWidget	*widget,
+					 Compose	*compose);
+static void followupto_activated	(GtkWidget	*widget,
+					 Compose	*compose);
+
+static GtkItemFactoryEntry compose_popup_entries[] =
+{
+	{N_("/_Add..."),	NULL, compose_attach_cb, 0, NULL},
+	{N_("/_Remove"),	NULL, compose_attach_remove_selected, 0, NULL},
+	{N_("/---"),		NULL, NULL, 0, "<Separator>"},
+	{N_("/_Property..."),	NULL, compose_attach_property, 0, NULL}
+};
+
+static GtkItemFactoryEntry compose_entries[] =
+{
+	{N_("/_File"),				NULL, NULL, 0, "<Branch>"},
+	{N_("/_File/_Attach file"),		"<control>M", compose_attach_cb,      0, NULL},
+	{N_("/_File/_Insert file"),		"<control>I", compose_insert_file_cb, 0, NULL},
+	{N_("/_File/Insert si_gnature"),	"<control>G", compose_insert_sig,     0, NULL},
+	{N_("/_File/---"),			NULL, NULL, 0, "<Separator>"},
+	{N_("/_File/_Close"),			"<alt>W", compose_close_cb, 0, NULL},
+
+	{N_("/_Edit"),		   NULL, NULL, 0, "<Branch>"},
+	{N_("/_Edit/_Undo"),	   "<control>Z", NULL, 0, NULL},
+	{N_("/_Edit/_Redo"),	   "<control>Y", NULL, 0, NULL},
+	{N_("/_Edit/---"),	   NULL, NULL, 0, "<Separator>"},
+	{N_("/_Edit/Cu_t"),	   "<control>X", compose_cut_cb,    0, NULL},
+	{N_("/_Edit/_Copy"),	   "<control>C", compose_copy_cb,   0, NULL},
+	{N_("/_Edit/_Paste"),	   "<control>V", compose_paste_cb,  0, NULL},
+	{N_("/_Edit/Select _all"), "<control>A", compose_allsel_cb, 0, NULL},
+	{N_("/_Edit/---"),	   NULL, NULL, 0, "<Separator>"},
+	{N_("/_Edit/_Wrap current paragraph"), "<alt>L", compose_wrap_line, 0, NULL},
+	{N_("/_Edit/Wrap all long _lines"),
+			"<shift><alt>L", compose_wrap_line_all, 0, NULL},
+	{N_("/_Edit/Edit with e_xternal editor"),
+			"<alt>X", compose_ext_editor_cb, 0, NULL},
+
+	{N_("/_Message"),		NULL, NULL, 0, "<Branch>"},
+	{N_("/_Message/_Send"),		"<shift><control>S",
+					compose_send_cb, 0, NULL},
+	{N_("/_Message/Send _later"),	"<shift><alt>S",
+					compose_send_later_cb,  0, NULL},
+	{N_("/_Message/Save to _draft folder"),
+					"<alt>D", compose_draft_cb, 0, NULL},
+	{N_("/_Message/---"),		NULL, NULL, 0, "<Separator>"},
+	{N_("/_Message/_To"),		NULL, compose_toggle_to_cb     , 0, "<ToggleItem>"},
+	{N_("/_Message/_Cc"),		NULL, compose_toggle_cc_cb     , 0, "<ToggleItem>"},
+	{N_("/_Message/_Bcc"),		NULL, compose_toggle_bcc_cb    , 0, "<ToggleItem>"},
+	{N_("/_Message/_Reply to"),	NULL, compose_toggle_replyto_cb, 0, "<ToggleItem>"},
+	{N_("/_Message/---"),		NULL, NULL, 0, "<Separator>"},
+	{N_("/_Message/_Followup to"),	NULL, compose_toggle_followupto_cb, 0, "<ToggleItem>"},
+	{N_("/_Message/---"),		NULL, NULL, 0, "<Separator>"},
+	{N_("/_Message/_Attach"),	NULL, compose_toggle_attach_cb, 0, "<ToggleItem>"},
+#if USE_GPGME
+	{N_("/_Message/---"),		NULL, NULL, 0, "<Separator>"},
+	{N_("/_Message/Si_gn"),   	NULL, compose_toggle_sign_cb   , 0, "<ToggleItem>"},
+	{N_("/_Message/_Encrypt"),	NULL, compose_toggle_encrypt_cb, 0, "<ToggleItem>"},
+#endif /* USE_GPGME */
+	{N_("/_Tool"),			NULL, NULL, 0, "<Branch>"},
+	{N_("/_Tool/Show _ruler"),	NULL, compose_toggle_ruler_cb, 0, "<ToggleItem>"},
+	{N_("/_Tool/_Address book"),	"<alt>A", compose_address_cb , 0, NULL},
+	{N_("/_Help"),			NULL, NULL, 0, "<LastBranch>"},
+	{N_("/_Help/_About"),		NULL, about_show, 0, NULL}
+};
+
+static GtkTargetEntry compose_mime_types[] =
+{
+	{"text/uri-list", 0, 0}
+};
+
+void compose_new(PrefsAccount *account)
+{
+	compose_new_with_recipient(account, NULL);
+}
+
+void compose_new_with_recipient(PrefsAccount *account, const gchar *to)
+{
+	Compose *compose;
+
+	if (!account) account = cur_account;
+	g_return_if_fail(account != NULL);
+
+	compose = compose_create(account, COMPOSE_NEW);
+
+	if (prefs_common.auto_sig)
+		compose_insert_sig(compose);
+	gtk_editable_set_position(GTK_EDITABLE(compose->text), 0);
+	gtk_text_set_point(GTK_TEXT(compose->text), 0);
+
+	if (account->protocol != A_NNTP) {
+		if (to) {
+			compose_entry_append(compose, to, COMPOSE_TO);
+			gtk_widget_grab_focus(compose->subject_entry);
+		} else
+			gtk_widget_grab_focus(compose->to_entry);
+	} else {
+		if (to) {
+			compose_entry_append(compose, to, COMPOSE_NEWSGROUPS);
+			gtk_widget_grab_focus(compose->subject_entry);
+		} else
+			gtk_widget_grab_focus(compose->newsgroups_entry);
+	}
+
+	if (prefs_common.auto_exteditor)
+		compose_exec_ext_editor(compose);
+}
+
+void compose_reply(MsgInfo *msginfo, gboolean quote, gboolean to_all,
+		   gboolean ignore_replyto)
+{
+	Compose *compose;
+	PrefsAccount *account;
+	GtkText *text;
+
+	g_return_if_fail(msginfo != NULL);
+	g_return_if_fail(msginfo->folder != NULL);
+
+	account = msginfo->folder->folder->account;
+	if (!account && msginfo->to && prefs_common.reply_account_autosel) {
+		gchar *to;
+		Xstrdup_a(to, msginfo->to, return);
+		extract_address(to);
+		account = account_find_from_address(to);
+	}
+	if (!account) account = cur_account;
+	g_return_if_fail(account != NULL);
+
+	MSG_UNSET_PERM_FLAGS(msginfo->flags, MSG_FORWARDED);
+	MSG_SET_PERM_FLAGS(msginfo->flags, MSG_REPLIED);
+
+	compose = compose_create(account, COMPOSE_REPLY);
+
+	if (compose_parse_header(compose, msginfo) < 0) return;
+	compose_reply_set_entry(compose, msginfo, to_all, ignore_replyto);
+
+	text = GTK_TEXT(compose->text);
+	gtk_text_freeze(text);
+
+	if (quote) {
+		FILE *fp;
+		gchar *quote_str;
+
+		if ((fp = procmime_get_text_part(msginfo)) == NULL)
+			g_warning(_("Can't get text part\n"));
+		else {
+			quote_str = compose_quote_parse_fmt
+				(compose, msginfo, prefs_common.quotefmt);
+			gtk_text_insert(text, NULL, NULL, NULL, quote_str, -1);
+			g_free(quote_str);
+			compose_quote_file(compose, msginfo, fp);
+			fclose(fp);
+		}
+	}
+
+	if (prefs_common.auto_sig)
+		compose_insert_sig(compose);
+	gtk_editable_set_position(GTK_EDITABLE(text), 0);
+	gtk_text_set_point(text, 0);
+
+	gtk_text_thaw(text);
+	gtk_widget_grab_focus(compose->text);
+
+	if (prefs_common.auto_exteditor)
+		compose_exec_ext_editor(compose);
+}
+
+#define INSERT_FW_HEADER(var, hdr) \
+if (msginfo->var && *msginfo->var) { \
+	gtk_text_insert(text, NULL, NULL, NULL, hdr, -1); \
+	gtk_text_insert(text, NULL, NULL, NULL, msginfo->var, -1); \
+	gtk_text_insert(text, NULL, NULL, NULL, "\n", 1); \
+}
+
+void compose_forward(MsgInfo *msginfo, gboolean as_attach)
+{
+	Compose *compose;
+	PrefsAccount *account;
+	GtkText *text;
+	FILE *fp;
+	gchar buf[BUFFSIZE];
+
+	g_return_if_fail(msginfo != NULL);
+	g_return_if_fail(msginfo->folder != NULL);
+
+	account = msginfo->folder->folder->account;
+	if (!account) account = cur_account;
+	g_return_if_fail(account != NULL);
+
+	MSG_UNSET_PERM_FLAGS(msginfo->flags, MSG_REPLIED);
+	MSG_SET_PERM_FLAGS(msginfo->flags, MSG_FORWARDED);
+
+	compose = compose_create(account, COMPOSE_FORWARD);
+
+	if (msginfo->subject && *msginfo->subject) {
+		gtk_entry_set_text(GTK_ENTRY(compose->subject_entry), "Fw: ");
+		gtk_entry_append_text(GTK_ENTRY(compose->subject_entry),
+				      msginfo->subject);
+	}
+
+	text = GTK_TEXT(compose->text);
+	gtk_text_freeze(text);
+
+	if (as_attach) {
+		gchar *msgfile;
+
+		msgfile = procmsg_get_message_file_path(msginfo);
+		if (!is_file_exist(msgfile))
+			g_warning(_("%s: file not exist\n"), msgfile);
+		else
+			compose_attach_append(compose, msgfile,
+					      MIME_MESSAGE_RFC822);
+
+		g_free(msgfile);
+	} else {
+		if ((fp = procmime_get_text_part(msginfo)) == NULL)
+			g_warning(_("Can't get text part\n"));
+		else {
+			/* insert header */
+			gtk_text_insert(text, NULL, NULL, NULL,
+					_("\n\nBegin forwarded message:\n\n"), -1);
+			INSERT_FW_HEADER(date,       "Date: ");
+			INSERT_FW_HEADER(from,       "From: ");
+			INSERT_FW_HEADER(to,         "To: ");
+			INSERT_FW_HEADER(newsgroups, "Newsgroups: ");
+			INSERT_FW_HEADER(subject,    "Subject: ");
+			gtk_text_insert(text, NULL, NULL, NULL, "\n\n", 2);
+
+			/* forward body */
+			while (fgets(buf, sizeof(buf), fp) != NULL)
+				gtk_text_insert(text, NULL, NULL, NULL,
+						buf, -1);
+			fclose(fp);
+		}
+	}
+
+	if (prefs_common.auto_sig)
+		compose_insert_sig(compose);
+	gtk_editable_set_position(GTK_EDITABLE(compose->text), 0);
+	gtk_text_set_point(GTK_TEXT(compose->text), 0);
+
+	gtk_text_thaw(text);
+	if (account->protocol != A_NNTP)
+		gtk_widget_grab_focus(compose->to_entry);
+	else
+		gtk_widget_grab_focus(compose->newsgroups_entry);
+
+	if (prefs_common.auto_exteditor)
+		compose_exec_ext_editor(compose);
+}
+
+#undef INSERT_FW_HEADER
+
+void compose_reedit(MsgInfo *msginfo)
+{
+	Compose *compose;
+	PrefsAccount *account;
+	GtkText *text;
+	FILE *fp;
+	gchar buf[BUFFSIZE];
+
+	g_return_if_fail(msginfo != NULL);
+	g_return_if_fail(msginfo->folder != NULL);
+
+	account = msginfo->folder->folder->account;
+	if (!account) account = cur_account;
+	g_return_if_fail(account != NULL);
+
+	compose = compose_create(account, COMPOSE_REEDIT);
+	compose->targetinfo = procmsg_msginfo_copy(msginfo);
+
+	if (compose_parse_header(compose, msginfo) < 0) return;
+	compose_reedit_set_entry(compose, msginfo);
+
+	text = GTK_TEXT(compose->text);
+	gtk_text_freeze(text);
+
+	if ((fp = procmime_get_text_part(msginfo)) == NULL)
+		g_warning(_("Can't get text part\n"));
+	else {
+		while (fgets(buf, sizeof(buf), fp) != NULL)
+			gtk_text_insert(text, NULL, NULL, NULL, buf, -1);
+		fclose(fp);
+	}
+
+	gtk_text_thaw(text);
+	gtk_widget_grab_focus(compose->text);
+
+	if (prefs_common.auto_exteditor)
+		compose_exec_ext_editor(compose);
+}
+
+GList *compose_get_compose_list(void)
+{
+	return compose_list;
+}
+
+void compose_entry_append(Compose *compose, const gchar *address,
+			  ComposeEntryType type)
+{
+	GtkEntry *entry;
+	const gchar *text;
+
+	if (!address || *address == '\0') return;
+
+	switch (type) {
+	case COMPOSE_CC:
+		entry = GTK_ENTRY(compose->cc_entry);
+		break;
+	case COMPOSE_BCC:
+		entry = GTK_ENTRY(compose->bcc_entry);
+		break;
+	case COMPOSE_NEWSGROUPS:
+		entry = GTK_ENTRY(compose->newsgroups_entry);
+		break;
+	case COMPOSE_TO:
+	default:
+		entry = GTK_ENTRY(compose->to_entry);
+		break;
+	}
+
+	text = gtk_entry_get_text(entry);
+	if (*text != '\0')
+		gtk_entry_append_text(entry, ", ");
+	gtk_entry_append_text(entry, address);
+}
+
+static gint compose_parse_header(Compose *compose, MsgInfo *msginfo)
+{
+	static HeaderEntry hentry[] = {{"Reply-To:",	NULL, TRUE},
+				       {"Cc:",		NULL, FALSE},
+				       {"References:",	NULL, FALSE},
+				       {"Bcc:",		NULL, FALSE},
+				       {"Newsgroups:",  NULL, FALSE},
+				       {"Followup-To:", NULL, FALSE},
+				       {NULL,		NULL, FALSE}};
+
+	enum
+	{
+		H_REPLY_TO	= 0,
+		H_CC		= 1,
+		H_REFERENCES	= 2,
+		H_BCC		= 3,
+		H_NEWSGROUPS    = 4,
+		H_FOLLOWUP_TO	= 5
+	};
+
+	FILE *fp;
+
+	g_return_val_if_fail(msginfo != NULL, -1);
+
+	if ((fp = procmsg_open_message(msginfo)) == NULL) return -1;
+	procheader_get_header_fields(fp, hentry);
+	fclose(fp);
+
+	if (hentry[H_REPLY_TO].body != NULL) {
+		conv_unmime_header_overwrite(hentry[H_REPLY_TO].body);
+		compose->replyto = hentry[H_REPLY_TO].body;
+		hentry[H_REPLY_TO].body = NULL;
+	}
+	if (hentry[H_CC].body != NULL) {
+		conv_unmime_header_overwrite(hentry[H_CC].body);
+		compose->cc = hentry[H_CC].body;
+		hentry[H_CC].body = NULL;
+	}
+	if (hentry[H_REFERENCES].body != NULL) {
+		if (compose->mode == COMPOSE_REEDIT)
+			compose->references = hentry[H_REFERENCES].body;
+		else {
+			compose->references = compose_parse_references
+				(hentry[H_REFERENCES].body, msginfo->msgid);
+			g_free(hentry[H_REFERENCES].body);
+		}
+		hentry[H_REFERENCES].body = NULL;
+	}
+	if (hentry[H_BCC].body != NULL) {
+		if (compose->mode == COMPOSE_REEDIT) {
+			conv_unmime_header_overwrite(hentry[H_BCC].body);
+			compose->bcc = hentry[H_BCC].body;
+		} else
+			g_free(hentry[H_BCC].body);
+		hentry[H_BCC].body = NULL;
+	}
+	if (hentry[H_NEWSGROUPS].body != NULL) {
+		compose->newsgroups = hentry[H_NEWSGROUPS].body;
+		hentry[H_NEWSGROUPS].body = NULL;
+	}
+	if (hentry[H_FOLLOWUP_TO].body != NULL) {
+		conv_unmime_header_overwrite(hentry[H_FOLLOWUP_TO].body);
+		compose->followup_to = hentry[H_FOLLOWUP_TO].body;
+		hentry[H_FOLLOWUP_TO].body = NULL;
+	}
+
+	if (compose->mode == COMPOSE_REEDIT && msginfo->inreplyto)
+		compose->inreplyto = g_strdup(msginfo->inreplyto);
+	else if (compose->mode != COMPOSE_REEDIT &&
+		 msginfo->msgid && *msginfo->msgid) {
+		compose->inreplyto = g_strdup(msginfo->msgid);
+
+		if (!compose->references) {
+			if (msginfo->inreplyto && *msginfo->inreplyto)
+				compose->references =
+					g_strdup_printf("<%s>\n\t<%s>",
+							msginfo->inreplyto,
+							msginfo->msgid);
+			else
+				compose->references =
+					g_strconcat("<", msginfo->msgid, ">",
+						    NULL);
+		}
+	}
+
+	return 0;
+}
+
+static gchar *compose_parse_references(const gchar *ref, const gchar *msgid)
+{
+	GSList *ref_id_list, *cur;
+	GString *new_ref;
+	gchar *new_ref_str;
+
+	ref_id_list = references_list_append(NULL, ref);
+	if (!ref_id_list) return NULL;
+	if (msgid && *msgid)
+		ref_id_list = g_slist_append(ref_id_list, g_strdup(msgid));
+
+	for (;;) {
+		gint len = 0;
+
+		for (cur = ref_id_list; cur != NULL; cur = cur->next)
+			/* "<" + Message-ID + ">" + CR+LF+TAB */
+			len += strlen((gchar *)cur->data) + 5;
+
+		if (len > MAX_REFERENCES_LEN) {
+			/* remove second message-ID */
+			if (ref_id_list && ref_id_list->next &&
+			    ref_id_list->next->next) {
+				g_free(ref_id_list->next->data);
+				ref_id_list = g_slist_remove
+					(ref_id_list, ref_id_list->next->data);
+			} else {
+				slist_free_strings(ref_id_list);
+				g_slist_free(ref_id_list);
+				return NULL;
+			}
+		} else
+			break;
+	}
+
+	new_ref = g_string_new("");
+	for (cur = ref_id_list; cur != NULL; cur = cur->next) {
+		if (new_ref->len > 0)
+			g_string_append(new_ref, "\n\t");
+		g_string_sprintfa(new_ref, "<%s>", (gchar *)cur->data);
+	}
+
+	slist_free_strings(ref_id_list);
+	g_slist_free(ref_id_list);
+
+	new_ref_str = new_ref->str;
+	g_string_free(new_ref, FALSE);
+
+	return new_ref_str;
+}
+
+static void compose_quote_file(Compose *compose, MsgInfo *msginfo, FILE *fp)
+{
+	GtkText *text = GTK_TEXT(compose->text);
+	gchar *qmark;
+	gchar *quote_str;
+	GdkColor *qcolor = NULL;
+	gchar buf[BUFFSIZE];
+	gint qlen;
+	gchar *linep, *cur, *leftp;
+	gint line_len, cur_len;
+	gint wrap_len;
+	gint str_len;
+	gint ch_len;
+
+	/* if (prefs_common.enable_color) qcolor = &quote_color; */
+	if (prefs_common.quotemark && *prefs_common.quotemark)
+		qmark = prefs_common.quotemark;
+	else
+		qmark = "> ";
+	quote_str = compose_quote_parse_fmt(compose, msginfo, qmark);
+	g_return_if_fail(quote_str != NULL);
+	qlen = strlen(quote_str);
+
+	if (!prefs_common.linewrap_quote ||
+	    prefs_common.linewrap_len <= qlen) {
+		while (fgets(buf, sizeof(buf), fp) != NULL) {
+			gtk_text_insert(text, NULL, qcolor, NULL,
+					quote_str, -1);
+			gtk_text_insert(text, NULL, qcolor, NULL, buf, -1);
+		}
+		g_free(quote_str);
+		return;
+	}
+
+	wrap_len = prefs_common.linewrap_len - qlen;
+
+	while (fgets(buf, sizeof(buf), fp) != NULL) {
+		strretchomp(buf);
+		str_len = strlen(buf);
+
+		if (str_len <= wrap_len) {
+			gtk_text_insert(text, NULL, qcolor, NULL,
+					quote_str, -1);
+			gtk_text_insert(text, NULL, qcolor, NULL, buf, -1);
+			gtk_text_insert(text, NULL, NULL, NULL, "\n", 1);
+			continue;
+		}
+
+		linep = cur = leftp = buf;
+		line_len = cur_len = 0;
+
+		while (*cur != '\0') {
+			ch_len = mblen(cur, MB_CUR_MAX);
+			if (ch_len < 0) ch_len = 1;
+
+			if (ch_len == 1 && isspace(*cur)) {
+				linep = cur + ch_len;
+				line_len = cur_len + ch_len;
+			}
+
+			if (cur_len + ch_len > wrap_len && line_len > 0) {
+				gtk_text_insert(text, NULL, qcolor, NULL,
+						quote_str, -1);
+
+				if (isspace(*(linep - 1)))
+					gtk_text_insert(text, NULL,
+							qcolor, NULL,
+							leftp, line_len - 1);
+				else
+					gtk_text_insert(text, NULL,
+							qcolor, NULL,
+							leftp, line_len);
+				gtk_text_insert(text, NULL, NULL, NULL,
+						"\n", 1);
+
+				leftp = linep;
+				cur_len = cur_len - line_len + ch_len;
+				line_len = 0;
+				cur += ch_len;
+				continue;
+			}
+
+			if (ch_len > 1) {
+				linep = cur + ch_len;
+				line_len = cur_len + ch_len;
+			}
+			cur_len += ch_len;
+			cur += ch_len;
+		}
+
+		if (*leftp) {
+			gtk_text_insert(text, NULL, qcolor, NULL,
+					quote_str, -1);
+			gtk_text_insert(text, NULL, qcolor, NULL, leftp, -1);
+			gtk_text_insert(text, NULL, NULL, NULL, "\n", 1);
+		}
+	}
+
+	g_free(quote_str);
+}
+
+static gchar *compose_quote_parse_fmt(Compose *compose, MsgInfo *msginfo,
+				      const gchar *fmt)
+{
+	gchar *ext_str;
+	size_t buf_len = 1024;
+	size_t ext_len = 0;
+	gchar *str;
+	gchar *mbs;
+	wchar_t *wcsfmt;
+	wchar_t *sp;
+	gchar tmp[3];
+
+	if (!fmt || *fmt == '\0') return 0;
+
+	Xalloca(mbs, sizeof(wchar_t) + 1, return 0);
+	Xalloca(wcsfmt, (strlen(fmt) + 1) * sizeof(wchar_t), return 0);
+	mbstowcs(wcsfmt, fmt, strlen(fmt) + 1);
+	sp = wcsfmt;
+
+	ext_str = g_malloc(sizeof(gchar) * buf_len);
+	g_return_val_if_fail(ext_str != NULL, NULL);
+
+	while (*sp) {
+		gint len;
+
+		len = wctomb(mbs, *sp);
+		mbs[len] = '\0';
+
+		if (*mbs == '%') {
+			gchar *p;
+
+			wctomb(mbs, *(++sp));
+			str = NULL;
+
+			switch (*mbs) {
+			case 'd':
+				str = msginfo->date;
+				sp++;
+				break;
+			case 'f':
+				str = msginfo->from;
+				sp++;
+				break;
+			case 'I':	/* initial */
+				if (!msginfo->fromname) {sp++; break;}
+				p = msginfo->fromname;
+				tmp[0] = tmp[1] = tmp[2] = '\0';
+
+				if (*p && isalnum(*p))
+					tmp[0] = toupper(*p);
+				else {
+					sp++;
+					break;
+				}
+
+				while (*p) {
+					while (*p && !isspace(*p)) p++;
+					while (*p && isspace(*p)) p++;
+					if (*p && isalnum(*p))
+						tmp[1] = toupper(*p);
+				}
+
+				if (tmp[1]) str = tmp;
+				sp++;
+				break;
+			case 'n':
+				str = msginfo->fromname;
+				sp++;
+				break;
+			case 'N':
+				if (!msginfo->fromname) {sp++; break;}
+				Xstrdup_a(str, msginfo->fromname,
+					  {sp++; break;});
+				p = str;
+				while (*p && !isspace(*p)) p++;
+				*p = '\0';
+				sp++;
+				break;
+			case 's':
+				str = msginfo->subject;
+				sp++;
+				break;
+			case 't':
+				str = msginfo->to;
+				sp++;
+				break;
+			case 'c':
+				str = msginfo->cc;
+				sp++;
+				break;
+			case 'i':
+				if (!msginfo->msgid) {sp++; break;}
+				Xalloca(str, strlen(msginfo->msgid) + 3,
+					{sp++; break;});
+				g_snprintf(str, strlen(msginfo->msgid) + 3,
+					   "<%s>", msginfo->msgid);
+				sp++;
+				break;
+			case '%':
+				str = "%";
+				sp++;
+				break;
+			default:
+				break;
+			}
+
+			if (str) {
+				while (ext_len + strlen(str) + 1 > buf_len)
+					buf_len += 1024;
+				ext_str = g_realloc(ext_str,
+						    sizeof(gchar) * buf_len);
+				g_return_val_if_fail(ext_str != NULL, NULL);
+				strcpy(ext_str + ext_len, str);
+				ext_len += strlen(str);
+			}
+		} else if (*mbs == '\\') {
+			wctomb(mbs, *(++sp));
+			str = NULL;
+
+			switch (*mbs) {
+			case 'n':
+				str = "\n";
+				break;
+			case 't':
+				str = "\t";
+				break;
+			case '\\':
+				str = "\\";
+				break;
+			default:
+				break;
+			}
+
+			if (str) {
+				while (ext_len + strlen(str) + 1 > buf_len)
+					buf_len += 1024;
+				ext_str = g_realloc(ext_str,
+						    sizeof(gchar) * buf_len);
+				g_return_val_if_fail(ext_str != NULL, NULL);
+				strcpy(ext_str + ext_len, str);
+				ext_len += strlen(str);
+				sp++;
+			}
+		} else {
+			while (ext_len + len + 1 > buf_len) buf_len += 1024;
+			ext_str = g_realloc(ext_str, sizeof(gchar) * buf_len);
+			g_return_val_if_fail(ext_str != NULL, NULL);
+			strcpy(ext_str + ext_len, mbs);
+			ext_len += len;
+			sp++;
+		}
+	}
+
+	if (ext_str)
+		ext_str = g_realloc(ext_str, strlen(ext_str) + 1);
+
+	return ext_str;
+}
+
+static void compose_reply_set_entry(Compose *compose, MsgInfo *msginfo,
+				    gboolean to_all, gboolean ignore_replyto)
+{
+	GSList *cc_list;
+	GSList *cur;
+	gchar *from;
+	GHashTable *to_table;
+
+	g_return_if_fail(compose->account != NULL);
+	g_return_if_fail(msginfo != NULL);
+
+	if (compose->account->protocol != A_NNTP)
+		gtk_entry_set_text(GTK_ENTRY(compose->to_entry),
+				   (compose->replyto && !ignore_replyto)
+				   ? compose->replyto
+				   : msginfo->from ? msginfo->from : "");
+	if (compose->account->protocol == A_NNTP)
+		gtk_entry_set_text(GTK_ENTRY(compose->newsgroups_entry),
+				   compose->followup_to ? compose->followup_to
+				   : compose->newsgroups ? compose->newsgroups
+				   : "");
+
+	if (msginfo->subject && *msginfo->subject) {
+		gchar *buf, *buf2, *p;
+
+		buf = g_strdup(msginfo->subject);
+		while (!strncasecmp(buf, "Re:", 3)) {
+			p = buf + 3;
+			while (isspace(*p)) p++;
+			memmove(buf, p, strlen(p) + 1);
+		}
+
+		buf2 = g_strdup_printf("Re: %s", buf);
+		gtk_entry_set_text(GTK_ENTRY(compose->subject_entry), buf2);
+		g_free(buf2);
+		g_free(buf);
+	} else
+		gtk_entry_set_text(GTK_ENTRY(compose->subject_entry), "Re: ");
+
+	if (!to_all || compose->account->protocol == A_NNTP) return;
+
+	from = g_strdup(compose->replyto ? compose->replyto :
+			msginfo->from ? msginfo->from : "");
+	extract_address(from);
+
+	cc_list = address_list_append(NULL, msginfo->to);
+	cc_list = address_list_append(cc_list, compose->cc);
+
+	to_table = g_hash_table_new(g_str_hash, g_str_equal);
+	g_hash_table_insert(to_table, from, GINT_TO_POINTER(1));
+	if (compose->account)
+		g_hash_table_insert(to_table, compose->account->address,
+				    GINT_TO_POINTER(1));
+
+	/* remove address on To: and that of current account */
+	for (cur = cc_list; cur != NULL; ) {
+		GSList *next = cur->next;
+
+		if (g_hash_table_lookup(to_table, cur->data) != NULL)
+			cc_list = g_slist_remove(cc_list, cur->data);
+		else
+			g_hash_table_insert(to_table, cur->data, cur);
+
+		cur = next;
+	}
+	g_hash_table_destroy(to_table);
+	g_free(from);
+
+	if (cc_list) {
+		for (cur = cc_list; cur != NULL; cur = cur->next)
+			compose_entry_append(compose, (gchar *)cur->data,
+					     COMPOSE_CC);
+		slist_free_strings(cc_list);
+		g_slist_free(cc_list);
+	}
+}
+
+#define SET_ENTRY(entry, str) \
+{ \
+	if (str && *str) \
+		gtk_entry_set_text(GTK_ENTRY(compose->entry), str); \
+}
+
+static void compose_reedit_set_entry(Compose *compose, MsgInfo *msginfo)
+{
+	g_return_if_fail(msginfo != NULL);
+
+	SET_ENTRY(to_entry, msginfo->to);
+	SET_ENTRY(subject_entry, msginfo->subject);
+	SET_ENTRY(cc_entry, compose->cc);
+	SET_ENTRY(bcc_entry, compose->bcc);
+	SET_ENTRY(reply_entry, compose->replyto);
+
+	if (compose->bcc) {
+		GtkItemFactory *ifactory;
+		GtkWidget *menuitem;
+
+		ifactory = gtk_item_factory_from_widget(compose->menubar);
+		menuitem = gtk_item_factory_get_item(ifactory, "/Message/Bcc");
+		gtk_check_menu_item_set_active
+			(GTK_CHECK_MENU_ITEM(menuitem), TRUE);
+	}
+	if (compose->replyto) {
+		GtkItemFactory *ifactory;
+		GtkWidget *menuitem;
+
+		ifactory = gtk_item_factory_from_widget(compose->menubar);
+		menuitem = gtk_item_factory_get_item
+			(ifactory, "/Message/Reply to");
+		gtk_check_menu_item_set_active
+			(GTK_CHECK_MENU_ITEM(menuitem), TRUE);
+	}
+}
+
+#undef SET_ENTRY
+
+static void compose_insert_sig(Compose *compose)
+{
+	gchar *sigfile;
+
+	if (compose->account && compose->account->sig_path)
+		sigfile = g_strdup(compose->account->sig_path);
+	else {
+		sigfile = g_strconcat(get_home_dir(), G_DIR_SEPARATOR_S,
+				      DEFAULT_SIGNATURE, NULL);
+	}
+
+	if (!is_file_or_fifo_exist(sigfile)) {
+		g_free(sigfile);
+		return;
+	}
+
+	gtk_text_insert(GTK_TEXT(compose->text), NULL, NULL, NULL, "\n\n", 2);
+	if (prefs_common.sig_sep) {
+		gtk_text_insert(GTK_TEXT(compose->text), NULL, NULL, NULL,
+				prefs_common.sig_sep, -1);
+		gtk_text_insert(GTK_TEXT(compose->text), NULL, NULL, NULL,
+				"\n", 1);
+	}
+
+	compose_insert_file(compose, sigfile);
+	g_free(sigfile);
+}
+
+static void compose_insert_file(Compose *compose, const gchar *file)
+{
+	GtkText *text = GTK_TEXT(compose->text);
+	gchar buf[BUFFSIZE];
+	FILE *fp;
+
+	g_return_if_fail(file != NULL);
+
+	if ((fp = fopen(file, "r")) == NULL) {
+		FILE_OP_ERROR(file, "fopen");
+		return;
+	}
+
+	gtk_text_freeze(text);
+
+	while (fgets(buf, sizeof(buf), fp) != NULL)
+		gtk_text_insert(text, NULL, NULL, NULL, buf, -1);
+
+	gtk_text_thaw(text);
+
+	fclose(fp);
+}
+
+static void compose_attach_append(Compose *compose, const gchar *file,
+				  ContentType cnttype)
+{
+	AttachInfo *ainfo;
+	gchar *text[N_ATTACH_COLS];
+	off_t size;
+	gint row;
+
+	if (!is_file_exist(file)) {
+		g_warning(_("File %s doesn't exist\n"), file);
+		return;
+	}
+	if ((size = get_file_size(file)) < 0) {
+		g_warning(_("Can't get file size of %s\n"), file);
+		return;
+	}
+	if (size == 0) {
+		alertpanel_notice(_("File %s is empty\n"), file);
+		return;
+	}
+
+	if (!compose->use_attach) {
+		GtkItemFactory *ifactory;
+		GtkWidget *menuitem;
+
+		ifactory = gtk_item_factory_from_widget(compose->menubar);
+		menuitem = gtk_item_factory_get_item(ifactory,
+						     "/Message/Attach");
+		gtk_check_menu_item_set_active(GTK_CHECK_MENU_ITEM(menuitem),
+					       TRUE);
+	}
+
+	ainfo = g_new0(AttachInfo, 1);
+	ainfo->file = g_strdup(file);
+
+	if (cnttype == MIME_MESSAGE_RFC822) {
+		ainfo->content_type = g_strdup("message/rfc822");
+		ainfo->encoding = ENC_7BIT;
+		ainfo->name = g_strdup_printf(_("Message: %s"),
+					      g_basename(file));
+	} else {
+		ainfo->content_type = procmime_get_mime_type(file);
+		if (!ainfo->content_type)
+			ainfo->content_type =
+				g_strdup("application/octet-stream");
+		ainfo->encoding = ENC_BASE64;
+		ainfo->name = g_strdup(g_basename(file));
+	}
+	ainfo->size = size;
+
+	text[COL_MIMETYPE] = ainfo->content_type;
+	text[COL_SIZE] = to_human_readable(size);
+	text[COL_NAME] = ainfo->name;
+
+	row = gtk_clist_append(GTK_CLIST(compose->attach_clist), text);
+	gtk_clist_set_row_data(GTK_CLIST(compose->attach_clist), row, ainfo);
+
+	if (cnttype != MIME_MESSAGE_RFC822)
+		compose_changed_cb(NULL, compose);
+}
+
+static void compose_wrap_line(Compose *compose)
+{
+	GtkText *text = GTK_TEXT(compose->text);
+	gint ch_len, last_ch_len;
+	gchar cbuf[MB_CUR_MAX], last_ch;
+	guint text_len;
+	guint line_end;
+	guint quoted;
+	gint p_start, p_end;
+	gint line_pos, cur_pos;
+	gint line_len, cur_len;
+
+#define GET_TEXT(pos)                                                        \
+	if (text->use_wchar)                                                 \
+		ch_len = wctomb(cbuf, (wchar_t)GTK_TEXT_INDEX(text, (pos))); \
+	else {                                                               \
+		cbuf[0] = GTK_TEXT_INDEX(text, (pos));                       \
+		ch_len = 1;                                                  \
+	}
+
+	gtk_text_freeze(text);
+
+	text_len = gtk_text_get_length(text);
+
+	/* check to see if the point is on the paragraph mark (empty line). */
+	cur_pos = gtk_text_get_point(text);
+	GET_TEXT(cur_pos);
+	if ((ch_len == 1 && *cbuf == '\n') || cur_pos == text_len) {
+		if (cur_pos == 0)
+			goto compose_end; /* on the paragraph mark */
+		GET_TEXT(cur_pos - 1);
+		if (ch_len == 1 && *cbuf == '\n')
+			goto compose_end; /* on the paragraph mark */
+	}
+
+	/* find paragraph start. */
+	line_end = quoted = 0;
+	for (p_start = cur_pos; p_start >= 0; --p_start) {
+		GET_TEXT(p_start);
+		if (ch_len == 1 && *cbuf == '\n') {
+			if (quoted)
+				goto compose_end; /* quoted part */
+			if (line_end) {
+				p_start += 2;
+				break;
+			}
+			line_end = 1;
+		} else {
+			if (ch_len == 1 && strchr(">:#", *cbuf))
+				quoted = 1;
+			else if (ch_len != 1 || !isspace(*cbuf))
+				quoted = 0;
+
+			line_end = 0;
+		}
+	}
+	if (p_start < 0)
+		p_start = 0;
+
+	/* find paragraph end. */
+	line_end = 0;
+	for (p_end = cur_pos; p_end < text_len; p_end++) {
+		GET_TEXT(p_end);
+		if (ch_len == 1 && *cbuf == '\n') {
+			if (line_end) {
+				p_end -= 1;
+				break;
+			}
+			line_end = 1;
+		} else {
+			if (line_end && ch_len == 1 && strchr(">:#", *cbuf))
+				goto compose_end; /* quoted part */
+
+			line_end = 0;
+		}
+	}
+	if (p_end >= text_len)
+		p_end = text_len;
+
+	if (p_start >= p_end)
+		goto compose_end;
+
+	line_len = cur_len = 0;
+	last_ch_len = 0;
+	last_ch = '\0';
+	line_pos = p_start;
+	for (cur_pos = p_start; cur_pos < p_end; cur_pos++) {
+		guint space = 0;
+
+		GET_TEXT(cur_pos);
+
+		if (ch_len < 0) {
+			cbuf[0] = '\0';
+			ch_len = 1;
+		}
+
+		if (ch_len == 1 && isspace(*cbuf))
+			space = 1;
+
+		if (ch_len == 1 && *cbuf == '\n') {
+			guint replace = 0;
+			if (last_ch_len == 1 && !isspace(last_ch)) {
+				if (cur_pos + 1 < p_end) {
+					GET_TEXT(cur_pos + 1);
+					if (ch_len == 1 && !isspace(*cbuf))
+						replace = 1;
+				}
+			}
+			gtk_text_set_point(text, cur_pos + 1);
+			gtk_text_backward_delete(text, 1);
+			if (replace) {
+				gtk_text_set_point(text, cur_pos);
+				gtk_text_insert(text, NULL, NULL, NULL, " ", 1);
+				space = 1;
+			}
+			else {
+				p_end--;
+				cur_pos--;
+				continue;
+			}
+		}
+
+		last_ch_len = ch_len;
+		last_ch = *cbuf;
+
+		if (space) {
+			line_pos = cur_pos + 1;
+			line_len = cur_len + ch_len;
+		}
+
+		if (cur_len + ch_len > prefs_common.linewrap_len &&
+		    line_len > 0) {
+			gint tlen = ch_len;
+
+			GET_TEXT(line_pos - 1);
+			if (ch_len == 1 && isspace(*cbuf)) {
+				gtk_text_set_point(text, line_pos);
+				gtk_text_backward_delete(text, 1);
+				p_end--;
+				cur_pos--;
+				line_pos--;
+				cur_len--;
+				line_len--;
+			}
+			ch_len = tlen;
+
+			gtk_text_set_point(text, line_pos);
+			gtk_text_insert(text, NULL, NULL, NULL, "\n", 1);
+			p_end++;
+			cur_pos++;
+			line_pos++;
+			cur_len = cur_len - line_len + ch_len;
+			line_len = 0;
+			continue;
+		}
+
+		if (ch_len > 1) {
+			line_pos = cur_pos + 1;
+			line_len = cur_len + ch_len;
+		}
+		cur_len += ch_len;
+	}
+
+compose_end:
+	gtk_text_thaw(text);
+
+#undef GET_TEXT
+}
+
+static void compose_wrap_line_all(Compose *compose)
+{
+	GtkText *text = GTK_TEXT(compose->text);
+	guint text_len;
+	guint line_pos = 0, cur_pos = 0;
+	gint line_len = 0, cur_len = 0;
+	gint ch_len;
+	gchar cbuf[MB_CUR_MAX];
+
+	gtk_text_freeze(text);
+
+	text_len = gtk_text_get_length(text);
+
+	for (; cur_pos < text_len; cur_pos++) {
+		if (text->use_wchar)
+			ch_len = wctomb
+				(cbuf, (wchar_t)GTK_TEXT_INDEX(text, cur_pos));
+		else {
+			cbuf[0] = GTK_TEXT_INDEX(text, cur_pos);
+			ch_len = 1;
+		}
+
+		if (ch_len == 1 && *cbuf == '\n') {
+			line_pos = cur_pos + 1;
+			line_len = cur_len = 0;
+			continue;
+		}
+
+		if (ch_len < 0) {
+			cbuf[0] = '\0';
+			ch_len = 1;
+		}
+
+		if (ch_len == 1 && isspace(*cbuf)) {
+			line_pos = cur_pos + 1;
+			line_len = cur_len + ch_len;
+		}
+
+		if (cur_len + ch_len > prefs_common.linewrap_len &&
+		    line_len > 0) {
+			gint tlen;
+
+			if (text->use_wchar)
+				tlen = wctomb(cbuf, (wchar_t)GTK_TEXT_INDEX(text, line_pos - 1));
+			else {
+				cbuf[0] = GTK_TEXT_INDEX(text, line_pos - 1);
+				tlen = 1;
+			}
+			if (tlen == 1 && isspace(*cbuf)) {
+				gtk_text_set_point(text, line_pos);
+				gtk_text_backward_delete(text, 1);
+				text_len--;
+				cur_pos--;
+				line_pos--;
+				cur_len--;
+				line_len--;
+			}
+
+			gtk_text_set_point(text, line_pos);
+			gtk_text_insert(text, NULL, NULL, NULL, "\n", 1);
+			text_len++;
+			cur_pos++;
+			line_pos++;
+			cur_len = cur_len - line_len + ch_len;
+			line_len = 0;
+			continue;
+		}
+
+		if (ch_len > 1) {
+			line_pos = cur_pos + 1;
+			line_len = cur_len + ch_len;
+		}
+		cur_len += ch_len;
+	}
+
+	gtk_text_thaw(text);
+}
+
+static void compose_set_title(Compose *compose)
+{
+	gchar *str;
+	gchar *edited;
+
+	edited = compose->modified ? _(" [Edited]") : "";
+	if (compose->account && compose->account->address)
+		str = g_strdup_printf(_("%s - Compose message%s"),
+				      compose->account->address, edited);
+	else
+		str = g_strdup_printf(_("Compose message%s"), edited);
+	gtk_window_set_title(GTK_WINDOW(compose->window), str);
+	g_free(str);
+}
+
+static gint compose_send(Compose *compose)
+{
+	gchar tmp[MAXPATHLEN + 1];
+	gchar *to, *newsgroups;
+	gint ok = 0;
+	static gboolean lock = FALSE;
+
+	if (lock) return 1;
+
+	g_return_val_if_fail(compose->account != NULL, -1);
+	g_return_val_if_fail(compose->orig_account != NULL, -1);
+
+	lock = TRUE;
+
+	to = gtk_entry_get_text(GTK_ENTRY(compose->to_entry));
+	newsgroups = gtk_entry_get_text(GTK_ENTRY(compose->newsgroups_entry));
+	if (*to == '\0' && *newsgroups == '\0') {
+		alertpanel_error(_("Recipient is not specified."));
+		lock = FALSE;
+		return 1;
+	}
+
+	/* write to temporary file */
+	g_snprintf(tmp, sizeof(tmp), "%s%ctmpmsg%d",
+		   get_rc_dir(), G_DIR_SEPARATOR, (gint)compose);
+
+	if (prefs_common.linewrap_at_send)
+		compose_wrap_line_all(compose);
+
+	if (compose_write_to_file(compose, tmp, FALSE) < 0) {
+		lock = FALSE;
+		return -1;
+	}
+
+	if (!compose->to_list && !compose->newsgroup_list) {
+		g_warning(_("can't get recipient list."));
+		unlink(tmp);
+		lock = FALSE;
+		return -1;
+	}
+
+	if (compose->to_list) {
+		PrefsAccount *ac;
+
+		if (compose->account->protocol != A_NNTP)
+			ac = compose->account;
+		else if (compose->orig_account->protocol != A_NNTP)
+			ac = compose->orig_account;
+		else if (cur_account && cur_account->protocol != A_NNTP)
+			ac = cur_account;
+		else {
+			ac = account_get_default();
+			if (!ac || ac->protocol == A_NNTP) {
+				alertpanel_error(_("Account for sending mail is not specified.\n"
+						   "Please select a mail account before sending."));
+				unlink(tmp);
+				lock = FALSE;
+				return -1;
+			}
+		}
+		ok = send_message(tmp, ac, compose->to_list);
+		statusbar_pop_all();
+	}
+
+	if (ok == 0 && compose->newsgroup_list) {
+		Folder *folder;
+
+		if (compose->account->protocol == A_NNTP)
+			folder = FOLDER(compose->account->folder);
+		else
+			folder = FOLDER(compose->orig_account->folder);
+
+		ok = news_post(folder, tmp);
+		if (ok < 0) {
+			alertpanel_error(_("Error occurred while posting the message to %s ."),
+					 compose->account->nntp_server);
+			unlink(tmp);
+			lock = FALSE;
+			return -1;
+		}
+	}
+
+	/* queue message if failed to send */
+	if (ok < 0) {
+		if (prefs_common.queue_msg) {
+			AlertValue val;
+
+			val = alertpanel
+				(_("Queueing"),
+				 _("Error occurred while sending the message.\n"
+				   "Put this message into queue folder?"),
+				 _("OK"), _("Cancel"), NULL);
+			if (G_ALERTDEFAULT == val) {
+				ok = compose_queue(compose, tmp);
+				if (ok < 0)
+					alertpanel_error(_("Can't queue the message."));
+			}
+		} else
+			alertpanel_error(_("Error occurred while sending the message."));
+	} else {
+		if (compose->mode == COMPOSE_REEDIT) {
+			compose_remove_reedit_target(compose);
+			if (compose->targetinfo)
+				folderview_update_item
+					(compose->targetinfo->folder, TRUE);
+		}
+	}
+
+	/* save message to outbox */
+	if (ok == 0 && prefs_common.savemsg) {
+		if (compose_save_to_outbox(compose, tmp) < 0)
+			alertpanel_error
+				(_("Can't save the message to outbox."));
+	}
+
+	unlink(tmp);
+	lock = FALSE;
+	return ok;
+}
+
+static gint compose_write_to_file(Compose *compose, const gchar *file,
+				  gboolean is_draft)
+{
+	FILE *fp;
+	size_t len;
+	gchar *chars;
+	gchar *buf;
+	const gchar *out_codeset;
+	EncodingType encoding;
+
+	if ((fp = fopen(file, "w")) == NULL) {
+		FILE_OP_ERROR(file, "fopen");
+		return -1;
+	}
+
+	/* chmod for security */
+	if (change_file_mode_rw(fp, file) < 0) {
+		FILE_OP_ERROR(file, "chmod");
+		g_warning(_("can't change file mode\n"));
+	}
+
+	/* get all composed text */
+	chars = gtk_editable_get_chars(GTK_EDITABLE(compose->text), 0, -1);
+	len = strlen(chars);
+	if (is_ascii_str(chars)) {
+		buf = g_strdup(chars);
+		out_codeset = "US-ASCII";
+		encoding = ENC_7BIT;
+	} else {
+		const gchar *src_codeset;
+
+		out_codeset = conv_get_outgoing_charset_str();
+		if (!strcasecmp(out_codeset, "US-ASCII"))
+			out_codeset = "ISO-8859-1";
+		encoding = procmime_get_encoding_for_charset(out_codeset);
+		debug_print("charset = %s, encoding = %s\n",
+			    out_codeset, procmime_get_encoding_str(encoding));
+
+		src_codeset = conv_get_current_charset_str();
+		buf = conv_codeset_strdup(chars, src_codeset, out_codeset);
+		if (!buf) {
+			g_free(chars);
+			fclose(fp);
+			unlink(file);
+			alertpanel_error(_("Can't convert the codeset of the message."));
+			return -1;
+		}
+	}
+	g_free(chars);
+
+	/* write headers */
+	if (compose_write_headers
+		(compose, fp, out_codeset, encoding, is_draft) < 0) {
+		g_warning(_("can't write headers\n"));
+		fclose(fp);
+		unlink(file);
+		g_free(buf);
+		return -1;
+	}
+
+	if (compose->use_attach &&
+	    GTK_CLIST(compose->attach_clist)->row_list) {
+#if USE_GPGME
+            /* This prolog message is ignored by mime software and
+             * because it would make our signing/encryption task
+             * tougher, we don't emit it in that case */
+            if (!compose->use_signing && !compose->use_encryption)
+#endif
+		fputs("This is a multi-part message in MIME format.\n", fp);
+
+		fprintf(fp, "\n--%s\n", compose->boundary);
+		fprintf(fp, "Content-Type: text/plain; charset=%s\n",
+			out_codeset);
+		fprintf(fp, "Content-Transfer-Encoding: %s\n",
+			procmime_get_encoding_str(encoding));
+		fputc('\n', fp);
+	}
+
+	/* write body */
+	len = strlen(buf);
+	if (encoding == ENC_BASE64) {
+		gchar outbuf[B64_BUFFSIZE];
+		gint i, l;
+
+		for (i = 0; i < len; i += B64_LINE_SIZE) {
+			l = MIN(B64_LINE_SIZE, len - i);
+			to64frombits(outbuf, buf + i, l);
+			fputs(outbuf, fp);
+			fputc('\n', fp);
+		}
+	} else if (fwrite(buf, sizeof(gchar), len, fp) != len) {
+		FILE_OP_ERROR(file, "fwrite");
+		fclose(fp);
+		unlink(file);
+		g_free(buf);
+		return -1;
+	}
+	g_free(buf);
+
+	if (compose->use_attach &&
+	    GTK_CLIST(compose->attach_clist)->row_list)
+		compose_write_attach(compose, fp);
+
+	if (fclose(fp) == EOF) {
+		FILE_OP_ERROR(file, "fclose");
+		unlink(file);
+		return -1;
+	}
+
+#if USE_GPGME
+	if (compose->use_signing) {
+		if (rfc2015_sign(file, compose->account) < 0) {
+			unlink(file);
+			return -1;
+		}
+	}
+	if (compose->use_encryption) {
+		if (rfc2015_encrypt(file, compose->to_list) < 0) {
+			unlink(file);
+			return -1;
+		}
+	}
+#endif /* USE_GPGME */
+
+	return 0;
+}
+
+static gint compose_write_body_to_file(Compose *compose, const gchar *file)
+{
+	FILE *fp;
+	size_t len;
+	gchar *chars;
+
+	if ((fp = fopen(file, "w")) == NULL) {
+		FILE_OP_ERROR(file, "fopen");
+		return -1;
+	}
+
+	/* chmod for security */
+	if (change_file_mode_rw(fp, file) < 0) {
+		FILE_OP_ERROR(file, "chmod");
+		g_warning(_("can't change file mode\n"));
+	}
+
+	chars = gtk_editable_get_chars(GTK_EDITABLE(compose->text), 0, -1);
+
+	/* write body */
+	len = strlen(chars);
+	if (fwrite(chars, sizeof(gchar), len, fp) != len) {
+		FILE_OP_ERROR(file, "fwrite");
+		g_free(chars);
+		fclose(fp);
+		unlink(file);
+		return -1;
+	}
+
+	g_free(chars);
+
+	if (fclose(fp) == EOF) {
+		FILE_OP_ERROR(file, "fclose");
+		unlink(file);
+		return -1;
+	}
+	return 0;
+}
+
+static gint compose_save_to_outbox(Compose *compose, const gchar *file)
+{
+	FolderItem *outbox;
+	gchar *path;
+	gint num;
+	FILE *fp;
+
+	debug_print(_("saving sent message...\n"));
+
+	outbox = folder_get_default_outbox();
+	folder_item_scan(outbox);
+	if ((num = folder_item_add_msg(outbox, file, FALSE)) < 0) {
+		g_warning(_("can't save message\n"));
+		return -1;
+	}
+
+	path = folder_item_get_path(outbox);
+	if ((fp = procmsg_open_mark_file(path, TRUE)) == NULL)
+		g_warning(_("can't open mark file\n"));
+	else {
+		MsgInfo newmsginfo;
+
+		newmsginfo.msgnum = num;
+		newmsginfo.flags.perm_flags = 0;
+		newmsginfo.flags.tmp_flags = 0;
+		procmsg_write_flags(&newmsginfo, fp);
+		fclose(fp);
+	}
+	g_free(path);
+
+	return 0;
+}
+
+static gint compose_remove_reedit_target(Compose *compose)
+{
+	FolderItem *item;
+	MsgInfo *msginfo = compose->targetinfo;
+
+	g_return_val_if_fail(compose->mode == COMPOSE_REEDIT, -1);
+	if (!msginfo) return -1;
+
+	item = msginfo->folder;
+	g_return_val_if_fail(item != NULL, -1);
+
+	folder_item_scan(item);
+	if (procmsg_msg_exist(msginfo) &&
+	    (item->stype == F_DRAFT || item->stype == F_QUEUE)) {
+		if (folder_item_remove_msg(item, msginfo->msgnum) < 0) {
+			g_warning(_("can't remove the old message\n"));
+			return -1;
+		}
+	}
+
+	return 0;
+}
+
+static gint compose_queue(Compose *compose, const gchar *file)
+{
+	FolderItem *queue;
+	gchar *tmp, *queue_path;
+	FILE *fp, *src_fp;
+	GSList *cur;
+	gchar buf[BUFFSIZE];
+	gint num;
+
+	debug_print(_("queueing message...\n"));
+	g_return_val_if_fail(compose->to_list != NULL, -1);
+	g_return_val_if_fail(compose->account != NULL, -1);
+
+	tmp = g_strdup_printf("%s%cqueue.%d", g_get_tmp_dir(),
+			      G_DIR_SEPARATOR, (gint)compose);
+	if ((fp = fopen(tmp, "w")) == NULL) {
+		FILE_OP_ERROR(tmp, "fopen");
+		g_free(tmp);
+		return -1;
+	}
+	if ((src_fp = fopen(file, "r")) == NULL) {
+		FILE_OP_ERROR(file, "fopen");
+		fclose(fp);
+		unlink(tmp);
+		g_free(tmp);
+		return -1;
+	}
+	if (change_file_mode_rw(fp, tmp) < 0) {
+		FILE_OP_ERROR(tmp, "chmod");
+		g_warning(_("can't change file mode\n"));
+	}
+
+	/* queueing variables */
+	fprintf(fp, "AF:\n");
+	fprintf(fp, "NF:0\n");
+	fprintf(fp, "PS:10\n");
+	fprintf(fp, "SRH:1\n");
+	fprintf(fp, "SFN:\n");
+	fprintf(fp, "DSR:\n");
+	if (compose->msgid)
+		fprintf(fp, "MID:<%s>\n", compose->msgid);
+	else
+		fprintf(fp, "MID:\n");
+	fprintf(fp, "CFG:\n");
+	fprintf(fp, "PT:0\n");
+	fprintf(fp, "S:%s\n", compose->account->address);
+	fprintf(fp, "RQ:\n");
+	if (compose->account->smtp_server)
+		fprintf(fp, "SSV:%s\n", compose->account->smtp_server);
+	else
+		fprintf(fp, "SSV:\n");
+	if (compose->account->nntp_server)
+		fprintf(fp, "NSV:%s\n", compose->account->nntp_server);
+	else
+		fprintf(fp, "NSV:\n");
+	fprintf(fp, "SSH:\n");
+	fprintf(fp, "R:<%s>", (gchar *)compose->to_list->data);
+	for (cur = compose->to_list->next; cur != NULL; cur = cur->next)
+		fprintf(fp, ",<%s>", (gchar *)cur->data);
+	fprintf(fp, "\n");
+	/* Sylpheed account ID */
+	fprintf(fp, "AID:%d\n", compose->account->account_id);
+	fprintf(fp, "\n");
+
+	while (fgets(buf, sizeof(buf), src_fp) != NULL) {
+		if (fputs(buf, fp) == EOF) {
+			FILE_OP_ERROR(tmp, "fputs");
+			fclose(fp);
+			fclose(src_fp);
+			unlink(tmp);
+			g_free(tmp);
+			return -1;
+		}
+	}
+
+	fclose(src_fp);
+	if (fclose(fp) == EOF) {
+		FILE_OP_ERROR(tmp, "fclose");
+		unlink(tmp);
+		g_free(tmp);
+		return -1;
+	}
+
+	queue = folder_get_default_queue();
+
+	folder_item_scan(queue);
+	if ((num = folder_item_add_msg(queue, tmp, TRUE)) < 0) {
+		g_warning(_("can't queue the message\n"));
+		unlink(tmp);
+		g_free(tmp);
+		return -1;
+	}
+	g_free(tmp);
+
+	if (compose->mode == COMPOSE_REEDIT) {
+		compose_remove_reedit_target(compose);
+		if (compose->targetinfo &&
+		    compose->targetinfo->folder != queue)
+			folderview_update_item
+				(compose->targetinfo->folder, TRUE);
+	}
+
+	queue_path = folder_item_get_path(queue);
+	if ((fp = procmsg_open_mark_file(queue_path, TRUE)) == NULL)
+		g_warning(_("can't open mark file\n"));
+	else {
+		MsgInfo newmsginfo;
+
+		newmsginfo.msgnum = num;
+		newmsginfo.flags.perm_flags = 0;
+		newmsginfo.flags.tmp_flags = 0;
+		procmsg_write_flags(&newmsginfo, fp);
+		fclose(fp);
+	}
+	g_free(queue_path);
+
+	folder_item_scan(queue);
+	folderview_update_item(queue, TRUE);
+
+	return 0;
+}
+
+static void compose_write_attach(Compose *compose, FILE *fp)
+{
+	AttachInfo *ainfo;
+	GtkCList *clist = GTK_CLIST(compose->attach_clist);
+	gint row;
+	FILE *attach_fp;
+	gchar filename[BUFFSIZE];
+	gint len;
+
+	for (row = 0; (ainfo = gtk_clist_get_row_data(clist, row)) != NULL;
+	     row++) {
+		if ((attach_fp = fopen(ainfo->file, "r")) == NULL) {
+			g_warning(_("Can't open file %s\n"), ainfo->file);
+			continue;
+		}
+
+		fprintf(fp, "\n--%s\n", compose->boundary);
+
+		if (!strcmp2(ainfo->content_type, "message/rfc822")) {
+			fprintf(fp, "Content-Type: %s\n", ainfo->content_type);
+			fprintf(fp, "Content-Disposition: inline\n");
+		} else {
+			conv_encode_header(filename, sizeof(filename),
+					   ainfo->name, 12);
+			fprintf(fp, "Content-Type: %s;\n"
+				    " name=\"%s\"\n",
+				ainfo->content_type, filename);
+			fprintf(fp, "Content-Disposition: attachment;\n"
+				    " filename=\"%s\"\n", filename);
+		}
+
+		fprintf(fp, "Content-Transfer-Encoding: %s\n\n",
+			procmime_get_encoding_str(ainfo->encoding));
+
+		if (ainfo->encoding == ENC_7BIT) {
+			gchar buf[BUFFSIZE];
+
+			while (fgets(buf, sizeof(buf), attach_fp) != NULL) {
+				len = strlen(buf);
+				if (len > 1 && buf[len - 1] == '\n' &&
+				    buf[len - 2] == '\r') {
+					buf[len - 2] = '\n';
+					buf[len - 1] = '\0';
+				}
+				fputs(buf, fp);
+			}
+		} else {
+			gchar inbuf[B64_LINE_SIZE], outbuf[B64_BUFFSIZE];
+
+			while ((len = fread(inbuf, sizeof(gchar),
+					    B64_LINE_SIZE, attach_fp))
+			       == B64_LINE_SIZE) {
+				to64frombits(outbuf, inbuf, B64_LINE_SIZE);
+				fputs(outbuf, fp);
+				fputc('\n', fp);
+			}
+			if (len > 0 && feof(attach_fp)) {
+				to64frombits(outbuf, inbuf, len);
+				fputs(outbuf, fp);
+				fputc('\n', fp);
+			}
+		}
+
+		fclose(attach_fp);
+	}
+
+	fprintf(fp, "\n--%s--\n", compose->boundary);
+}
+
+#define IS_IN_CUSTOM_HEADER(header) \
+	(compose->account->add_customhdr && \
+	 custom_header_find(compose->account->customhdr_list, header) != NULL)
+
+static gint compose_write_headers(Compose *compose, FILE *fp,
+				  const gchar *charset, EncodingType encoding,
+				  gboolean is_draft)
+{
+	gchar buf[BUFFSIZE];
+	gchar *str;
+	/* struct utsname utsbuf; */
+
+	g_return_val_if_fail(fp != NULL, -1);
+	g_return_val_if_fail(charset != NULL, -1);
+	g_return_val_if_fail(compose->account != NULL, -1);
+	g_return_val_if_fail(compose->account->address != NULL, -1);
+
+	/* Date */
+	if (compose->account->add_date) {
+		get_rfc822_date(buf, sizeof(buf));
+		fprintf(fp, "Date: %s\n", buf);
+	}
+
+	/* From */
+	if (compose->account->name && *compose->account->name) {
+		compose_convert_header
+			(buf, sizeof(buf), compose->account->name,
+			 strlen("From: "));
+		fprintf(fp, "From: %s <%s>\n",
+			buf, compose->account->address);
+	} else
+		fprintf(fp, "From: %s\n", compose->account->address);
+
+	slist_free_strings(compose->to_list);
+	g_slist_free(compose->to_list);
+	compose->to_list = NULL;
+
+	/* To */
+	if (compose->use_to) {
+		str = gtk_entry_get_text(GTK_ENTRY(compose->to_entry));
+		if (*str != '\0') {
+			Xstrdup_a(str, str, return -1);
+			g_strstrip(str);
+			if (*str != '\0') {
+				compose->to_list = address_list_append
+					(compose->to_list, str);
+				compose_convert_header
+					(buf, sizeof(buf), str,
+					 strlen("To: "));
+				fprintf(fp, "To: %s\n", buf);
+			}
+		}
+	}
+
+	slist_free_strings(compose->newsgroup_list);
+	g_slist_free(compose->newsgroup_list);
+	compose->newsgroup_list = NULL;
+
+	/* Newsgroups */
+	str = gtk_entry_get_text(GTK_ENTRY(compose->newsgroups_entry));
+	if (*str != '\0') {
+		Xstrdup_a(str, str, return -1);
+		g_strstrip(str);
+		remove_space(str);
+		if (*str != '\0') {
+			compose->newsgroup_list =
+				newsgroup_list_append(compose->newsgroup_list,
+						      str);
+			if (!IS_IN_CUSTOM_HEADER("Newsgroups")) {
+				compose_convert_header(buf, sizeof(buf), str,
+						       strlen("Newsgroups: "));
+				fprintf(fp, "Newsgroups: %s\n", buf);
+			}
+		}
+	}
+
+	if (!is_draft && !compose->to_list && !compose->newsgroup_list)
+		return -1;
+
+	/* Cc */
+	if (compose->use_cc) {
+		str = gtk_entry_get_text(GTK_ENTRY(compose->cc_entry));
+		if (*str != '\0') {
+			Xstrdup_a(str, str, return -1);
+			g_strstrip(str);
+			if (*str != '\0') {
+				compose->to_list = address_list_append
+					(compose->to_list, str);
+				if (!IS_IN_CUSTOM_HEADER("Cc")) {
+					compose_convert_header
+						(buf, sizeof(buf), str,
+						 strlen("Cc: "));
+					fprintf(fp, "Cc: %s\n", buf);
+				}
+			}
+		}
+	}
+
+	/* Bcc */
+	if (compose->use_bcc) {
+		str = gtk_entry_get_text(GTK_ENTRY(compose->bcc_entry));
+		if (*str != '\0') {
+			Xstrdup_a(str, str, return -1);
+			g_strstrip(str);
+			if (*str != '\0') {
+				compose->to_list = address_list_append
+					(compose->to_list, str);
+				compose_convert_header(buf, sizeof(buf), str,
+						       strlen("Bcc: "));
+				fprintf(fp, "Bcc: %s\n", buf);
+			}
+		}
+	}
+
+	/* Subject */
+	str = gtk_entry_get_text(GTK_ENTRY(compose->subject_entry));
+	if (*str != '\0' && !IS_IN_CUSTOM_HEADER("Subject")) {
+		Xstrdup_a(str, str, return -1);
+		g_strstrip(str);
+		if (*str != '\0') {
+			compose_convert_header(buf, sizeof(buf), str,
+					       strlen("Subject: "));
+			fprintf(fp, "Subject: %s\n", buf);
+		}
+	}
+
+	/* Message-ID */
+	if (compose->account->gen_msgid) {
+		compose_generate_msgid(compose, buf, sizeof(buf));
+		fprintf(fp, "Message-Id: <%s>\n", buf);
+		compose->msgid = g_strdup(buf);
+	}
+
+	/* In-Reply-To */
+	if (compose->inreplyto && compose->to_list)
+		fprintf(fp, "In-Reply-To: <%s>\n", compose->inreplyto);
+
+	/* References */
+	if (compose->references)
+		fprintf(fp, "References: %s\n", compose->references);
+
+	/* Followup-To */
+	if (compose->use_followupto && !IS_IN_CUSTOM_HEADER("Followup-To")) {
+		str = gtk_entry_get_text(GTK_ENTRY(compose->followup_entry));
+		if (*str != '\0') {
+			Xstrdup_a(str, str, return -1);
+			g_strstrip(str);
+			remove_space(str);
+			if (*str != '\0') {
+				compose_convert_header(buf, sizeof(buf), str,
+						       strlen("Followup-To: "));
+				fprintf(fp, "Followup-To: %s\n", buf);
+			}
+		}
+	}
+
+	/* Reply-To */
+	if (compose->use_replyto && !IS_IN_CUSTOM_HEADER("Reply-To")) {
+		str = gtk_entry_get_text(GTK_ENTRY(compose->reply_entry));
+		if (*str != '\0') {
+			Xstrdup_a(str, str, return -1);
+			g_strstrip(str);
+			if (*str != '\0') {
+				compose_convert_header(buf, sizeof(buf), str,
+						       strlen("Reply-To: "));
+				fprintf(fp, "Reply-To: %s\n", buf);
+			}
+		}
+	}
+
+	/* Organization */
+	if (compose->account->organization &&
+	    !IS_IN_CUSTOM_HEADER("Organization")) {
+		compose_convert_header(buf, sizeof(buf),
+				       compose->account->organization,
+				       strlen("Organization: "));
+		fprintf(fp, "Organization: %s\n", buf);
+	}
+
+	/* Program version and system info */
+	/* uname(&utsbuf); */
+	str = gtk_entry_get_text(GTK_ENTRY(compose->to_entry));
+	if (*str != '\0' && !IS_IN_CUSTOM_HEADER("X-Mailer")) {
+		fprintf(fp, "X-Mailer: %s (GTK+ %d.%d.%d; %s)\n",
+			prog_version,
+			gtk_major_version, gtk_minor_version, gtk_micro_version,
+			HOST_ALIAS);
+			/* utsbuf.sysname, utsbuf.release, utsbuf.machine); */
+	}
+	str = gtk_entry_get_text(GTK_ENTRY(compose->newsgroups_entry));
+	if (*str != '\0' && !IS_IN_CUSTOM_HEADER("X-Newsreader")) {
+		fprintf(fp, "X-Newsreader: %s (GTK+ %d.%d.%d; %s)\n",
+			prog_version,
+			gtk_major_version, gtk_minor_version, gtk_micro_version,
+			HOST_ALIAS);
+			/* utsbuf.sysname, utsbuf.release, utsbuf.machine); */
+	}
+
+	/* custom headers */
+	if (compose->account->add_customhdr) {
+		GSList *cur;
+
+		for (cur = compose->account->customhdr_list; cur != NULL;
+		     cur = cur->next) {
+			CustomHeader *chdr = (CustomHeader *)cur->data;
+
+			if (strcasecmp(chdr->name, "Date")         != 0 &&
+			    strcasecmp(chdr->name, "From")         != 0 &&
+			    strcasecmp(chdr->name, "To")           != 0 &&
+			    strcasecmp(chdr->name, "Sender")       != 0 &&
+			    strcasecmp(chdr->name, "Message-Id")   != 0 &&
+			    strcasecmp(chdr->name, "In-Reply-To")  != 0 &&
+			    strcasecmp(chdr->name, "References")   != 0 &&
+			    strcasecmp(chdr->name, "Mime-Version") != 0 &&
+			    strcasecmp(chdr->name, "Content-Type") != 0 &&
+			    strcasecmp(chdr->name, "Content-Transfer-Encoding")
+			    != 0)
+				compose_convert_header
+					(buf, sizeof(buf),
+					 chdr->value ? chdr->value : "",
+					 strlen(chdr->name) + 2);
+				fprintf(fp, "%s: %s\n", chdr->name, buf);
+		}
+	}
+
+	/* MIME */
+	fprintf(fp, "Mime-Version: 1.0\n");
+	if (compose->use_attach &&
+	    GTK_CLIST(compose->attach_clist)->row_list) {
+		get_rfc822_date(buf, sizeof(buf));
+		subst_char(buf, ' ', '_');
+		subst_char(buf, ',', '_');
+		compose->boundary = g_strdup_printf("Multipart_%s_%08x",
+						    buf, (guint)compose);
+		fprintf(fp,
+			"Content-Type: multipart/mixed;\n"
+			" boundary=\"%s\"\n", compose->boundary);
+	} else {
+		fprintf(fp, "Content-Type: text/plain; charset=%s\n", charset);
+		fprintf(fp, "Content-Transfer-Encoding: %s\n",
+			procmime_get_encoding_str(encoding));
+	}
+
+	/* separator between header and body */
+	fputs("\n", fp);
+
+	return 0;
+}
+
+#undef IS_IN_CUSTOM_HEADER
+
+static void compose_convert_header(gchar *dest, gint len, gchar *src,
+				   gint header_len)
+{
+	g_return_if_fail(src != NULL);
+	g_return_if_fail(dest != NULL);
+
+	if (len < 1) return;
+
+	remove_return(src);
+
+	if (is_ascii_str(src)) {
+		strncpy2(dest, src, len);
+		dest[len - 1] = '\0';
+		return;
+	} else
+		conv_encode_header(dest, len, src, header_len);
+}
+
+static void compose_generate_msgid(Compose *compose, gchar *buf, gint len)
+{
+	struct tm *lt;
+	time_t t;
+	gchar *addr;
+
+	t = time(NULL);
+	lt = localtime(&t);
+
+	if (compose->account && compose->account->address &&
+	    *compose->account->address) {
+		if (strchr(compose->account->address, '@'))
+			addr = g_strdup(compose->account->address);
+		else
+			addr = g_strconcat(compose->account->address, "@",
+					   get_domain_name(), NULL);
+	} else
+		addr = g_strconcat(g_get_user_name(), "@", get_domain_name(),
+				   NULL);
+
+	g_snprintf(buf, len, "%04d%02d%02d%02d%02d%02d.%08x.%s",
+		   lt->tm_year + 1900, lt->tm_mon + 1,
+		   lt->tm_mday, lt->tm_hour,
+		   lt->tm_min, lt->tm_sec,
+		   (guint)random(), addr);
+
+	debug_print(_("generated Message-ID: %s\n"), buf);
+
+	g_free(addr);
+}
+
+static void compose_add_entry_field(GtkWidget *table, GtkWidget **hbox,
+				    GtkWidget **entry, gint *count,
+				    const gchar *label_str,
+				    gboolean is_addr_entry)
+{
+	GtkWidget *label;
+
+	if (GTK_TABLE(table)->nrows < (*count) + 1)
+		gtk_table_resize(GTK_TABLE(table), (*count) + 1, 2);
+
+	*hbox = gtk_hbox_new(FALSE, 0);
+	label = gtk_label_new
+		(prefs_common.trans_hdr ? gettext(label_str) : label_str);
+	gtk_box_pack_end(GTK_BOX(*hbox), label, FALSE, FALSE, 0);
+	gtk_table_attach(GTK_TABLE(table), *hbox, 0, 1, *count, (*count) + 1,
+			 GTK_FILL, 0, 2, 0);
+	*entry = gtk_entry_new();
+	gtk_table_attach_defaults
+		(GTK_TABLE(table), *entry, 1, 2, *count, (*count) + 1);
+	if (GTK_TABLE(table)->nrows > (*count) + 1)
+		gtk_table_set_row_spacing(GTK_TABLE(table), *count, 4);
+
+	if (is_addr_entry)
+		address_completion_register_entry(GTK_ENTRY(*entry));
+
+	(*count)++;
+}
+
+static Compose *compose_create(PrefsAccount *account, ComposeMode mode)
+{
+	Compose   *compose;
+	GtkWidget *window;
+	GtkWidget *vbox;
+	GtkWidget *menubar;
+	GtkWidget *handlebox;
+
+	GtkWidget *vbox2;
+
+	GtkWidget *table_vbox;
+	GtkWidget *label;
+	GtkWidget *from_optmenu_hbox;
+	GtkWidget *to_entry;
+	GtkWidget *to_hbox;
+	GtkWidget *newsgroups_entry;
+	GtkWidget *newsgroups_hbox;
+	GtkWidget *subject_entry;
+	GtkWidget *cc_entry;
+	GtkWidget *cc_hbox;
+	GtkWidget *bcc_entry;
+	GtkWidget *bcc_hbox;
+	GtkWidget *reply_entry;
+	GtkWidget *reply_hbox;
+	GtkWidget *followup_entry;
+	GtkWidget *followup_hbox;
+
+	GtkWidget *paned;
+
+	GtkWidget *attach_scrwin;
+	GtkWidget *attach_clist;
+
+	GtkWidget *edit_vbox;
+	GtkWidget *ruler_hbox;
+	GtkWidget *ruler;
+	GtkWidget *scrolledwin;
+	GtkWidget *text;
+
+	GtkWidget *table;
+	GtkWidget *hbox;
+
+	gchar *titles[] = {_("MIME type"), _("Size"), _("Name")};
+	guint n_menu_entries;
+	GtkStyle  *style, *new_style;
+	GdkColormap *cmap;
+	GdkColor color[1];
+	gboolean success[1];
+	GdkFont   *font;
+	GtkWidget *popupmenu;
+	GtkWidget *menuitem;
+	GtkItemFactory *popupfactory;
+	GtkItemFactory *ifactory;
+	gint n_entries;
+	gint count = 0;
+	gint i;
+
+	g_return_val_if_fail(account != NULL, NULL);
+
+	debug_print(_("Creating compose window...\n"));
+	compose = g_new0(Compose, 1);
+
+	compose->account = account;
+	compose->orig_account = account;
+
+	window = gtk_window_new(GTK_WINDOW_TOPLEVEL);
+	gtk_window_set_policy(GTK_WINDOW(window), TRUE, TRUE, FALSE);
+	gtk_widget_set_usize(window, -1, prefs_common.compose_height);
+	gtk_signal_connect(GTK_OBJECT(window), "delete_event",
+			   GTK_SIGNAL_FUNC(compose_delete_cb), compose);
+	gtk_signal_connect(GTK_OBJECT(window), "destroy",
+			   GTK_SIGNAL_FUNC(compose_destroy_cb), compose);
+	gtk_signal_connect(GTK_OBJECT(window), "focus_in_event",
+			   GTK_SIGNAL_FUNC(manage_window_focus_in), NULL);
+	gtk_signal_connect(GTK_OBJECT(window), "focus_out_event",
+			   GTK_SIGNAL_FUNC(manage_window_focus_out), NULL);
+	gtk_widget_realize(window);
+
+	vbox = gtk_vbox_new(FALSE, 0);
+	gtk_container_add(GTK_CONTAINER(window), vbox);
+
+	n_menu_entries = sizeof(compose_entries) / sizeof(compose_entries[0]);
+	menubar = menubar_create(window, compose_entries,
+				 n_menu_entries, "<Compose>", compose);
+	gtk_box_pack_start(GTK_BOX(vbox), menubar, FALSE, TRUE, 0);
+
+	handlebox = gtk_handle_box_new();
+	gtk_box_pack_start(GTK_BOX(vbox), handlebox, FALSE, FALSE, 0);
+
+	compose_toolbar_create(compose, handlebox);
+
+	vbox2 = gtk_vbox_new(FALSE, 2);
+	gtk_box_pack_start(GTK_BOX(vbox), vbox2, TRUE, TRUE, 0);
+	gtk_container_set_border_width(GTK_CONTAINER(vbox2), BORDER_WIDTH);
+
+	table_vbox = gtk_vbox_new(FALSE, 0);
+	gtk_box_pack_start(GTK_BOX(vbox2), table_vbox, FALSE, TRUE, 0);
+	gtk_container_set_border_width(GTK_CONTAINER(table_vbox),
+				       BORDER_WIDTH * 2);
+
+	table = gtk_table_new(8, 2, FALSE);
+	gtk_box_pack_start(GTK_BOX(table_vbox), table, FALSE, TRUE, 0);
+
+	/* option menu for selecting accounts */
+	hbox = gtk_hbox_new(FALSE, 0);
+	label = gtk_label_new(prefs_common.trans_hdr ? _("From:") : "From:");
+	gtk_box_pack_end(GTK_BOX(hbox), label, FALSE, FALSE, 0);
+	gtk_table_attach(GTK_TABLE(table), hbox, 0, 1, count, count + 1,
+			 GTK_FILL, 0, 2, 0);
+	from_optmenu_hbox = compose_account_option_menu_create(compose);
+	gtk_table_attach_defaults(GTK_TABLE(table), from_optmenu_hbox,
+				  1, 2, count, count + 1);
+	gtk_table_set_row_spacing(GTK_TABLE(table), 0, 4);
+	count++;
+
+	/* header labels and entries */
+	compose_add_entry_field(table, &to_hbox, &to_entry, &count,
+				"To:", TRUE); 
+	compose_add_entry_field(table, &newsgroups_hbox, &newsgroups_entry,
+				&count, "Newsgroups:", FALSE);
+	compose_add_entry_field(table, &hbox, &subject_entry, &count,
+				"Subject:", FALSE);
+	compose_add_entry_field(table, &cc_hbox, &cc_entry, &count,
+				"Cc:", TRUE);
+	compose_add_entry_field(table, &bcc_hbox, &bcc_entry, &count,
+				"Bcc:", TRUE);
+	compose_add_entry_field(table, &reply_hbox, &reply_entry, &count,
+				"Reply-To:", TRUE);
+	compose_add_entry_field(table, &followup_hbox, &followup_entry, &count,
+				"Followup-To:", FALSE);
+
+	gtk_table_set_col_spacings(GTK_TABLE(table), 4);
+
+	gtk_signal_connect(GTK_OBJECT(to_entry), "activate",
+			   GTK_SIGNAL_FUNC(to_activated), compose);
+	gtk_signal_connect(GTK_OBJECT(newsgroups_entry), "activate",
+			   GTK_SIGNAL_FUNC(newsgroups_activated), compose);
+	gtk_signal_connect(GTK_OBJECT(subject_entry), "activate",
+			   GTK_SIGNAL_FUNC(subject_activated), compose);
+	gtk_signal_connect(GTK_OBJECT(cc_entry), "activate",
+			   GTK_SIGNAL_FUNC(cc_activated), compose);
+	gtk_signal_connect(GTK_OBJECT(bcc_entry), "activate",
+			   GTK_SIGNAL_FUNC(bcc_activated), compose);
+	gtk_signal_connect(GTK_OBJECT(reply_entry), "activate",
+			   GTK_SIGNAL_FUNC(replyto_activated), compose);
+	gtk_signal_connect(GTK_OBJECT(followup_entry), "activate",
+			   GTK_SIGNAL_FUNC(followupto_activated), compose);
+
+	gtk_signal_connect(GTK_OBJECT(subject_entry), "grab_focus",
+			   GTK_SIGNAL_FUNC(compose_grab_focus_cb), compose);
+	gtk_signal_connect(GTK_OBJECT(to_entry), "grab_focus",
+			   GTK_SIGNAL_FUNC(compose_grab_focus_cb), compose);
+	gtk_signal_connect(GTK_OBJECT(newsgroups_entry), "grab_focus",
+			   GTK_SIGNAL_FUNC(compose_grab_focus_cb), compose);
+	gtk_signal_connect(GTK_OBJECT(cc_entry), "grab_focus",
+			   GTK_SIGNAL_FUNC(compose_grab_focus_cb), compose);
+	gtk_signal_connect(GTK_OBJECT(bcc_entry), "grab_focus",
+			   GTK_SIGNAL_FUNC(compose_grab_focus_cb), compose);
+	gtk_signal_connect(GTK_OBJECT(reply_entry), "grab_focus",
+			   GTK_SIGNAL_FUNC(compose_grab_focus_cb), compose);
+	gtk_signal_connect(GTK_OBJECT(followup_entry), "grab_focus",
+			   GTK_SIGNAL_FUNC(compose_grab_focus_cb), compose);
+
+	/* attachment list */
+	attach_scrwin = gtk_scrolled_window_new(NULL, NULL);
+	gtk_scrolled_window_set_policy(GTK_SCROLLED_WINDOW(attach_scrwin),
+				       GTK_POLICY_AUTOMATIC,
+				       GTK_POLICY_ALWAYS);
+	gtk_widget_set_usize(attach_scrwin, -1, 80);
+
+	attach_clist = gtk_clist_new_with_titles(N_ATTACH_COLS, titles);
+	gtk_clist_set_column_justification(GTK_CLIST(attach_clist), COL_SIZE,
+					   GTK_JUSTIFY_RIGHT);
+	gtk_clist_set_column_width(GTK_CLIST(attach_clist), COL_MIMETYPE, 240);
+	gtk_clist_set_column_width(GTK_CLIST(attach_clist), COL_SIZE, 64);
+	gtk_clist_set_selection_mode(GTK_CLIST(attach_clist),
+				     GTK_SELECTION_EXTENDED);
+	for (i = 0; i < N_ATTACH_COLS; i++)
+		GTK_WIDGET_UNSET_FLAGS
+			(GTK_CLIST(attach_clist)->column[i].button,
+			 GTK_CAN_FOCUS);
+	gtk_container_add(GTK_CONTAINER(attach_scrwin), attach_clist);
+
+	gtk_signal_connect(GTK_OBJECT(attach_clist), "select_row",
+			   GTK_SIGNAL_FUNC(attach_selected), compose);
+	gtk_signal_connect(GTK_OBJECT(attach_clist), "button_press_event",
+			   GTK_SIGNAL_FUNC(attach_button_pressed), compose);
+	gtk_signal_connect(GTK_OBJECT(attach_clist), "key_press_event",
+			   GTK_SIGNAL_FUNC(attach_key_pressed), compose);
+
+	/* drag and drop */
+	gtk_drag_dest_set(attach_clist,
+			  GTK_DEST_DEFAULT_ALL, compose_mime_types, 1,
+			  GDK_ACTION_COPY);
+	gtk_signal_connect(GTK_OBJECT(attach_clist), "drag_data_received",
+			   GTK_SIGNAL_FUNC(compose_attach_drag_received_cb),
+			   compose);
+
+	/* pane between attach clist and text */
+	paned = gtk_vpaned_new();
+	gtk_paned_add1(GTK_PANED(paned), attach_scrwin);
+	gtk_widget_ref(paned);
+	gtk_widget_show_all(paned);
+
+	edit_vbox = gtk_vbox_new(FALSE, 0);
+	gtk_box_pack_start(GTK_BOX(vbox2), edit_vbox, TRUE, TRUE, 0);
+
+	/* ruler */
+	ruler_hbox = gtk_hbox_new(FALSE, 0);
+	gtk_box_pack_start(GTK_BOX(edit_vbox), ruler_hbox, FALSE, FALSE, 0);
+
+	ruler = gtk_shruler_new();
+	gtk_ruler_set_range(GTK_RULER(ruler), 0.0, 100.0, 1.0, 100.0);
+	gtk_box_pack_start(GTK_BOX(ruler_hbox), ruler, TRUE, TRUE,
+			   BORDER_WIDTH + 1);
+	gtk_widget_set_usize(ruler_hbox, 1, -1);
+
+	/* text widget */
+	scrolledwin = gtk_scrolled_window_new(NULL, NULL);
+	gtk_scrolled_window_set_policy(GTK_SCROLLED_WINDOW(scrolledwin),
+				       GTK_POLICY_NEVER, GTK_POLICY_ALWAYS);
+	gtk_box_pack_start(GTK_BOX(edit_vbox), scrolledwin, TRUE, TRUE, 0);
+	gtk_widget_set_usize(scrolledwin, prefs_common.compose_width, -1);
+
+	text = gtk_text_new(gtk_scrolled_window_get_hadjustment
+			    (GTK_SCROLLED_WINDOW(scrolledwin)),
+			    gtk_scrolled_window_get_vadjustment
+			    (GTK_SCROLLED_WINDOW(scrolledwin)));
+	GTK_TEXT(text)->default_tab_width = 8;
+	gtk_text_set_editable(GTK_TEXT(text), TRUE);
+	gtk_text_set_word_wrap(GTK_TEXT(text), TRUE);
+	gtk_container_add(GTK_CONTAINER(scrolledwin), text);
+
+	gtk_signal_connect(GTK_OBJECT(text), "changed",
+			   GTK_SIGNAL_FUNC(compose_changed_cb), compose);
+	gtk_signal_connect(GTK_OBJECT(text), "grab_focus",
+			   GTK_SIGNAL_FUNC(compose_grab_focus_cb), compose);
+	gtk_signal_connect_after(GTK_OBJECT(text), "button_press_event",
+				 GTK_SIGNAL_FUNC(compose_button_press_cb),
+				 compose);
+#if 0
+	gtk_signal_connect_after(GTK_OBJECT(text), "key_press_event",
+				 GTK_SIGNAL_FUNC(compose_key_press_cb),
+				 compose);
+#endif
+	gtk_signal_connect_after(GTK_OBJECT(text), "size_allocate",
+				 GTK_SIGNAL_FUNC(compose_edit_size_alloc),
+				 ruler);
+
+	/* drag and drop */
+	gtk_drag_dest_set(text, GTK_DEST_DEFAULT_ALL, compose_mime_types, 1,
+			  GDK_ACTION_COPY);
+	gtk_signal_connect(GTK_OBJECT(text), "drag_data_received",
+			   GTK_SIGNAL_FUNC(compose_insert_drag_received_cb),
+			   compose);
+
+	gtk_widget_show_all(vbox);
+
+	style = gtk_widget_get_style(text);
+
+	/* workaround for the slow down of GtkText when using Pixmap theme */
+	if (style->engine) {
+		GtkThemeEngine *engine;
+
+		engine = style->engine;
+		style->engine = NULL;
+		new_style = gtk_style_copy(style);
+		style->engine = engine;
+	} else
+		new_style = gtk_style_copy(style);
+
+	if (prefs_common.textfont) {
+		CharSet charset;
+
+		charset = conv_get_current_charset();
+		if (MB_CUR_MAX == 1) {
+			gchar *fontstr, *p;
+
+			Xstrdup_a(fontstr, prefs_common.textfont, );
+			if (fontstr && (p = strchr(fontstr, ',')) != NULL)
+				*p = '\0';
+			font = gdk_font_load(fontstr);
+		} else
+			font = gdk_fontset_load(prefs_common.textfont);
+		if (font) {
+			gdk_font_unref(new_style->font);
+			new_style->font = font;
+		}
+	}
+
+	gtk_widget_set_style(text, new_style);
+
+	color[0] = quote_color;
+	cmap = gdk_window_get_colormap(window->window);
+	gdk_colormap_alloc_colors(cmap, color, 1, FALSE, TRUE, success);
+	if (success[0] == FALSE) {
+		g_warning("Compose: color allocation failed.\n");
+		style = gtk_widget_get_style(text);
+		quote_color = style->black;
+	}
+
+	n_entries = sizeof(compose_popup_entries) /
+		sizeof(compose_popup_entries[0]);
+	popupmenu = menu_create_items(compose_popup_entries, n_entries,
+				      "<Compose>", &popupfactory,
+				      compose);
+
+	ifactory = gtk_item_factory_from_widget(menubar);
+	menu_set_sensitive(ifactory, "/Edit/Undo", FALSE);
+	menu_set_sensitive(ifactory, "/Edit/Redo", FALSE);
+
+	gtk_widget_hide(bcc_hbox);
+	gtk_widget_hide(bcc_entry);
+	gtk_widget_hide(reply_hbox);
+	gtk_widget_hide(reply_entry);
+	gtk_widget_hide(followup_hbox);
+	gtk_widget_hide(followup_entry);
+	gtk_widget_hide(ruler_hbox);
+	gtk_table_set_row_spacing(GTK_TABLE(table), 4, 0);
+	gtk_table_set_row_spacing(GTK_TABLE(table), 5, 0);
+	gtk_table_set_row_spacing(GTK_TABLE(table), 6, 0);
+
+	if (account->protocol == A_NNTP) {
+		gtk_widget_hide(to_hbox);
+		gtk_widget_hide(to_entry);
+		gtk_widget_hide(cc_hbox);
+		gtk_widget_hide(cc_entry);
+		gtk_table_set_row_spacing(GTK_TABLE(table), 1, 0);
+		gtk_table_set_row_spacing(GTK_TABLE(table), 3, 0);
+	} else {
+		gtk_widget_hide(newsgroups_hbox);
+		gtk_widget_hide(newsgroups_entry);
+		gtk_table_set_row_spacing(GTK_TABLE(table), 2, 0);
+		menu_set_sensitive(ifactory, "/Message/Followup to", FALSE);
+	}
+
+	switch (prefs_common.toolbar_style) {
+	case TOOLBAR_NONE:
+		gtk_widget_hide(handlebox);
+		break;
+	case TOOLBAR_ICON:
+		gtk_toolbar_set_style(GTK_TOOLBAR(compose->toolbar),
+				      GTK_TOOLBAR_ICONS);
+		break;
+	case TOOLBAR_TEXT:
+		gtk_toolbar_set_style(GTK_TOOLBAR(compose->toolbar),
+				      GTK_TOOLBAR_TEXT);
+		break;
+	case TOOLBAR_BOTH:
+		gtk_toolbar_set_style(GTK_TOOLBAR(compose->toolbar),
+				      GTK_TOOLBAR_BOTH);
+		break;
+	}
+
+	gtk_widget_show(window);
+
+	address_completion_start(window);
+
+	compose->window        = window;
+	compose->vbox	       = vbox;
+	compose->menubar       = menubar;
+	compose->handlebox     = handlebox;
+
+	compose->vbox2	       = vbox2;
+
+	compose->table_vbox       = table_vbox;
+	compose->table	          = table;
+	compose->to_hbox          = to_hbox;
+	compose->to_entry         = to_entry;
+	compose->newsgroups_hbox  = newsgroups_hbox;
+	compose->newsgroups_entry = newsgroups_entry;
+	compose->subject_entry    = subject_entry;
+	compose->cc_hbox          = cc_hbox;
+	compose->cc_entry         = cc_entry;
+	compose->bcc_hbox         = bcc_hbox;
+	compose->bcc_entry        = bcc_entry;
+	compose->reply_hbox       = reply_hbox;
+	compose->reply_entry      = reply_entry;
+	compose->followup_hbox    = followup_hbox;
+	compose->followup_entry   = followup_entry;
+
+	compose->paned = paned;
+
+	compose->attach_scrwin = attach_scrwin;
+	compose->attach_clist  = attach_clist;
+
+	compose->edit_vbox     = edit_vbox;
+	compose->ruler_hbox    = ruler_hbox;
+	compose->ruler         = ruler;
+	compose->scrolledwin   = scrolledwin;
+	compose->text	       = text;
+
+	compose->focused_editable = NULL;
+
+	compose->popupmenu    = popupmenu;
+	compose->popupfactory = popupfactory;
+
+	compose->mode = mode;
+
+	compose->replyto     = NULL;
+	compose->cc	     = NULL;
+	compose->bcc	     = NULL;
+	compose->followup_to = NULL;
+	compose->inreplyto   = NULL;
+	compose->references  = NULL;
+	compose->msgid       = NULL;
+	compose->boundary    = NULL;
+
+	compose->use_to         = FALSE;
+	compose->use_cc         = FALSE;
+	compose->use_bcc        = FALSE;
+	compose->use_replyto    = FALSE;
+	compose->use_followupto = FALSE;
+	compose->use_attach     = FALSE;
+
+#if USE_GPGME
+	compose->use_signing    = FALSE;
+	compose->use_encryption = FALSE;
+#endif /* USE_GPGME */
+
+	compose->modified = FALSE;
+
+	compose->to_list        = NULL;
+	compose->newsgroup_list = NULL;
+
+	compose->exteditor_file    = NULL;
+	compose->exteditor_pid     = -1;
+	compose->exteditor_readdes = -1;
+	compose->exteditor_tag     = -1;
+
+	compose_set_title(compose);
+
+	if (account->protocol != A_NNTP) {
+		menuitem = gtk_item_factory_get_item(ifactory, "/Message/To");
+		gtk_check_menu_item_set_active
+			(GTK_CHECK_MENU_ITEM(menuitem), TRUE);
+		gtk_widget_set_sensitive(menuitem, FALSE);
+		menuitem = gtk_item_factory_get_item(ifactory, "/Message/Cc");
+		gtk_check_menu_item_set_active
+			(GTK_CHECK_MENU_ITEM(menuitem), TRUE);
+		gtk_widget_set_sensitive(menuitem, FALSE);
+	}
+	if (account->set_autocc && account->auto_cc && mode != COMPOSE_REEDIT) {
+		gtk_entry_set_text(GTK_ENTRY(cc_entry), account->auto_cc);
+		menuitem = gtk_item_factory_get_item(ifactory, "/Message/Cc");
+		gtk_check_menu_item_set_active
+			(GTK_CHECK_MENU_ITEM(menuitem), TRUE);
+	}
+	if (account->set_autobcc) {
+		menuitem = gtk_item_factory_get_item(ifactory, "/Message/Bcc");
+		gtk_check_menu_item_set_active
+			(GTK_CHECK_MENU_ITEM(menuitem), TRUE);
+		if (account->auto_bcc && mode != COMPOSE_REEDIT)
+			gtk_entry_set_text(GTK_ENTRY(bcc_entry),
+					   account->auto_bcc);
+	}
+	if (account->set_autoreplyto) {
+		menuitem = gtk_item_factory_get_item(ifactory,
+						     "/Message/Reply to");
+		gtk_check_menu_item_set_active
+			(GTK_CHECK_MENU_ITEM(menuitem), TRUE);
+		if (account->auto_replyto && mode != COMPOSE_REEDIT)
+			gtk_entry_set_text(GTK_ENTRY(reply_entry),
+					   account->auto_replyto);
+	}
+
+	menuitem = gtk_item_factory_get_item(ifactory, "/Tool/Show ruler");
+	gtk_check_menu_item_set_active(GTK_CHECK_MENU_ITEM(menuitem),
+				       prefs_common.show_ruler);
+
+#if USE_GPGME
+	menuitem = gtk_item_factory_get_item(ifactory, "/Message/Sign");
+	gtk_check_menu_item_set_active(GTK_CHECK_MENU_ITEM(menuitem),
+				       prefs_common.default_sign);
+	menuitem = gtk_item_factory_get_item(ifactory, "/Message/Encrypt");
+	gtk_check_menu_item_set_active(GTK_CHECK_MENU_ITEM(menuitem),
+				       prefs_common.default_encrypt);
+#endif /* USE_GPGME */
+
+	addressbook_set_target_compose(compose);
+
+	compose_list = g_list_append(compose_list, compose);
+
+	return compose;
+}
+
+#include "pixmaps/stock_mail_send.xpm"
+#include "pixmaps/stock_mail_send_queue.xpm"
+#include "pixmaps/stock_mail.xpm"
+#include "pixmaps/stock_paste.xpm"
+#include "pixmaps/stock_mail_attach.xpm"
+#include "pixmaps/stock_mail_compose.xpm"
+#include "pixmaps/linewrap.xpm"
+#include "pixmaps/tb_address_book.xpm"
+
+#define CREATE_TOOLBAR_ICON(xpm_d) \
+{ \
+	icon = gdk_pixmap_create_from_xpm_d(container->window, &mask, \
+					    &container->style->white, \
+					    xpm_d); \
+	icon_wid = gtk_pixmap_new(icon, mask); \
+}
+
+static void compose_toolbar_create(Compose *compose, GtkWidget *container)
+{
+	GtkWidget *toolbar;
+	GdkPixmap *icon;
+	GdkBitmap *mask;
+	GtkWidget *icon_wid;
+	GtkWidget *send_btn;
+	GtkWidget *sendl_btn;
+	GtkWidget *draft_btn;
+	GtkWidget *insert_btn;
+	GtkWidget *attach_btn;
+	GtkWidget *sig_btn;
+	GtkWidget *exteditor_btn;
+	GtkWidget *linewrap_btn;
+	GtkWidget *addrbook_btn;
+
+	toolbar = gtk_toolbar_new(GTK_ORIENTATION_HORIZONTAL,
+				  GTK_TOOLBAR_BOTH);
+	gtk_container_add(GTK_CONTAINER(container), toolbar);
+	gtk_container_set_border_width(GTK_CONTAINER(container), 2);
+	gtk_toolbar_set_button_relief(GTK_TOOLBAR(toolbar), GTK_RELIEF_NONE);
+	gtk_toolbar_set_space_style(GTK_TOOLBAR(toolbar),
+				    GTK_TOOLBAR_SPACE_LINE);
+
+	CREATE_TOOLBAR_ICON(stock_mail_send_xpm);
+	send_btn = gtk_toolbar_append_item(GTK_TOOLBAR(toolbar),
+					   _("Send"),
+					   _("Send message"),
+					   "Send",
+					   icon_wid, toolbar_send_cb, compose);
+
+	CREATE_TOOLBAR_ICON(stock_mail_send_queue_xpm);
+	sendl_btn = gtk_toolbar_append_item(GTK_TOOLBAR(toolbar),
+					   _("Send later"),
+					   _("Put into queue folder and send later"),
+					   "Send later",
+					   icon_wid, toolbar_send_later_cb,
+					   compose);
+
+	CREATE_TOOLBAR_ICON(stock_mail_xpm);
+	draft_btn = gtk_toolbar_append_item(GTK_TOOLBAR(toolbar),
+					    _("Draft"),
+					    _("Save to draft folder"),
+					    "Draft",
+					    icon_wid, toolbar_draft_cb,
+					    compose);
+
+	gtk_toolbar_append_space(GTK_TOOLBAR(toolbar));
+
+	CREATE_TOOLBAR_ICON(stock_paste_xpm);
+	insert_btn = gtk_toolbar_append_item(GTK_TOOLBAR(toolbar),
+					     _("Insert"),
+					     _("Insert file"),
+					     "Insert",
+					     icon_wid, toolbar_insert_cb,
+					     compose);
+
+	CREATE_TOOLBAR_ICON(stock_mail_attach_xpm);
+	attach_btn = gtk_toolbar_append_item(GTK_TOOLBAR(toolbar),
+					     _("Attach"),
+					     _("Attach file"),
+					     "Attach",
+					     icon_wid, toolbar_attach_cb,
+					     compose);
+
+	gtk_toolbar_append_space(GTK_TOOLBAR(toolbar));
+
+	CREATE_TOOLBAR_ICON(stock_mail_xpm);
+	sig_btn = gtk_toolbar_append_item(GTK_TOOLBAR(toolbar),
+					  _("Signature"),
+					  _("Insert signature"),
+					  "Signature",
+					  icon_wid, toolbar_sig_cb, compose);
+
+	gtk_toolbar_append_space(GTK_TOOLBAR(toolbar));
+
+	CREATE_TOOLBAR_ICON(stock_mail_compose_xpm);
+	exteditor_btn = gtk_toolbar_append_item(GTK_TOOLBAR(toolbar),
+						_("Editor"),
+						_("Edit with external editor"),
+						"Editor",
+						icon_wid,
+						toolbar_ext_editor_cb,
+						compose);
+
+	CREATE_TOOLBAR_ICON(linewrap_xpm);
+	linewrap_btn = gtk_toolbar_append_item(GTK_TOOLBAR(toolbar),
+					       _("Linewrap"),
+					       _("Wrap current paragraph"),
+					       "Linewrap",
+					       icon_wid,
+					       toolbar_linewrap_cb,
+					       compose);
+
+	gtk_toolbar_append_space(GTK_TOOLBAR(toolbar));
+
+	CREATE_TOOLBAR_ICON(tb_address_book_xpm);
+	addrbook_btn = gtk_toolbar_append_item(GTK_TOOLBAR(toolbar),
+					       _("Address"),
+					       _("Address book"),
+					       "Address",
+					       icon_wid, toolbar_address_cb,
+					       compose);
+
+	compose->toolbar       = toolbar;
+	compose->send_btn      = send_btn;
+	compose->sendl_btn     = sendl_btn;
+	compose->draft_btn     = draft_btn;
+	compose->insert_btn    = insert_btn;
+	compose->attach_btn    = attach_btn;
+	compose->sig_btn       = sig_btn;
+	compose->exteditor_btn = exteditor_btn;
+	compose->linewrap_btn  = linewrap_btn;
+	compose->addrbook_btn  = addrbook_btn;
+
+	gtk_widget_show_all(toolbar);
+}
+
+#undef CREATE_TOOLBAR_ICON
+
+static GtkWidget *compose_account_option_menu_create(Compose *compose)
+{
+	GList *accounts;
+	GtkWidget *hbox;
+	GtkWidget *optmenu;
+	GtkWidget *menu;
+	gint num = 0, def_menu = 0;
+
+	accounts = account_get_list();
+	g_return_val_if_fail(accounts != NULL, NULL);
+
+	hbox = gtk_hbox_new(FALSE, 0);
+	optmenu = gtk_option_menu_new();
+	gtk_box_pack_start(GTK_BOX(hbox), optmenu, FALSE, FALSE, 0);
+	menu = gtk_menu_new();
+
+	for (; accounts != NULL; accounts = accounts->next, num++) {
+		PrefsAccount *ac = (PrefsAccount *)accounts->data;
+		GtkWidget *menuitem;
+		gchar *name;
+
+		if (ac == compose->account) def_menu = num;
+
+		name = g_strdup_printf("%s: %s <%s>",
+				       ac->account_name, ac->name, ac->address);
+		MENUITEM_ADD(menu, menuitem, name, ac);
+		g_free(name);
+		gtk_signal_connect(GTK_OBJECT(menuitem), "activate",
+				   GTK_SIGNAL_FUNC(account_activated),
+				   compose);
+	}
+
+	gtk_option_menu_set_menu(GTK_OPTION_MENU(optmenu), menu);
+	gtk_option_menu_set_history(GTK_OPTION_MENU(optmenu), def_menu);
+
+	return hbox;
+}
+
+static void compose_destroy(Compose *compose)
+{
+	gint row;
+	GtkCList *clist = GTK_CLIST(compose->attach_clist);
+	AttachInfo *ainfo;
+
+	/* NOTE: address_completion_end() does nothing with the window
+	 * however this may change. */
+	address_completion_end(compose->window);
+
+	slist_free_strings(compose->to_list);
+	g_slist_free(compose->to_list);
+	slist_free_strings(compose->newsgroup_list);
+	g_slist_free(compose->newsgroup_list);
+
+	procmsg_msginfo_free(compose->targetinfo);
+
+	g_free(compose->replyto);
+	g_free(compose->cc);
+	g_free(compose->bcc);
+	g_free(compose->newsgroups);
+	g_free(compose->followup_to);
+
+	g_free(compose->inreplyto);
+	g_free(compose->references);
+	g_free(compose->msgid);
+	g_free(compose->boundary);
+
+	g_free(compose->exteditor_file);
+
+	for (row = 0; (ainfo = gtk_clist_get_row_data(clist, row)) != NULL;
+	     row++)
+		compose_attach_info_free(ainfo);
+
+	if (addressbook_get_target_compose() == compose)
+		addressbook_set_target_compose(NULL);
+
+	prefs_common.compose_width = compose->scrolledwin->allocation.width;
+	prefs_common.compose_height = compose->window->allocation.height;
+
+	gtk_widget_destroy(compose->paned);
+
+	g_free(compose);
+
+	compose_list = g_list_remove(compose_list, compose);
+}
+
+static void compose_attach_info_free(AttachInfo *ainfo)
+{
+	g_free(ainfo->file);
+	g_free(ainfo->content_type);
+	g_free(ainfo->name);
+	g_free(ainfo);
+}
+
+static void compose_attach_remove_selected(Compose *compose)
+{
+	GtkCList *clist = GTK_CLIST(compose->attach_clist);
+	AttachInfo *ainfo;
+	gint row;
+
+	while (clist->selection != NULL) {
+		row = GPOINTER_TO_INT(clist->selection->data);
+		ainfo = gtk_clist_get_row_data(clist, row);
+		compose_attach_info_free(ainfo);
+		gtk_clist_remove(clist, row);
+	}
+}
+
+static struct _AttachProperty
+{
+	GtkWidget *window;
+	GtkWidget *mimetype_entry;
+	GtkWidget *encoding_optmenu;
+	GtkWidget *path_entry;
+	GtkWidget *filename_entry;
+	GtkWidget *ok_btn;
+	GtkWidget *cancel_btn;
+} attach_prop;
+
+static void compose_attach_property(Compose *compose)
+{
+	GtkCList *clist = GTK_CLIST(compose->attach_clist);
+	AttachInfo *ainfo;
+	gint row;
+	GtkOptionMenu *optmenu;
+	static gboolean cancelled;
+
+	if (!clist->selection) return;
+	row = GPOINTER_TO_INT(clist->selection->data);
+
+	ainfo = gtk_clist_get_row_data(clist, row);
+	if (!ainfo) return;
+
+	if (!attach_prop.window)
+		compose_attach_property_create(&cancelled);
+	gtk_widget_grab_focus(attach_prop.ok_btn);
+	gtk_widget_show(attach_prop.window);
+	manage_window_set_transient(GTK_WINDOW(attach_prop.window));
+
+	optmenu = GTK_OPTION_MENU(attach_prop.encoding_optmenu);
+	if (ainfo->encoding == ENC_UNKNOWN)
+		gtk_option_menu_set_history(optmenu, ENC_BASE64);
+	else
+		gtk_option_menu_set_history(optmenu, ainfo->encoding);
+
+	gtk_entry_set_text(GTK_ENTRY(attach_prop.mimetype_entry),
+			   ainfo->content_type ? ainfo->content_type : "");
+	gtk_entry_set_text(GTK_ENTRY(attach_prop.path_entry),
+			   ainfo->file ? ainfo->file : "");
+	gtk_entry_set_text(GTK_ENTRY(attach_prop.filename_entry),
+			   ainfo->name ? ainfo->name : "");
+
+	for (;;) {
+		gchar *text;
+		gchar *cnttype = NULL;
+		gchar *file = NULL;
+		off_t size = 0;
+		GtkWidget *menu;
+		GtkWidget *menuitem;
+
+		cancelled = FALSE;
+		gtk_main();
+
+		if (cancelled == TRUE) {
+			gtk_widget_hide(attach_prop.window);
+			break;
+		}
+
+		text = gtk_entry_get_text(GTK_ENTRY(attach_prop.mimetype_entry));
+		if (*text != '\0') {
+			gchar *p;
+
+			text = g_strstrip(g_strdup(text));
+			if ((p = strchr(text, '/')) && !strchr(p + 1, '/')) {
+				cnttype = g_strdup(text);
+				g_free(text);
+			} else {
+				alertpanel_error(_("Invalid MIME type."));
+				g_free(text);
+				continue;
+			}
+		}
+
+		menu = gtk_option_menu_get_menu(optmenu);
+		menuitem = gtk_menu_get_active(GTK_MENU(menu));
+		ainfo->encoding = GPOINTER_TO_INT
+			(gtk_object_get_user_data(GTK_OBJECT(menuitem)));
+
+		text = gtk_entry_get_text(GTK_ENTRY(attach_prop.path_entry));
+		if (*text != '\0') {
+			if (is_file_exist(text) &&
+			    (size = get_file_size(text)) > 0)
+				file = g_strdup(text);
+			else {
+				alertpanel_error
+					(_("File doesn't exist or is empty."));
+				g_free(cnttype);
+				continue;
+			}
+		}
+
+		text = gtk_entry_get_text(GTK_ENTRY(attach_prop.filename_entry));
+		if (*text != '\0') {
+			g_free(ainfo->name);
+			ainfo->name = g_strdup(text);
+		}
+
+		if (cnttype) {
+			g_free(ainfo->content_type);
+			ainfo->content_type = cnttype;
+		}
+		if (file) {
+			g_free(ainfo->file);
+			ainfo->file = file;
+		}
+		if (size)
+			ainfo->size = size;
+
+		gtk_clist_set_text(clist, row, COL_MIMETYPE,
+				   ainfo->content_type);
+		gtk_clist_set_text(clist, row, COL_SIZE,
+				   to_human_readable(ainfo->size));
+		gtk_clist_set_text(clist, row, COL_NAME, ainfo->name);
+
+		gtk_widget_hide(attach_prop.window);
+		break;
+	}
+}
+
+#define SET_LABEL_AND_ENTRY(str, entry, top) \
+{ \
+	label = gtk_label_new(str); \
+	gtk_table_attach(GTK_TABLE(table), label, 0, 1, top, (top + 1), \
+			 GTK_FILL, 0, 0, 0); \
+	gtk_misc_set_alignment(GTK_MISC(label), 0, 0.5); \
+ \
+	entry = gtk_entry_new(); \
+	gtk_table_attach(GTK_TABLE(table), entry, 1, 2, top, (top + 1), \
+			 GTK_EXPAND|GTK_SHRINK|GTK_FILL, 0, 0, 0); \
+}
+
+static void compose_attach_property_create(gboolean *cancelled)
+{
+	GtkWidget *window;
+	GtkWidget *vbox;
+	GtkWidget *table;
+	GtkWidget *label;
+	GtkWidget *mimetype_entry;
+	GtkWidget *hbox;
+	GtkWidget *optmenu;
+	GtkWidget *optmenu_menu;
+	GtkWidget *menuitem;
+	GtkWidget *path_entry;
+	GtkWidget *filename_entry;
+	GtkWidget *hbbox;
+	GtkWidget *ok_btn;
+	GtkWidget *cancel_btn;
+
+	debug_print("Creating attach_property window...\n");
+
+	window = gtk_window_new(GTK_WINDOW_DIALOG);
+	gtk_widget_set_usize(window, 480, -1);
+	gtk_container_set_border_width(GTK_CONTAINER(window), 8);
+	gtk_window_set_title(GTK_WINDOW(window), _("Property"));
+	gtk_window_set_position(GTK_WINDOW(window), GTK_WIN_POS_CENTER);
+	gtk_window_set_modal(GTK_WINDOW(window), TRUE);
+	gtk_signal_connect(GTK_OBJECT(window), "delete_event",
+			   GTK_SIGNAL_FUNC(attach_property_delete_event),
+			   cancelled);
+	gtk_signal_connect(GTK_OBJECT(window), "key_press_event",
+			   GTK_SIGNAL_FUNC(attach_property_key_pressed),
+			   cancelled);
+
+	vbox = gtk_vbox_new(FALSE, 8);
+	gtk_container_add(GTK_CONTAINER(window), vbox);
+
+	table = gtk_table_new(4, 2, FALSE);
+	gtk_box_pack_start(GTK_BOX(vbox), table, FALSE, FALSE, 0);
+	gtk_table_set_row_spacings(GTK_TABLE(table), 8);
+	gtk_table_set_col_spacings(GTK_TABLE(table), 8);
+
+	SET_LABEL_AND_ENTRY(_("MIME type"), mimetype_entry, 0);
+
+	label = gtk_label_new(_("Encoding"));
+	gtk_table_attach(GTK_TABLE(table), label, 0, 1, 1, 2,
+			 GTK_FILL, 0, 0, 0);
+	gtk_misc_set_alignment(GTK_MISC(label), 0, 0.5);
+
+	hbox = gtk_hbox_new(FALSE, 0);
+	gtk_table_attach(GTK_TABLE(table), hbox, 1, 2, 1, 2,
+			 GTK_EXPAND|GTK_SHRINK|GTK_FILL, 0, 0, 0);
+
+	optmenu = gtk_option_menu_new();
+	gtk_box_pack_start(GTK_BOX(hbox), optmenu, FALSE, FALSE, 0);
+
+	optmenu_menu = gtk_menu_new();
+	MENUITEM_ADD(optmenu_menu, menuitem, "7bit", ENC_7BIT);
+	gtk_widget_set_sensitive(menuitem, FALSE);
+	MENUITEM_ADD(optmenu_menu, menuitem, "8bit", ENC_8BIT);
+	gtk_widget_set_sensitive(menuitem, FALSE);
+	MENUITEM_ADD(optmenu_menu, menuitem, "quoted-printable", ENC_QUOTED_PRINTABLE);
+	gtk_widget_set_sensitive(menuitem, FALSE);
+	MENUITEM_ADD(optmenu_menu, menuitem, "base64", ENC_BASE64);
+
+	gtk_option_menu_set_menu(GTK_OPTION_MENU(optmenu), optmenu_menu);
+
+	SET_LABEL_AND_ENTRY(_("Path"),      path_entry,     2);
+	SET_LABEL_AND_ENTRY(_("File name"), filename_entry, 3);
+
+	gtkut_button_set_create(&hbbox, &ok_btn, _("OK"),
+				&cancel_btn, _("Cancel"), NULL, NULL);
+	gtk_box_pack_end(GTK_BOX(vbox), hbbox, FALSE, FALSE, 0);
+	gtk_widget_grab_default(ok_btn);
+
+	gtk_signal_connect(GTK_OBJECT(ok_btn), "clicked",
+			   GTK_SIGNAL_FUNC(attach_property_ok),
+			   cancelled);
+	gtk_signal_connect(GTK_OBJECT(cancel_btn), "clicked",
+			   GTK_SIGNAL_FUNC(attach_property_cancel),
+			   cancelled);
+
+	gtk_widget_show_all(vbox);
+
+	attach_prop.window           = window;
+	attach_prop.mimetype_entry   = mimetype_entry;
+	attach_prop.encoding_optmenu = optmenu;
+	attach_prop.path_entry       = path_entry;
+	attach_prop.filename_entry   = filename_entry;
+	attach_prop.ok_btn           = ok_btn;
+	attach_prop.cancel_btn       = cancel_btn;
+}
+
+#undef SET_LABEL_AND_ENTRY
+
+static void attach_property_ok(GtkWidget *widget, gboolean *cancelled)
+{
+	*cancelled = FALSE;
+	gtk_main_quit();
+}
+
+static void attach_property_cancel(GtkWidget *widget, gboolean *cancelled)
+{
+	*cancelled = TRUE;
+	gtk_main_quit();
+}
+
+static gint attach_property_delete_event(GtkWidget *widget, GdkEventAny *event,
+					 gboolean *cancelled)
+{
+	*cancelled = TRUE;
+	gtk_main_quit();
+
+	return TRUE;
+}
+
+static void attach_property_key_pressed(GtkWidget *widget, GdkEventKey *event,
+					gboolean *cancelled)
+{
+	if (event && event->keyval == GDK_Escape) {
+		*cancelled = TRUE;
+		gtk_main_quit();
+	}
+}
+
+static void compose_exec_ext_editor(Compose *compose)
+{
+	gchar tmp[64];
+	pid_t pid;
+	gint pipe_fds[2];
+
+	g_snprintf(tmp, sizeof(tmp), "%s%ctmpmsg.%08x",
+		   g_get_tmp_dir(), G_DIR_SEPARATOR, (gint)compose);
+
+	if (pipe(pipe_fds) < 0) {
+		perror("pipe");
+		return;
+	}
+
+	if ((pid = fork()) < 0) {
+		perror("fork");
+		return;
+	}
+
+	if (pid != 0) {
+		/* close the write side of the pipe */
+		close(pipe_fds[1]);
+
+		compose->exteditor_file    = g_strdup(tmp);
+		compose->exteditor_pid     = pid;
+		compose->exteditor_readdes = pipe_fds[0];
+
+		compose_set_ext_editor_sensitive(compose, FALSE);
+
+		compose->exteditor_tag =
+			gdk_input_add(pipe_fds[0], GDK_INPUT_READ,
+				      compose_input_cb, compose);
+	} else {	/* process-monitoring process */
+		pid_t pid_ed;
+
+		if (setpgid(0, 0))
+			perror("setpgid");
+
+		/* close the read side of the pipe */
+		close(pipe_fds[0]);
+
+		if (compose_write_body_to_file(compose, tmp) < 0) {
+			fd_write(pipe_fds[1], "2\n", 2);
+			_exit(1);
+		}
+
+		pid_ed = compose_exec_ext_editor_real(tmp);
+		if (pid_ed < 0) {
+			fd_write(pipe_fds[1], "1\n", 2);
+			_exit(1);
+		}
+
+		/* wait until editor is terminated */
+		waitpid(pid_ed, NULL, 0);
+
+		fd_write(pipe_fds[1], "0\n", 2);
+
+		close(pipe_fds[1]);
+		_exit(0);
+	}
+}
+
+static gint compose_exec_ext_editor_real(const gchar *file)
+{
+	static gchar *def_cmd = "emacs %s";
+	gchar buf[1024];
+	gchar *p;
+	gchar **cmdline;
+	pid_t pid;
+
+	g_return_val_if_fail(file != NULL, -1);
+
+	if ((pid = fork()) < 0) {
+		perror("fork");
+		return -1;
+	}
+
+	if (pid != 0) return pid;
+
+	/* grandchild process */
+
+	if (setpgid(0, getppid()))
+		perror("setpgid");
+
+	if (prefs_common.ext_editor_cmd &&
+	    (p = strchr(prefs_common.ext_editor_cmd, '%')) &&
+	    *(p + 1) == 's' && !strchr(p + 2, '%')) {
+		g_snprintf(buf, sizeof(buf), prefs_common.ext_editor_cmd, file);
+	} else {
+		if (prefs_common.ext_editor_cmd)
+			g_warning(_("External editor command line is invalid: `%s'\n"),
+				  prefs_common.ext_editor_cmd);
+		g_snprintf(buf, sizeof(buf), def_cmd, file);
+	}
+
+	cmdline = g_strsplit(buf, " ", 1024);
+	execvp(cmdline[0], cmdline);
+
+	perror("execvp");
+	g_strfreev(cmdline);
+
+	_exit(1);
+}
+
+static gboolean compose_ext_editor_kill(Compose *compose)
+{
+	pid_t pgid = compose->exteditor_pid * -1;
+	gint ret;
+
+	ret = kill(pgid, 0);
+
+	if (ret == 0 || (ret == -1 && EPERM == errno)) {
+		AlertValue val;
+		gchar *msg;
+
+		msg = g_strdup_printf
+			(_("The external editor is still working.\n"
+			   "Force terminating the process?\n"
+			   "process group id: %d"), -pgid);
+		val = alertpanel(_("Notice"), msg, _("Yes"), _("+No"), NULL);
+		g_free(msg);
+
+		if (val == G_ALERTDEFAULT) {
+			gdk_input_remove(compose->exteditor_tag);
+			close(compose->exteditor_readdes);
+
+			if (kill(pgid, SIGTERM) < 0) perror("kill");
+			waitpid(compose->exteditor_pid, NULL, 0);
+
+			g_warning(_("Terminated process group id: %d"), -pgid);
+			g_warning(_("Temporary file: %s"),
+				  compose->exteditor_file);
+
+			compose_set_ext_editor_sensitive(compose, TRUE);
+
+			g_free(compose->exteditor_file);
+			compose->exteditor_file    = NULL;
+			compose->exteditor_pid     = -1;
+			compose->exteditor_readdes = -1;
+			compose->exteditor_tag     = -1;
+		} else
+			return FALSE;
+	}
+
+	return TRUE;
+}
+
+static void compose_input_cb(gpointer data, gint source,
+			     GdkInputCondition condition)
+{
+	gchar buf[3];
+	Compose *compose = (Compose *)data;
+	gint i = 0;
+
+	debug_print(_("Compose: input from monitoring process\n"));
+
+	gdk_input_remove(compose->exteditor_tag);
+
+	for (;;) {
+		if (read(source, &buf[i], 1) < 1) {
+			buf[0] = '3';
+			break;
+		}
+		if (buf[i] == '\n') {
+			buf[i] = '\0';
+			break;
+		}
+		i++;
+		if (i == sizeof(buf) - 1)
+			break;
+	}
+
+	waitpid(compose->exteditor_pid, NULL, 0);
+
+	if (buf[0] == '0') {		/* success */
+		GtkText *text = GTK_TEXT(compose->text);
+
+		gtk_text_freeze(text);
+		gtk_text_set_point(text, 0);
+		gtk_text_forward_delete(text, gtk_text_get_length(text));
+		compose_insert_file(compose, compose->exteditor_file);
+		compose_changed_cb(NULL, compose);
+		gtk_text_thaw(text);
+
+		if (unlink(compose->exteditor_file) < 0)
+			FILE_OP_ERROR(compose->exteditor_file, "unlink");
+	} else if (buf[0] == '1') {	/* failed */
+		g_warning(_("Couldn't exec external editor\n"));
+		if (unlink(compose->exteditor_file) < 0)
+			FILE_OP_ERROR(compose->exteditor_file, "unlink");
+	} else if (buf[0] == '2') {
+		g_warning(_("Couldn't write to file\n"));
+	} else if (buf[0] == '3') {
+		g_warning(_("Pipe read failed\n"));
+	}
+
+	close(source);
+
+	compose_set_ext_editor_sensitive(compose, TRUE);
+
+	g_free(compose->exteditor_file);
+	compose->exteditor_file    = NULL;
+	compose->exteditor_pid     = -1;
+	compose->exteditor_readdes = -1;
+	compose->exteditor_tag     = -1;
+}
+
+static void compose_set_ext_editor_sensitive(Compose *compose,
+					     gboolean sensitive)
+{
+	GtkItemFactory *ifactory;
+
+	ifactory = gtk_item_factory_from_widget(compose->menubar);
+
+	menu_set_sensitive(ifactory, "/Message/Send", sensitive);
+	menu_set_sensitive(ifactory, "/Message/Send later", sensitive);
+	menu_set_sensitive(ifactory, "/Message/Save to draft folder",
+			   sensitive);
+	menu_set_sensitive(ifactory, "/File/Insert file", sensitive);
+	menu_set_sensitive(ifactory, "/File/Insert signature", sensitive);
+	menu_set_sensitive(ifactory, "/Edit/Wrap long lines", sensitive);
+	menu_set_sensitive(ifactory, "/Edit/Edit with external editor",
+			   sensitive);
+
+	gtk_widget_set_sensitive(compose->text,          sensitive);
+	gtk_widget_set_sensitive(compose->send_btn,      sensitive);
+	gtk_widget_set_sensitive(compose->sendl_btn,     sensitive);
+	gtk_widget_set_sensitive(compose->draft_btn,     sensitive);
+	gtk_widget_set_sensitive(compose->insert_btn,    sensitive);
+	gtk_widget_set_sensitive(compose->sig_btn,       sensitive);
+	gtk_widget_set_sensitive(compose->exteditor_btn, sensitive);
+	gtk_widget_set_sensitive(compose->linewrap_btn,  sensitive);
+}
+
+static gint calc_cursor_xpos(GtkText *text, gint extra, gint char_width)
+{
+	gint cursor_pos;
+
+	cursor_pos = (text->cursor_pos_x - extra) / char_width;
+	cursor_pos = MAX(cursor_pos, 0);
+
+	return cursor_pos;
+}
+
+/* callback functions */
+
+/* compose_edit_size_alloc() - called when resized. don't know whether Gtk
+ * includes "non-client" (windows-izm) in calculation, so this calculation
+ * may not be accurate.
+ */
+static gboolean compose_edit_size_alloc(GtkEditable *widget,
+					GtkAllocation *allocation,
+					GtkSHRuler *shruler)
+{
+	if (prefs_common.show_ruler) {
+		gint char_width;
+		gint line_width_in_chars;
+
+		char_width = gtkut_get_font_width
+			(GTK_WIDGET(widget)->style->font);
+		line_width_in_chars =
+			(allocation->width - allocation->x) / char_width;
+
+		/* got the maximum */
+		gtk_ruler_set_range(GTK_RULER(shruler),
+				    0.0, line_width_in_chars,
+				    calc_cursor_xpos(GTK_TEXT(widget),
+						     allocation->x,
+						     char_width),
+				    /*line_width_in_chars*/ char_width);
+	}
+
+	return TRUE;
+}
+
+static void toolbar_send_cb(GtkWidget *widget, gpointer data)
+{
+	compose_send_cb(data, 0, NULL);
+}
+
+static void toolbar_send_later_cb(GtkWidget *widget, gpointer data)
+{
+	compose_send_later_cb(data, 0, NULL);
+}
+
+static void toolbar_draft_cb(GtkWidget *widget, gpointer data)
+{
+	compose_draft_cb(data, 0, NULL);
+}
+
+static void toolbar_insert_cb(GtkWidget *widget, gpointer data)
+{
+	compose_insert_file_cb(data, 0, NULL);
+}
+
+static void toolbar_attach_cb(GtkWidget *widget, gpointer data)
+{
+	compose_attach_cb(data, 0, NULL);
+}
+
+static void toolbar_sig_cb(GtkWidget *widget, gpointer data)
+{
+	Compose *compose = (Compose *)data;
+
+	compose_insert_sig(compose);
+}
+
+static void toolbar_ext_editor_cb(GtkWidget *widget, gpointer data)
+{
+	Compose *compose = (Compose *)data;
+
+	compose_exec_ext_editor(compose);
+}
+
+static void toolbar_linewrap_cb(GtkWidget *widget, gpointer data)
+{
+	Compose *compose = (Compose *)data;
+
+	compose_wrap_line(compose);
+}
+
+static void toolbar_address_cb(GtkWidget *widget, gpointer data)
+{
+	compose_address_cb(data, 0, NULL);
+}
+
+static void account_activated(GtkMenuItem *menuitem, gpointer data)
+{
+	Compose *compose = (Compose *)data;
+
+	PrefsAccount *ac;
+
+	ac = (PrefsAccount *)gtk_object_get_user_data(GTK_OBJECT(menuitem));
+	g_return_if_fail(ac != NULL);
+
+	if (ac != compose->account) {
+		compose->account = ac;
+		compose_set_title(compose);
+	}
+}
+
+static void attach_selected(GtkCList *clist, gint row, gint column,
+			    GdkEvent *event, gpointer data)
+{
+	Compose *compose = (Compose *)data;
+
+	if (event && event->type == GDK_2BUTTON_PRESS)
+		compose_attach_property(compose);
+}
+
+static void attach_button_pressed(GtkWidget *widget, GdkEventButton *event,
+				  gpointer data)
+{
+	Compose *compose = (Compose *)data;
+	GtkCList *clist = GTK_CLIST(compose->attach_clist);
+	gint row, column;
+
+	if (!event) return;
+
+	if (event->button == 3) {
+		if ((clist->selection && !clist->selection->next) ||
+		    !clist->selection) {
+			gtk_clist_unselect_all(clist);
+			if (gtk_clist_get_selection_info(clist,
+							 event->x, event->y,
+							 &row, &column)) {
+				gtk_clist_select_row(clist, row, column);
+				gtkut_clist_set_focus_row(clist, row);
+			}
+		}
+		gtk_menu_popup(GTK_MENU(compose->popupmenu), NULL, NULL,
+			       NULL, NULL, event->button, event->time);
+	}
+}
+
+static void attach_key_pressed(GtkWidget *widget, GdkEventKey *event,
+			       gpointer data)
+{
+	Compose *compose = (Compose *)data;
+
+	if (!event) return;
+
+	switch (event->keyval) {
+	case GDK_Delete:
+		compose_attach_remove_selected(compose);
+		break;
+	}
+}
+
+static void compose_send_cb(gpointer data, guint action, GtkWidget *widget)
+{
+	Compose *compose = (Compose *)data;
+	gint val;
+
+	val = compose_send(compose);
+
+	if (val == 0) gtk_widget_destroy(compose->window);
+}
+
+static void compose_send_later_cb(gpointer data, guint action,
+				  GtkWidget *widget)
+{
+	Compose *compose = (Compose *)data;
+	gchar tmp[22];
+	gchar *to, *newsgroups;
+
+	to = gtk_entry_get_text(GTK_ENTRY(compose->to_entry));
+	newsgroups = gtk_entry_get_text(GTK_ENTRY(compose->newsgroups_entry));
+	if (*to == '\0' && *newsgroups == '\0') {
+		alertpanel_error(_("Recipient is not specified."));
+		return;
+	}
+
+	g_snprintf(tmp, 22, "%s%ctmpmsg%d",
+		   g_get_tmp_dir(), G_DIR_SEPARATOR, (gint)compose);
+
+	if (prefs_common.linewrap_at_send)
+		compose_wrap_line_all(compose);
+
+	if (compose_write_to_file(compose, tmp, FALSE) < 0 ||
+	    compose_queue(compose, tmp) < 0) {
+		alertpanel_error(_("Can't queue the message."));
+		return;
+	}
+
+	if (prefs_common.savemsg) {
+		if (compose_save_to_outbox(compose, tmp) < 0)
+			alertpanel_error
+				(_("Can't save the message to outbox."));
+	}
+
+	if (unlink(tmp) < 0)
+		FILE_OP_ERROR(tmp, "unlink");
+
+	gtk_widget_destroy(compose->window);
+}
+
+static void compose_draft_cb(gpointer data, guint action, GtkWidget *widget)
+{
+	Compose *compose = (Compose *)data;
+	FolderItem *draft;
+	gchar *tmp;
+
+	draft = folder_get_default_draft();
+
+	tmp = g_strdup_printf("%s%cdraft.%d", g_get_tmp_dir(),
+			      G_DIR_SEPARATOR, (gint)compose);
+
+	if (compose_write_to_file(compose, tmp, TRUE) < 0) {
+		g_free(tmp);
+		return;
+	}
+
+	folder_item_scan(draft);
+	if (folder_item_add_msg(draft, tmp, TRUE) < 0) {
+		unlink(tmp);
+		g_free(tmp);
+		return;
+	}
+	g_free(tmp);
+
+	if (compose->mode == COMPOSE_REEDIT) {
+		compose_remove_reedit_target(compose);
+		if (compose->targetinfo &&
+		    compose->targetinfo->folder != draft)
+			folderview_update_item(compose->targetinfo->folder,
+					       TRUE);
+	}
+
+	folder_item_scan(draft);
+	folderview_update_item(draft, TRUE);
+
+	gtk_widget_destroy(compose->window);
+}
+
+static void compose_attach_cb(gpointer data, guint action, GtkWidget *widget)
+{
+	Compose *compose = (Compose *)data;
+	gchar *file;
+
+	file = filesel_select_file(_("Select file"), NULL);
+
+	if (file)
+		compose_attach_append(compose, file, MIME_UNKNOWN);
+}
+
+static void compose_insert_file_cb(gpointer data, guint action,
+				   GtkWidget *widget)
+{
+	Compose *compose = (Compose *)data;
+	gchar *file;
+
+	file = filesel_select_file(_("Select file"), NULL);
+
+	if (file)
+		compose_insert_file(compose, file);
+}
+
+static gint compose_delete_cb(GtkWidget *widget, GdkEventAny *event,
+			      gpointer data)
+{
+	compose_close_cb(data, 0, NULL);
+	return TRUE;
+}
+
+static void compose_close_cb(gpointer data, guint action, GtkWidget *widget)
+{
+	Compose *compose = (Compose *)data;
+	AlertValue val;
+
+	if (compose->exteditor_tag != -1) {
+		if (!compose_ext_editor_kill(compose))
+			return;
+	}
+
+	if (compose->modified) {
+		val = alertpanel(_("Discard message"),
+				 _("This message has been modified. discard it?"),
+				 _("Discard"), _("to Draft"), _("Cancel"));
+
+		switch (val) {
+		case G_ALERTDEFAULT:
+			break;
+		case G_ALERTALTERNATE:
+			compose_draft_cb(data, 0, NULL);
+			return;
+		default:
+			return;
+		}
+	}
+
+	gtk_widget_destroy(compose->window);
+}
+
+static void compose_address_cb(gpointer data, guint action, GtkWidget *widget)
+{
+	Compose *compose = (Compose *)data;
+
+	addressbook_open(compose);
+}
+
+static void compose_ext_editor_cb(gpointer data, guint action,
+				  GtkWidget *widget)
+{
+	Compose *compose = (Compose *)data;
+
+	compose_exec_ext_editor(compose);
+}
+
+static void compose_destroy_cb(GtkWidget *widget, Compose *compose)
+{
+	compose_destroy(compose);
+}
+
+static void compose_cut_cb(Compose *compose)
+{
+	if (compose->focused_editable &&
+	    GTK_WIDGET_HAS_FOCUS(compose->focused_editable))
+		gtk_editable_cut_clipboard
+			(GTK_EDITABLE(compose->focused_editable));
+}
+
+static void compose_copy_cb(Compose *compose)
+{
+	if (compose->focused_editable &&
+	    GTK_WIDGET_HAS_FOCUS(compose->focused_editable))
+		gtk_editable_copy_clipboard
+			(GTK_EDITABLE(compose->focused_editable));
+}
+
+static void compose_paste_cb(Compose *compose)
+{
+	if (compose->focused_editable &&
+	    GTK_WIDGET_HAS_FOCUS(compose->focused_editable))
+		gtk_editable_paste_clipboard
+			(GTK_EDITABLE(compose->focused_editable));
+}
+
+static void compose_allsel_cb(Compose *compose)
+{
+	if (compose->focused_editable &&
+	    GTK_WIDGET_HAS_FOCUS(compose->focused_editable))
+		gtk_editable_select_region
+			(GTK_EDITABLE(compose->focused_editable), 0, -1);
+}
+
+static void compose_grab_focus_cb(GtkWidget *widget, Compose *compose)
+{
+	if (GTK_IS_EDITABLE(widget))
+		compose->focused_editable = widget;
+}
+
+static void compose_changed_cb(GtkEditable *editable, Compose *compose)
+{
+	if (compose->modified == FALSE) {
+		compose->modified = TRUE;
+		compose_set_title(compose);
+	}
+}
+
+static void compose_button_press_cb(GtkWidget *widget, GdkEventButton *event,
+				    Compose *compose)
+{
+	gtk_text_set_point(GTK_TEXT(widget),
+			   gtk_editable_get_position(GTK_EDITABLE(widget)));
+}
+
+#if 0
+static void compose_key_press_cb(GtkWidget *widget, GdkEventKey *event,
+				 Compose *compose)
+{
+	gtk_text_set_point(GTK_TEXT(widget),
+			   gtk_editable_get_position(GTK_EDITABLE(widget)));
+}
+#endif
+
+static void compose_toggle_to_cb(gpointer data, guint action,
+				 GtkWidget *widget)
+{
+	Compose *compose = (Compose *)data;
+
+	if (GTK_CHECK_MENU_ITEM(widget)->active) {
+		gtk_widget_show(compose->to_hbox);
+		gtk_widget_show(compose->to_entry);
+		gtk_table_set_row_spacing(GTK_TABLE(compose->table), 1, 4);
+		compose->use_to = TRUE;
+	} else {
+		gtk_widget_hide(compose->to_hbox);
+		gtk_widget_hide(compose->to_entry);
+		gtk_table_set_row_spacing(GTK_TABLE(compose->table), 1, 0);
+		gtk_widget_queue_resize(compose->table_vbox);
+		compose->use_to = FALSE;
+	}
+
+	if (addressbook_get_target_compose() == compose)
+		addressbook_set_target_compose(compose);
+}
+
+static void compose_toggle_cc_cb(gpointer data, guint action,
+				 GtkWidget *widget)
+{
+	Compose *compose = (Compose *)data;
+
+	if (GTK_CHECK_MENU_ITEM(widget)->active) {
+		gtk_widget_show(compose->cc_hbox);
+		gtk_widget_show(compose->cc_entry);
+		gtk_table_set_row_spacing(GTK_TABLE(compose->table), 3, 4);
+		compose->use_cc = TRUE;
+	} else {
+		gtk_widget_hide(compose->cc_hbox);
+		gtk_widget_hide(compose->cc_entry);
+		gtk_table_set_row_spacing(GTK_TABLE(compose->table), 3, 0);
+		gtk_widget_queue_resize(compose->table_vbox);
+		compose->use_cc = FALSE;
+	}
+
+	if (addressbook_get_target_compose() == compose)
+		addressbook_set_target_compose(compose);
+}
+
+static void compose_toggle_bcc_cb(gpointer data, guint action,
+				  GtkWidget *widget)
+{
+	Compose *compose = (Compose *)data;
+
+	if (GTK_CHECK_MENU_ITEM(widget)->active) {
+		gtk_widget_show(compose->bcc_hbox);
+		gtk_widget_show(compose->bcc_entry);
+		gtk_table_set_row_spacing(GTK_TABLE(compose->table), 4, 4);
+		compose->use_bcc = TRUE;
+	} else {
+		gtk_widget_hide(compose->bcc_hbox);
+		gtk_widget_hide(compose->bcc_entry);
+		gtk_table_set_row_spacing(GTK_TABLE(compose->table), 4, 0);
+		gtk_widget_queue_resize(compose->table_vbox);
+		compose->use_bcc = FALSE;
+	}
+
+	if (addressbook_get_target_compose() == compose)
+		addressbook_set_target_compose(compose);
+}
+
+static void compose_toggle_replyto_cb(gpointer data, guint action,
+				      GtkWidget *widget)
+{
+	Compose *compose = (Compose *)data;
+
+	if (GTK_CHECK_MENU_ITEM(widget)->active) {
+		gtk_widget_show(compose->reply_hbox);
+		gtk_widget_show(compose->reply_entry);
+		gtk_table_set_row_spacing(GTK_TABLE(compose->table), 5, 4);
+		compose->use_replyto = TRUE;
+	} else {
+		gtk_widget_hide(compose->reply_hbox);
+		gtk_widget_hide(compose->reply_entry);
+		gtk_table_set_row_spacing(GTK_TABLE(compose->table), 5, 0);
+		gtk_widget_queue_resize(compose->table_vbox);
+		compose->use_replyto = FALSE;
+	}
+}
+
+static void compose_toggle_followupto_cb(gpointer data, guint action,
+					 GtkWidget *widget)
+{
+	Compose *compose = (Compose *)data;
+
+	if (GTK_CHECK_MENU_ITEM(widget)->active) {
+		gtk_widget_show(compose->followup_hbox);
+		gtk_widget_show(compose->followup_entry);
+		gtk_table_set_row_spacing(GTK_TABLE(compose->table), 6, 4);
+		compose->use_followupto = TRUE;
+	} else {
+		gtk_widget_hide(compose->followup_hbox);
+		gtk_widget_hide(compose->followup_entry);
+		gtk_table_set_row_spacing(GTK_TABLE(compose->table), 6, 0);
+		gtk_widget_queue_resize(compose->table_vbox);
+		compose->use_followupto = FALSE;
+	}
+}
+
+static void compose_toggle_attach_cb(gpointer data, guint action,
+				     GtkWidget *widget)
+{
+	Compose *compose = (Compose *)data;
+
+	if (GTK_CHECK_MENU_ITEM(widget)->active) {
+		gtk_widget_ref(compose->edit_vbox);
+
+		gtk_container_remove(GTK_CONTAINER(compose->vbox2),
+				     compose->edit_vbox);
+		gtk_paned_add2(GTK_PANED(compose->paned), compose->edit_vbox);
+		gtk_box_pack_start(GTK_BOX(compose->vbox2), compose->paned,
+				   TRUE, TRUE, 0);
+		gtk_widget_show(compose->paned);
+
+		gtk_widget_unref(compose->edit_vbox);
+		gtk_widget_unref(compose->paned);
+
+		compose->use_attach = TRUE;
+	} else {
+		gtk_widget_ref(compose->paned);
+		gtk_widget_ref(compose->edit_vbox);
+
+		gtk_container_remove(GTK_CONTAINER(compose->vbox2),
+				     compose->paned);
+		gtk_container_remove(GTK_CONTAINER(compose->paned),
+				     compose->edit_vbox);
+		gtk_box_pack_start(GTK_BOX(compose->vbox2),
+				   compose->edit_vbox, TRUE, TRUE, 0);
+
+		gtk_widget_unref(compose->edit_vbox);
+
+		compose->use_attach = FALSE;
+	}
+}
+
+#if USE_GPGME
+static void compose_toggle_sign_cb(gpointer data, guint action,
+				   GtkWidget *widget)
+{
+	Compose *compose = (Compose *)data;
+
+	if (GTK_CHECK_MENU_ITEM(widget)->active)
+		compose->use_signing = TRUE;
+	else
+		compose->use_signing = FALSE;
+}
+
+static void compose_toggle_encrypt_cb(gpointer data, guint action,
+				      GtkWidget *widget)
+{
+	Compose *compose = (Compose *)data;
+
+	if (GTK_CHECK_MENU_ITEM(widget)->active)
+		compose->use_encryption = TRUE;
+	else
+		compose->use_encryption = FALSE;
+}
+#endif /* USE_GPGME */
+
+static void compose_toggle_ruler_cb(gpointer data, guint action,
+				    GtkWidget *widget)
+{
+	Compose *compose = (Compose *)data;
+
+	if (GTK_CHECK_MENU_ITEM(widget)->active) {
+		gtk_widget_show(compose->ruler_hbox);
+		prefs_common.show_ruler = TRUE;
+	} else {
+		gtk_widget_hide(compose->ruler_hbox);
+		gtk_widget_queue_resize(compose->edit_vbox);
+		prefs_common.show_ruler = FALSE;
+	}
+}
+
+static void compose_attach_drag_received_cb (GtkWidget		*widget,
+					     GdkDragContext	*drag_context,
+					     gint		 x,
+					     gint		 y,
+					     GtkSelectionData	*data,
+					     guint		 info,
+					     guint		 time,
+					     gpointer		 user_data)
+{
+	Compose *compose = (Compose *)user_data;
+	GList *list, *tmp;
+
+	list = uri_list_extract_filenames((const gchar *)data->data);
+	for (tmp = list; tmp != NULL; tmp = tmp->next)
+		compose_attach_append(compose, (const gchar *)tmp->data,
+				      MIME_UNKNOWN);
+	list_free_strings(list);
+	g_list_free(list);
+}
+
+static void compose_insert_drag_received_cb (GtkWidget		*widget,
+					     GdkDragContext	*drag_context,
+					     gint		 x,
+					     gint		 y,
+					     GtkSelectionData	*data,
+					     guint		 info,
+					     guint		 time,
+					     gpointer		 user_data)
+{
+	Compose *compose = (Compose *)user_data;
+	GList *list, *tmp;
+
+	list = uri_list_extract_filenames((const gchar *)data->data);
+	for (tmp = list; tmp != NULL; tmp = tmp->next)
+		compose_insert_file(compose, (const gchar *)tmp->data);
+	list_free_strings(list);
+	g_list_free(list);
+}
+
+static void to_activated(GtkWidget *widget, Compose *compose)
+{
+	if (GTK_WIDGET_VISIBLE(compose->newsgroups_entry))
+		gtk_widget_grab_focus(compose->newsgroups_entry);
+	else
+		gtk_widget_grab_focus(compose->subject_entry);
+}
+
+static void newsgroups_activated(GtkWidget *widget, Compose *compose)
+{
+	gtk_widget_grab_focus(compose->subject_entry);
+}
+
+static void subject_activated(GtkWidget *widget, Compose *compose)
+{
+	if (GTK_WIDGET_VISIBLE(compose->cc_entry))
+		gtk_widget_grab_focus(compose->cc_entry);
+	else if (GTK_WIDGET_VISIBLE(compose->bcc_entry))
+		gtk_widget_grab_focus(compose->bcc_entry);
+	else if (GTK_WIDGET_VISIBLE(compose->reply_entry))
+		gtk_widget_grab_focus(compose->reply_entry);
+	else if (GTK_WIDGET_VISIBLE(compose->followup_entry))
+		gtk_widget_grab_focus(compose->followup_entry);
+	else
+		gtk_widget_grab_focus(compose->text);
+}
+
+static void cc_activated(GtkWidget *widget, Compose *compose)
+{
+	if (GTK_WIDGET_VISIBLE(compose->bcc_entry))
+		gtk_widget_grab_focus(compose->bcc_entry);
+	else if (GTK_WIDGET_VISIBLE(compose->reply_entry))
+		gtk_widget_grab_focus(compose->reply_entry);
+	else if (GTK_WIDGET_VISIBLE(compose->followup_entry))
+		gtk_widget_grab_focus(compose->followup_entry);
+	else
+		gtk_widget_grab_focus(compose->text);
+}
+
+static void bcc_activated(GtkWidget *widget, Compose *compose)
+{
+	if (GTK_WIDGET_VISIBLE(compose->reply_entry))
+		gtk_widget_grab_focus(compose->reply_entry);
+	else if (GTK_WIDGET_VISIBLE(compose->followup_entry))
+		gtk_widget_grab_focus(compose->followup_entry);
+	else
+		gtk_widget_grab_focus(compose->text);
+}
+
+static void replyto_activated(GtkWidget *widget, Compose *compose)
+{
+	if (GTK_WIDGET_VISIBLE(compose->followup_entry))
+		gtk_widget_grab_focus(compose->followup_entry);
+	else
+		gtk_widget_grab_focus(compose->text);
+}
+
+static void followupto_activated(GtkWidget *widget, Compose *compose)
+{
+	gtk_widget_grab_focus(compose->text);
+}
diff -urN sylpheed-0.6.2.orig/src/compose.h sylpheed-0.6.2/src/compose.h
--- sylpheed-0.6.2.orig/src/compose.h	Tue Sep 11 16:14:03 2001
+++ sylpheed-0.6.2/src/compose.h	Fri Oct  5 14:13:33 2001
@@ -170,6 +170,7 @@
 				 gboolean	 to_all,
 				 gboolean	 ignore_replyto);
 void compose_forward		(MsgInfo	*msginfo,
+				 gboolean	 quote,
 				 gboolean	 as_attach);
 void compose_reedit		(MsgInfo	*msginfo);
 
diff -urN sylpheed-0.6.2.orig/src/compose.h.orig sylpheed-0.6.2/src/compose.h.orig
--- sylpheed-0.6.2.orig/src/compose.h.orig	Thu Jan  1 01:00:00 1970
+++ sylpheed-0.6.2/src/compose.h.orig	Tue Sep 11 16:14:03 2001
@@ -0,0 +1,182 @@
+/*
+ * Sylpheed -- a GTK+ based, lightweight, and fast e-mail client
+ * Copyright (C) 1999-2001 Hiroyuki Yamamoto
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef __COMPOSE_H__
+#define __COMPOSE_H__
+
+#include <glib.h>
+#include <gtk/gtkwidget.h>
+#include <gtk/gtkitemfactory.h>
+
+typedef struct _Compose		Compose;
+typedef struct _AttachInfo	AttachInfo;
+
+#include "procmsg.h"
+#include "procmime.h"
+#include "addressbook.h"
+#include "prefs_account.h"
+
+typedef enum
+{
+	COMPOSE_TO,
+	COMPOSE_CC,
+	COMPOSE_BCC,
+	COMPOSE_NEWSGROUPS
+} ComposeEntryType;
+
+typedef enum
+{
+	COMPOSE_REPLY,
+	COMPOSE_REPLY_WITH_QUOTE,
+	COMPOSE_REPLY_WITHOUT_QUOTE,
+	COMPOSE_REPLY_TO_SENDER,
+	COMPOSE_REPLY_TO_SENDER_WITH_QUOTE,
+	COMPOSE_REPLY_TO_SENDER_WITHOUT_QUOTE,
+	COMPOSE_REPLY_TO_ALL,
+	COMPOSE_REPLY_TO_ALL_WITH_QUOTE,
+	COMPOSE_REPLY_TO_ALL_WITHOUT_QUOTE,
+	COMPOSE_FORWARD,
+	COMPOSE_FORWARD_AS_ATTACH,
+	COMPOSE_NEW,
+	COMPOSE_REEDIT
+} ComposeMode;
+
+struct _Compose
+{
+	GtkWidget *window;
+	GtkWidget *vbox;
+	GtkWidget *menubar;
+
+	GtkWidget *handlebox;
+	GtkWidget *toolbar;
+	GtkWidget *send_btn;
+	GtkWidget *sendl_btn;
+	GtkWidget *draft_btn;
+	GtkWidget *insert_btn;
+	GtkWidget *attach_btn;
+	GtkWidget *sig_btn;
+	GtkWidget *exteditor_btn;
+	GtkWidget *linewrap_btn;
+	GtkWidget *addrbook_btn;
+
+	GtkWidget *vbox2;
+
+	GtkWidget *table_vbox;
+	GtkWidget *table;
+	GtkWidget *to_hbox;
+	GtkWidget *to_entry;
+	GtkWidget *newsgroups_hbox;
+	GtkWidget *newsgroups_entry;
+	GtkWidget *subject_entry;
+	GtkWidget *cc_hbox;
+	GtkWidget *cc_entry;
+	GtkWidget *bcc_hbox;
+	GtkWidget *bcc_entry;
+	GtkWidget *reply_hbox;
+	GtkWidget *reply_entry;
+	GtkWidget *followup_hbox;
+	GtkWidget *followup_entry;
+
+	GtkWidget *paned;
+
+	GtkWidget *attach_scrwin;
+	GtkWidget *attach_clist;
+
+	GtkWidget *edit_vbox;
+	GtkWidget *ruler_hbox;
+	GtkWidget *ruler;
+	GtkWidget *scrolledwin;
+	GtkWidget *text;
+
+	GtkWidget *focused_editable;
+
+	GtkWidget *popupmenu;
+
+	GtkItemFactory *popupfactory;
+
+	ComposeMode mode;
+
+	MsgInfo *targetinfo;
+
+	gchar	*replyto;
+	gchar	*cc;
+	gchar	*bcc;
+	gchar	*newsgroups;
+	gchar	*followup_to;
+
+	gchar	*inreplyto;
+	gchar	*references;
+	gchar	*msgid;
+	gchar	*boundary;
+
+	gboolean use_to;
+	gboolean use_cc;
+	gboolean use_bcc;
+	gboolean use_replyto;
+	gboolean use_followupto;
+	gboolean use_attach;
+
+	/* privacy settings */
+	gboolean use_signing;
+	gboolean use_encryption;
+
+	gboolean modified;
+
+	GSList *to_list;
+	GSList *newsgroup_list;
+
+	PrefsAccount *account;
+	PrefsAccount *orig_account;
+
+	/* external editor */
+	gchar *exteditor_file;
+	pid_t  exteditor_pid;
+	gint   exteditor_readdes;
+	gint   exteditor_tag;
+};
+
+struct _AttachInfo
+{
+	gchar *file;
+	gchar *content_type;
+	EncodingType encoding;
+	gchar *name;
+	off_t size;
+};
+
+void compose_new		(PrefsAccount	*account);
+
+void compose_new_with_recipient	(PrefsAccount	*account,
+				 const gchar	*to);
+
+void compose_reply		(MsgInfo	*msginfo,
+				 gboolean	 quote,
+				 gboolean	 to_all,
+				 gboolean	 ignore_replyto);
+void compose_forward		(MsgInfo	*msginfo,
+				 gboolean	 as_attach);
+void compose_reedit		(MsgInfo	*msginfo);
+
+GList *compose_get_compose_list	(void);
+
+void compose_entry_append	(Compose	  *compose,
+				 const gchar	  *address,
+				 ComposeEntryType  type);
+
+#endif /* __COMPOSE_H__ */
diff -urN sylpheed-0.6.2.orig/src/mainwindow.c sylpheed-0.6.2/src/mainwindow.c
--- sylpheed-0.6.2.orig/src/mainwindow.c	Tue Sep 11 16:14:03 2001
+++ sylpheed-0.6.2/src/mainwindow.c	Fri Oct  5 14:13:33 2001
@@ -2016,10 +2016,12 @@
 			      TRUE, FALSE);
 		break;
 	case COMPOSE_FORWARD:
-		compose_forward(msginfo, FALSE);
+		compose_forward(msginfo, prefs_common.forward_with_quote,
+				FALSE);
 		break;
 	case COMPOSE_FORWARD_AS_ATTACH:
-		compose_forward(msginfo, TRUE);
+		compose_forward(msginfo, prefs_common.forward_with_quote,
+				TRUE);
 		break;
 	default:
 		g_warning("reply_cb(): invalid action type: %d\n", action);
diff -urN sylpheed-0.6.2.orig/src/mainwindow.c.orig sylpheed-0.6.2/src/mainwindow.c.orig
--- sylpheed-0.6.2.orig/src/mainwindow.c.orig	Thu Jan  1 01:00:00 1970
+++ sylpheed-0.6.2/src/mainwindow.c.orig	Tue Sep 11 16:14:03 2001
@@ -0,0 +1,2316 @@
+/*
+ * Sylpheed -- a GTK+ based, lightweight, and fast e-mail client
+ * Copyright (C) 1999-2001 Hiroyuki Yamamoto
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include "defs.h"
+
+#include <glib.h>
+#include <gtk/gtkmain.h>
+#include <gtk/gtkwindow.h>
+#include <gtk/gtkwidget.h>
+#include <gtk/gtksignal.h>
+#include <gtk/gtkvbox.h>
+#include <gtk/gtkcontainer.h>
+#include <gtk/gtkstatusbar.h>
+#include <gtk/gtkprogressbar.h>
+#include <gtk/gtkhpaned.h>
+#include <gtk/gtkvpaned.h>
+#include <gtk/gtkcheckmenuitem.h>
+#include <gtk/gtkitemfactory.h>
+#include <gtk/gtkeditable.h>
+#include <gtk/gtkmenu.h>
+#include <gtk/gtkmenuitem.h>
+#include <gtk/gtkhandlebox.h>
+#include <gtk/gtktoolbar.h>
+#include <gtk/gtkbutton.h>
+#include <string.h>
+
+#include "intl.h"
+#include "main.h"
+#include "mainwindow.h"
+#include "folderview.h"
+#include "foldersel.h"
+#include "summaryview.h"
+#include "summary_search.h"
+#include "messageview.h"
+#include "headerview.h"
+#include "menu.h"
+#include "folder.h"
+#include "inc.h"
+#include "compose.h"
+#include "procmsg.h"
+#include "import.h"
+#include "export.h"
+#include "prefs_common.h"
+#include "prefs_filter.h"
+#include "prefs_account.h"
+#include "account.h"
+#include "addressbook.h"
+#include "headerwindow.h"
+#include "logwindow.h"
+#include "manage_window.h"
+#include "alertpanel.h"
+#include "statusbar.h"
+#include "inputdialog.h"
+#include "utils.h"
+#include "gtkutils.h"
+#include "codeconv.h"
+#include "about.h"
+#include "manual.h"
+#include "version.h"
+
+#define AC_LABEL_WIDTH	240
+
+#define STATUSBAR_PUSH(mainwin, str) \
+{ \
+	gtk_statusbar_push(GTK_STATUSBAR(mainwin->statusbar), \
+			   mainwin->mainwin_cid, str); \
+	gtkut_widget_wait_for_draw(mainwin->hbox_stat); \
+}
+
+#define STATUSBAR_POP(mainwin) \
+{ \
+	gtk_statusbar_pop(GTK_STATUSBAR(mainwin->statusbar), \
+			  mainwin->mainwin_cid); \
+}
+
+/* list of all instantiated MainWindow */
+static GList *mainwin_list = NULL;
+
+static GdkCursor *watch_cursor;
+
+static void main_window_show_cur_account	(MainWindow	*mainwin);
+
+static void main_window_set_widgets		(MainWindow	*mainwin,
+						 SeparateType	 type);
+static void main_window_toolbar_create		(MainWindow	*mainwin,
+						 GtkWidget	*container);
+
+/* callback functions */
+static void toolbar_inc_cb		(GtkWidget	*widget,
+					 gpointer	 data);
+static void toolbar_inc_all_cb		(GtkWidget	*widget,
+					 gpointer	 data);
+static void toolbar_send_cb		(GtkWidget	*widget,
+					 gpointer	 data);
+
+static void toolbar_compose_cb		(GtkWidget	*widget,
+					 gpointer	 data);
+static void toolbar_reply_cb		(GtkWidget	*widget,
+					 gpointer	 data);
+static void toolbar_reply_to_all_cb	(GtkWidget	*widget,
+					 gpointer	 data);
+static void toolbar_forward_cb		(GtkWidget	*widget,
+					 gpointer	 data);
+
+static void toolbar_delete_cb		(GtkWidget	*widget,
+					 gpointer	 data);
+static void toolbar_exec_cb		(GtkWidget	*widget,
+					 gpointer	 data);
+
+static void toolbar_next_unread_cb	(GtkWidget	*widget,
+					 gpointer	 data);
+
+static void toolbar_prefs_cb		(GtkWidget	*widget,
+					 gpointer	 data);
+static void toolbar_account_cb		(GtkWidget	*widget,
+					 gpointer	 data);
+
+static void toolbar_account_button_pressed	(GtkWidget	*widget,
+						 GdkEventButton	*event,
+						 gpointer	 data);
+static void ac_label_button_pressed		(GtkWidget	*widget,
+						 GdkEventButton	*event,
+						 gpointer	 data);
+static void ac_menu_popup_closed		(GtkMenuShell	*menu_shell,
+						 gpointer	 data);
+
+static gint main_window_close_cb (GtkWidget	*widget,
+				  GdkEventAny	*event,
+				  gpointer	 data);
+
+static void add_mailbox_cb	 (MainWindow	*mainwin,
+				  guint		 action,
+				  GtkWidget	*widget);
+static void update_folderview_cb (MainWindow	*mainwin,
+				  guint		 action,
+				  GtkWidget	*widget);
+static void new_folder_cb	 (MainWindow	*mainwin,
+				  guint		 action,
+				  GtkWidget	*widget);
+static void rename_folder_cb	 (MainWindow	*mainwin,
+				  guint		 action,
+				  GtkWidget	*widget);
+static void delete_folder_cb	 (MainWindow	*mainwin,
+				  guint		 action,
+				  GtkWidget	*widget);
+static void import_mbox_cb	 (MainWindow	*mainwin,
+				  guint		 action,
+				  GtkWidget	*widget);
+static void export_mbox_cb	 (MainWindow	*mainwin,
+				  guint		 action,
+				  GtkWidget	*widget);
+static void empty_trash_cb	 (MainWindow	*mainwin,
+				  guint		 action,
+				  GtkWidget	*widget);
+
+static void save_as_cb		 (MainWindow	*mainwin,
+				  guint		 action,
+				  GtkWidget	*widget);
+static void print_cb		 (MainWindow	*mainwin,
+				  guint		 action,
+				  GtkWidget	*widget);
+static void app_exit_cb		 (MainWindow	*mainwin,
+				  guint		 action,
+				  GtkWidget	*widget);
+
+static void toggle_folder_cb	 (MainWindow	*mainwin,
+				  guint		 action,
+				  GtkWidget	*widget);
+static void toggle_message_cb	 (MainWindow	*mainwin,
+				  guint		 action,
+				  GtkWidget	*widget);
+static void toggle_toolbar_cb	 (MainWindow	*mainwin,
+				  guint		 action,
+				  GtkWidget	*widget);
+static void toggle_statusbar_cb	 (MainWindow	*mainwin,
+				  guint		 action,
+				  GtkWidget	*widget);
+static void separate_widget_cb	 (MainWindow	*mainwin,
+				  guint		 action,
+				  GtkWidget	*widget);
+
+static void addressbook_open_cb	(MainWindow	*mainwin,
+				 guint		 action,
+				 GtkWidget	*widget);
+static void log_window_show_cb	(MainWindow	*mainwin,
+				 guint		 action,
+				 GtkWidget	*widget);
+
+static void inc_mail_cb			(MainWindow	*mainwin,
+					 guint		 action,
+					 GtkWidget	*widget);
+static void inc_all_account_mail_cb	(MainWindow	*mainwin,
+					 guint		 action,
+					 GtkWidget	*widget);
+
+static void send_queue_cb		(MainWindow	*mainwin,
+					 guint		 action,
+					 GtkWidget	*widget);
+
+static void compose_cb			(MainWindow	*mainwin,
+					 guint		 action,
+					 GtkWidget	*widget);
+static void reply_cb			(MainWindow	*mainwin,
+					 guint		 action,
+					 GtkWidget	*widget);
+
+static void open_msg_cb			(MainWindow	*mainwin,
+					 guint		 action,
+					 GtkWidget	*widget);
+
+static void view_source_cb		(MainWindow	*mainwin,
+					 guint		 action,
+					 GtkWidget	*widget);
+
+static void reedit_cb			(MainWindow	*mainwin,
+					 guint		 action,
+					 GtkWidget	*widget);
+
+static void move_to_cb			(MainWindow	*mainwin,
+					 guint		 action,
+					 GtkWidget	*widget);
+static void copy_to_cb			(MainWindow	*mainwin,
+					 guint		 action,
+					 GtkWidget	*widget);
+static void delete_cb			(MainWindow	*mainwin,
+					 guint		 action,
+					 GtkWidget	*widget);
+
+static void mark_cb			(MainWindow	*mainwin,
+					 guint		 action,
+					 GtkWidget	*widget);
+static void unmark_cb			(MainWindow	*mainwin,
+					 guint		 action,
+					 GtkWidget	*widget);
+
+static void mark_as_unread_cb		(MainWindow	*mainwin,
+					 guint		 action,
+					 GtkWidget	*widget);
+static void mark_as_read_cb		(MainWindow	*mainwin,
+					 guint		 action,
+					 GtkWidget	*widget);
+static void mark_all_read_cb		(MainWindow	*mainwin,
+					 guint		 action,
+					 GtkWidget	*widget);
+static void add_address_cb		(MainWindow	*mainwin,
+					 guint		 action,
+					 GtkWidget	*widget);
+
+static void set_charset_cb		(MainWindow	*mainwin,
+					 guint		 action,
+					 GtkWidget	*widget);
+
+static void thread_cb		 (MainWindow	*mainwin,
+				  guint		 action,
+				  GtkWidget	*widget);
+static void set_display_item_cb	 (MainWindow	*mainwin,
+				  guint		 action,
+				  GtkWidget	*widget);
+static void sort_summary_cb	 (MainWindow	*mainwin,
+				  guint		 action,
+				  GtkWidget	*widget);
+static void attract_by_subject_cb(MainWindow	*mainwin,
+				  guint		 action,
+				  GtkWidget	*widget);
+
+static void delete_duplicated_cb (MainWindow	*mainwin,
+				  guint		 action,
+				  GtkWidget	*widget);
+static void filter_cb		 (MainWindow	*mainwin,
+				  guint		 action,
+				  GtkWidget	*widget);
+static void execute_summary_cb	 (MainWindow	*mainwin,
+				  guint		 action,
+				  GtkWidget	*widget);
+static void update_summary_cb	 (MainWindow	*mainwin,
+				  guint		 action,
+				  GtkWidget	*widget);
+
+static void prev_cb		 (MainWindow	*mainwin,
+				  guint		 action,
+				  GtkWidget	*widget);
+static void next_cb		 (MainWindow	*mainwin,
+				  guint		 action,
+				  GtkWidget	*widget);
+
+static void prev_unread_cb	 (MainWindow	*mainwin,
+				  guint		 action,
+				  GtkWidget	*widget);
+static void next_unread_cb	 (MainWindow	*mainwin,
+				  guint		 action,
+				  GtkWidget	*widget);
+static void prev_marked_cb	 (MainWindow	*mainwin,
+				  guint		 action,
+				  GtkWidget	*widget);
+static void next_marked_cb	 (MainWindow	*mainwin,
+				  guint		 action,
+				  GtkWidget	*widget);
+static void prev_labeled_cb	 (MainWindow	*mainwin,
+				  guint		 action,
+				  GtkWidget	*widget);
+static void next_labeled_cb	 (MainWindow	*mainwin,
+				  guint		 action,
+				  GtkWidget	*widget);
+
+static void goto_folder_cb	 (MainWindow	*mainwin,
+				  guint		 action,
+				  GtkWidget	*widget);
+
+static void copy_cb		 (MainWindow	*mainwin,
+				  guint		 action,
+				  GtkWidget	*widget);
+static void allsel_cb		 (MainWindow	*mainwin,
+				  guint		 action,
+				  GtkWidget	*widget);
+
+static void prefs_common_open_cb (MainWindow	*mainwin,
+				  guint		 action,
+				  GtkWidget	*widget);
+static void prefs_filter_open_cb (MainWindow	*mainwin,
+				  guint		 action,
+				  GtkWidget	*widget);
+static void prefs_account_open_cb(MainWindow	*mainwin,
+				  guint		 action,
+				  GtkWidget	*widget);
+static void new_account_cb	 (MainWindow	*mainwin,
+				  guint		 action,
+				  GtkWidget	*widget);
+
+static void account_menu_cb	 (GtkMenuItem	*menuitem,
+				  gpointer	 data);
+
+static void manual_open_cb	 (MainWindow	*mainwin,
+				  guint		 action,
+				  GtkWidget	*widget);
+
+static void scan_tree_func	 (Folder	*folder,
+				  FolderItem	*item,
+				  gpointer	 data);
+
+static GtkItemFactoryEntry mainwin_entries[] =
+{
+	{N_("/_File"),				NULL, NULL, 0, "<Branch>"},
+	{N_("/_File/_Add mailbox..."),		NULL, add_mailbox_cb, 0, NULL},
+	{N_("/_File/_Update folder tree"),	NULL, update_folderview_cb, 0, NULL},
+	{N_("/_File/_Folder"),			NULL, NULL, 0, "<Branch>"},
+	{N_("/_File/_Folder/Create _new folder..."),
+						NULL, new_folder_cb, 0, NULL},
+	{N_("/_File/_Folder/_Rename folder..."),NULL, rename_folder_cb, 0, NULL},
+	{N_("/_File/_Folder/_Delete folder"),	NULL, delete_folder_cb, 0, NULL},
+	{N_("/_File/_Import mbox file..."),	NULL, import_mbox_cb, 0, NULL},
+	{N_("/_File/_Export to mbox file..."),	NULL, export_mbox_cb, 0, NULL},
+	{N_("/_File/Empty _trash"),		NULL, empty_trash_cb, 0, NULL},
+	{N_("/_File/---"),			NULL, NULL, 0, "<Separator>"},
+	{N_("/_File/_Save as..."),		NULL, save_as_cb, 0, NULL},
+	{N_("/_File/_Print..."),		"<alt>P", print_cb, 0, NULL},
+	{N_("/_File/---"),			NULL, NULL, 0, "<Separator>"},
+	{N_("/_File/_Close"),			"<alt>W", app_exit_cb, 0, NULL},
+	{N_("/_File/E_xit"),			"<alt>Q", app_exit_cb, 0, NULL},
+
+	{N_("/_Edit"),				NULL, NULL, 0, "<Branch>"},
+	{N_("/_Edit/_Copy"),			"<control>C", copy_cb, 0, NULL},
+	{N_("/_Edit/Select _all"),		"<control>A", allsel_cb, 0, NULL},
+	{N_("/_Edit/---"),			NULL, NULL, 0, "<Separator>"},
+	{N_("/_Edit/_Search"),			"<control>S", summary_search_cb, 0, NULL},
+
+	{N_("/_View"),				NULL, NULL, 0, "<Branch>"},
+	{N_("/_View/_Folder tree"),		NULL, toggle_folder_cb, 0, "<ToggleItem>"},
+	{N_("/_View/_Message view"),		NULL, toggle_message_cb, 0, "<ToggleItem>"},
+	{N_("/_View/_Toolbar"),			NULL, NULL, 0, "<Branch>"},
+	{N_("/_View/_Toolbar/Icon _and text"),	NULL, toggle_toolbar_cb, TOOLBAR_BOTH, "<RadioItem>"},
+	{N_("/_View/_Toolbar/_Icon"),		NULL, toggle_toolbar_cb, TOOLBAR_ICON, "/View/Toolbar/Icon and text"},
+	{N_("/_View/_Toolbar/_Text"),		NULL, toggle_toolbar_cb, TOOLBAR_TEXT, "/View/Toolbar/Icon and text"},
+	{N_("/_View/_Toolbar/_None"),		NULL, toggle_toolbar_cb, TOOLBAR_NONE, "/View/Toolbar/Icon and text"},
+	{N_("/_View/_Status bar"),		NULL, toggle_statusbar_cb, 0, "<ToggleItem>"},
+	{N_("/_View/---"),			NULL, NULL, 0, "<Separator>"},
+	{N_("/_View/Separate f_older tree"),	NULL, separate_widget_cb, SEPARATE_FOLDER, "<ToggleItem>"},
+	{N_("/_View/Separate m_essage view"),	NULL, separate_widget_cb, SEPARATE_MESSAGE, "<ToggleItem>"},
+	{N_("/_View/---"),			NULL, NULL, 0, "<Separator>"},
+	{N_("/_View/View _source"),		"<control>U", view_source_cb, 0, NULL},
+	{N_("/_View/Show all _header"),		"<control>H", header_window_show_cb, 0, NULL},
+	{N_("/_View/---"),			NULL, NULL, 0, "<Separator>"},
+	{N_("/_View/_Code set"),		NULL, NULL, 0, "<Branch>"},
+	{N_("/_View/_Code set/_Auto detect"),
+	 NULL, set_charset_cb, C_AUTO, "<RadioItem>"},
+
+#define CODESET_SEPARATOR \
+	{N_("/_View/_Code set/---"),		NULL, NULL, 0, "<Separator>"}
+#define CODESET_ACTION(action) \
+	 NULL, set_charset_cb, action, "/View/Code set/Auto detect"
+
+	{N_("/_View/_Code set/---"),		NULL, NULL, 0, "<Separator>"},
+	{N_("/_View/_Code set/7bit ascii (US-ASC_II)"),
+	 CODESET_ACTION(C_US_ASCII)},
+
+#if HAVE_LIBJCONV
+	{N_("/_View/_Code set/Unicode (_UTF-8)"),
+	 CODESET_ACTION(C_UTF_8)},
+	CODESET_SEPARATOR,
+#endif
+	{N_("/_View/_Code set/Western European (ISO-8859-_1)"),
+	 CODESET_ACTION(C_ISO_8859_1)},
+	CODESET_SEPARATOR,
+#if HAVE_LIBJCONV
+	{N_("/_View/_Code set/Central European (ISO-8859-_2)"),
+	 CODESET_ACTION(C_ISO_8859_2)},
+	CODESET_SEPARATOR,
+	{N_("/_View/_Code set/_Baltic (ISO-8859-13)"),
+	 CODESET_ACTION(C_ISO_8859_13)},
+	{N_("/_View/_Code set/Baltic (ISO-8859-_4)"),
+	 CODESET_ACTION(C_ISO_8859_4)},
+	CODESET_SEPARATOR,
+	{N_("/_View/_Code set/Greek (ISO-8859-_7)"),
+	 CODESET_ACTION(C_ISO_8859_7)},
+	CODESET_SEPARATOR,
+	{N_("/_View/_Code set/Turkish (ISO-8859-_9)"),
+	 CODESET_ACTION(C_ISO_8859_9)},
+	CODESET_SEPARATOR,
+	{N_("/_View/_Code set/Cyrillic (ISO-8859-_5)"),
+	 CODESET_ACTION(C_ISO_8859_5)},
+	{N_("/_View/_Code set/Cyrillic (KOI8-_R)"),
+	 CODESET_ACTION(C_KOI8_R)},
+	{N_("/_View/_Code set/Cyrillic (Windows-1251)"),
+	 CODESET_ACTION(C_CP1251)},
+	CODESET_SEPARATOR,
+#endif
+	{N_("/_View/_Code set/Japanese (ISO-2022-_JP)"),
+	 CODESET_ACTION(C_ISO_2022_JP)},
+#if HAVE_LIBJCONV
+	{N_("/_View/_Code set/Japanese (ISO-2022-JP-2)"),
+	 CODESET_ACTION(C_ISO_2022_JP_2)},
+#endif
+	{N_("/_View/_Code set/Japanese (_EUC-JP)"),
+	 CODESET_ACTION(C_EUC_JP)},
+	{N_("/_View/_Code set/Japanese (_Shift__JIS)"),
+	 CODESET_ACTION(C_SHIFT_JIS)},
+#if HAVE_LIBJCONV
+	CODESET_SEPARATOR,
+	{N_("/_View/_Code set/Simplified Chinese (_GB2312)"),
+	 CODESET_ACTION(C_GB2312)},
+	{N_("/_View/_Code set/Traditional Chinese (_Big5)"),
+	 CODESET_ACTION(C_BIG5)},
+	{N_("/_View/_Code set/Traditional Chinese (EUC-_TW)"),
+	 CODESET_ACTION(C_EUC_TW)},
+	{N_("/_View/_Code set/Chinese (ISO-2022-_CN)"),
+	 CODESET_ACTION(C_ISO_2022_CN)},
+	CODESET_SEPARATOR,
+	{N_("/_View/_Code set/Korean (EUC-_KR)"),
+	 CODESET_ACTION(C_EUC_KR)},
+	{N_("/_View/_Code set/Korean (ISO-2022-KR)"),
+	 CODESET_ACTION(C_ISO_2022_KR)},
+#endif
+
+#undef CODESET_SEPARATOR
+#undef CODESET_ACTION
+
+	{N_("/_Message"),			NULL, NULL, 0, "<Branch>"},
+	{N_("/_Message/Get new ma_il"),	"<alt>I",	inc_mail_cb, 0, NULL},
+	{N_("/_Message/Get from _all accounts"),
+						"<shift><alt>I", inc_all_account_mail_cb, 0, NULL},
+	{N_("/_Message/---"),			NULL, NULL, 0, "<Separator>"},
+	{N_("/_Message/Send queued messa_ges"),
+						NULL, send_queue_cb, 0, NULL},
+	{N_("/_Message/---"),			NULL, NULL, 0, "<Separator>"},
+	{N_("/_Message/Compose _new message"),	"<alt>N",	compose_cb, 0, NULL},
+	{N_("/_Message/_Reply"),		"<alt>R", 	reply_cb, COMPOSE_REPLY, NULL},
+	{N_("/_Message/Repl_y to sender"),	"<control><alt>R", reply_cb, COMPOSE_REPLY_TO_SENDER, NULL},
+	{N_("/_Message/Reply to a_ll"),		"<shift><alt>R", reply_cb, COMPOSE_REPLY_TO_ALL, NULL},
+	{N_("/_Message/_Forward"),		"<control>F", reply_cb, COMPOSE_FORWARD, NULL},
+	{N_("/_Message/Forward as a_ttachment"),
+						"<shift><control>F", reply_cb, COMPOSE_FORWARD_AS_ATTACH, NULL},
+	{N_("/_Message/---"),			NULL, NULL, 0, "<Separator>"},
+	{N_("/_Message/Re-_edit"),		NULL, reedit_cb, 0, NULL},
+	{N_("/_Message/---"),			NULL, NULL, 0, "<Separator>"},
+	{N_("/_Message/M_ove..."),		"<alt>O", move_to_cb, 0, NULL},
+	{N_("/_Message/_Copy..."),		NULL, copy_to_cb, 0, NULL},
+	{N_("/_Message/_Delete"),		"<alt>D", delete_cb,  0, NULL},
+	{N_("/_Message/---"),			NULL, NULL, 0, "<Separator>"},
+	{N_("/_Message/_Mark"),			NULL, NULL, 0, "<Branch>"},
+	{N_("/_Message/_Mark/_Mark"),		NULL, mark_cb,   0, NULL},
+	{N_("/_Message/_Mark/_Unmark"),		NULL, unmark_cb, 0, NULL},
+	{N_("/_Message/_Mark/---"),		NULL, NULL, 0, "<Separator>"},
+	{N_("/_Message/_Mark/Mark as unr_ead"),	NULL, mark_as_unread_cb, 0, NULL},
+	{N_("/_Message/_Mark/Mark as rea_d"),
+						NULL, mark_as_read_cb, 0, NULL},
+	{N_("/_Message/_Mark/Mark all _read"),	NULL, mark_all_read_cb, 0, NULL},
+	{N_("/_Message/---"),			NULL, NULL, 0, "<Separator>"},
+	{N_("/_Message/Add sender to address boo_k"),
+						NULL, add_address_cb, 0, NULL},
+	{N_("/_Message/---"),			NULL, NULL, 0, "<Separator>"},
+	{N_("/_Message/Open in new _window"),	"<shift><control>N", open_msg_cb, 0, NULL},
+
+	{N_("/_Summary"),			NULL, NULL, 0, "<Branch>"},
+	{N_("/_Summary/_Delete duplicated messages"),
+						NULL, delete_duplicated_cb,   0, NULL},
+	{N_("/_Summary/_Filter messages"),	NULL, filter_cb, 0, NULL},
+	{N_("/_Summary/E_xecute"),		"<alt>X", execute_summary_cb, 0, NULL},
+	{N_("/_Summary/_Update"),		"<alt>U", update_summary_cb,  0, NULL},
+	{N_("/_Summary/---"),			NULL, NULL, 0, "<Separator>"},
+	{N_("/_Summary/Go _to"),		NULL, NULL, 0, "<Branch>"},
+	{N_("/_Summary/Go _to/_Prev message"),	NULL, prev_cb, 0, NULL},
+	{N_("/_Summary/Go _to/_Next message"),	NULL, next_cb, 0, NULL},
+	{N_("/_Summary/Go _to/---"),		NULL, NULL, 0, "<Separator>"},
+	{N_("/_Summary/Go _to/P_rev unread message"),
+						NULL, prev_unread_cb, 0, NULL},
+	{N_("/_Summary/Go _to/N_ext unread message"),
+						NULL, next_unread_cb, 0, NULL},
+	{N_("/_Summary/Go _to/---"),		NULL, NULL, 0, "<Separator>"},
+	{N_("/_Summary/Go _to/Prev _marked message"),
+						NULL, prev_marked_cb, 0, NULL},
+	{N_("/_Summary/Go _to/Next m_arked message"),
+						NULL, next_marked_cb, 0, NULL},
+	{N_("/_Summary/Go _to/---"),		NULL, NULL, 0, "<Separator>"},
+	{N_("/_Summary/Go _to/Prev _labeled message"),
+						NULL, prev_labeled_cb, 0, NULL},
+	{N_("/_Summary/Go _to/Next la_beled message"),
+						NULL, next_labeled_cb, 0, NULL},
+	{N_("/_Summary/_Go to other folder..."),"<alt>G", goto_folder_cb, 0, NULL},
+	{N_("/_Summary/---"),			NULL, NULL, 0, "<Separator>"},
+	{N_("/_Summary/_Sort"),			NULL, NULL, 0, "<Branch>"},
+	{N_("/_Summary/_Sort/Sort by _number"),	NULL, sort_summary_cb, SORT_BY_NUMBER, NULL},
+	{N_("/_Summary/_Sort/Sort by s_ize"),	NULL, sort_summary_cb, SORT_BY_SIZE, NULL},
+	{N_("/_Summary/_Sort/Sort by _date"),	NULL, sort_summary_cb, SORT_BY_DATE, NULL},
+	{N_("/_Summary/_Sort/Sort by _from"),	NULL, sort_summary_cb, SORT_BY_FROM, NULL},
+	{N_("/_Summary/_Sort/Sort by _subject"),NULL, sort_summary_cb, SORT_BY_SUBJECT, NULL},
+	{N_("/_Summary/_Sort/Sort by _color label"),
+						NULL, sort_summary_cb, SORT_BY_LABEL, NULL},
+	{N_("/_Summary/_Sort/Sort by _mark"),	NULL, sort_summary_cb, SORT_BY_MARK, NULL},
+	{N_("/_Summary/_Sort/Sort by _unread"),	NULL, sort_summary_cb, SORT_BY_UNREAD, NULL},
+	{N_("/_Summary/_Sort/Sort by a_ttachment"),
+						NULL, sort_summary_cb, SORT_BY_MIME, NULL},
+	{N_("/_Summary/_Sort/---"),		NULL, NULL, 0, "<Separator>"},
+	{N_("/_Summary/_Sort/_Attract by subject"),
+						NULL, attract_by_subject_cb, 0, NULL},
+	{N_("/_Summary/_Thread view"),		"<control>T",	     thread_cb, 0, NULL},
+	{N_("/_Summary/Unt_hread view"),	"<shift><control>T", thread_cb, 1, NULL},
+	{N_("/_Summary/Set display _item..."),	NULL, set_display_item_cb, 0, NULL},
+
+	{N_("/_Tool"),				NULL, NULL, 0, "<Branch>"},
+	{N_("/_Tool/_Address book"),		"<alt>A", addressbook_open_cb, 0, NULL},
+	{N_("/_Tool/_Log window"),		"<alt>L", log_window_show_cb, 0, NULL},
+
+	{N_("/_Configuration"),			NULL, NULL, 0, "<Branch>"},
+	{N_("/_Configuration/_Common preferences..."),
+						NULL, prefs_common_open_cb, 0, NULL},
+	{N_("/_Configuration/_Filter setting..."),
+						NULL, prefs_filter_open_cb, 0, NULL},
+	{N_("/_Configuration/_Preferences per account..."),
+						NULL, prefs_account_open_cb, 0, NULL},
+	{N_("/_Configuration/---"),		NULL, NULL, 0, "<Separator>"},
+	{N_("/_Configuration/Create _new account..."),
+						NULL, new_account_cb, 0, NULL},
+	{N_("/_Configuration/_Edit accounts..."),
+						NULL, account_edit_open, 0, NULL},
+	{N_("/_Configuration/C_hange current account"),
+						NULL, NULL, 0, "<Branch>"},
+
+	{N_("/_Help"),				NULL, NULL, 0, "<LastBranch>"},
+	{N_("/_Help/_Manual"),			NULL, NULL, 0, "<Branch>"},
+	{N_("/_Help/_Manual/_English"),		NULL, manual_open_cb, MANUAL_LANG_EN, NULL},
+	{N_("/_Help/_Manual/_Japanese"),	NULL, manual_open_cb, MANUAL_LANG_JA, NULL},
+	{N_("/_Help/---"),			NULL, NULL, 0, "<Separator>"},
+	{N_("/_Help/_About"),			NULL, about_show, 0, NULL}
+};
+
+MainWindow *main_window_create(SeparateType type)
+{
+	MainWindow *mainwin;
+	GtkWidget *window;
+	GtkWidget *vbox;
+	GtkWidget *menubar;
+	GtkWidget *handlebox;
+	GtkWidget *vbox_body;
+	GtkWidget *hbox_stat;
+	GtkWidget *statusbar;
+	GtkWidget *progressbar;
+	GtkWidget *statuslabel;
+	GtkWidget *ac_button;
+	GtkWidget *ac_label;
+
+	FolderView *folderview;
+	SummaryView *summaryview;
+	MessageView *messageview;
+	GdkColormap *colormap;
+	GdkColor color[3];
+	gboolean success[3];
+	guint n_menu_entries;
+	GtkItemFactory *ifactory;
+	GtkWidget *ac_menu;
+	GtkWidget *menuitem;
+	gint i;
+
+	debug_print(_("Creating main window...\n"));
+	mainwin = g_new0(MainWindow, 1);
+
+	/* main window */
+	window = gtk_window_new(GTK_WINDOW_TOPLEVEL);
+	gtk_window_set_title(GTK_WINDOW(window), PROG_VERSION);
+	gtk_window_set_policy(GTK_WINDOW(window), TRUE, TRUE, FALSE);
+	gtk_signal_connect(GTK_OBJECT(window), "delete_event",
+			   GTK_SIGNAL_FUNC(main_window_close_cb), mainwin);
+	gtk_signal_connect(GTK_OBJECT(window), "focus_in_event",
+			   GTK_SIGNAL_FUNC(manage_window_focus_in), NULL);
+	gtk_signal_connect(GTK_OBJECT(window), "focus_out_event",
+			   GTK_SIGNAL_FUNC(manage_window_focus_out), NULL);
+	gtk_widget_realize(window);
+
+	vbox = gtk_vbox_new(FALSE, 0);
+	gtk_widget_show(vbox);
+	gtk_container_add(GTK_CONTAINER(window), vbox);
+
+	/* menu bar */
+	n_menu_entries = sizeof(mainwin_entries) / sizeof(mainwin_entries[0]);
+	menubar = menubar_create(window, mainwin_entries, 
+				 n_menu_entries, "<Main>", mainwin);
+	gtk_widget_show(menubar);
+	gtk_box_pack_start(GTK_BOX(vbox), menubar, FALSE, TRUE, 0);
+
+	handlebox = gtk_handle_box_new();
+	gtk_widget_show(handlebox);
+	gtk_box_pack_start(GTK_BOX(vbox), handlebox, FALSE, FALSE, 0);
+
+	main_window_toolbar_create(mainwin, handlebox);
+
+	/* vbox that contains body */
+	vbox_body = gtk_vbox_new(FALSE, BORDER_WIDTH);
+	gtk_widget_show(vbox_body);
+	gtk_container_set_border_width(GTK_CONTAINER(vbox_body), BORDER_WIDTH);
+	gtk_box_pack_start(GTK_BOX(vbox), vbox_body, TRUE, TRUE, 0);
+
+	hbox_stat = gtk_hbox_new(FALSE, 2);
+	gtk_box_pack_end(GTK_BOX(vbox_body), hbox_stat, FALSE, FALSE, 0);
+
+	statusbar = statusbar_create();
+	gtk_box_pack_start(GTK_BOX(hbox_stat), statusbar, TRUE, TRUE, 0);
+
+	progressbar = gtk_progress_bar_new();
+	gtk_widget_set_usize(progressbar, 120, 1);
+	gtk_box_pack_start(GTK_BOX(hbox_stat), progressbar, FALSE, FALSE, 0);
+
+	statuslabel = gtk_label_new("");
+	gtk_box_pack_start(GTK_BOX(hbox_stat), statuslabel, FALSE, FALSE, 0);
+
+	ac_button = gtk_button_new();
+	gtk_button_set_relief(GTK_BUTTON(ac_button), GTK_RELIEF_NONE);
+	GTK_WIDGET_UNSET_FLAGS(ac_button, GTK_CAN_FOCUS);
+	gtk_widget_set_usize(ac_button, -1, 1);
+	gtk_box_pack_end(GTK_BOX(hbox_stat), ac_button, FALSE, FALSE, 0);
+	gtk_signal_connect(GTK_OBJECT(ac_button), "button_press_event",
+			   GTK_SIGNAL_FUNC(ac_label_button_pressed), mainwin);
+
+	ac_label = gtk_label_new("");
+	gtk_container_add(GTK_CONTAINER(ac_button), ac_label);
+
+	gtk_widget_show_all(hbox_stat);
+
+	/* create views */
+	mainwin->folderview  = folderview  = folderview_create();
+	mainwin->summaryview = summaryview = summary_create();
+	mainwin->messageview = messageview = messageview_create();
+	mainwin->headerwin   = header_window_create();
+	mainwin->logwin      = log_window_create();
+
+	folderview->mainwin      = mainwin;
+	folderview->summaryview  = summaryview;
+
+	summaryview->mainwin     = mainwin;
+	summaryview->folderview  = folderview;
+	summaryview->messageview = messageview;
+	summaryview->headerwin   = mainwin->headerwin;
+	summaryview->window      = window;
+
+	messageview->mainwin     = mainwin;
+
+	mainwin->window      = window;
+	mainwin->vbox        = vbox;
+	mainwin->menubar     = menubar;
+	mainwin->handlebox   = handlebox;
+	mainwin->vbox_body   = vbox_body;
+	mainwin->hbox_stat   = hbox_stat;
+	mainwin->statusbar   = statusbar;
+	mainwin->progressbar = progressbar;
+	mainwin->statuslabel = statuslabel;
+	mainwin->ac_button   = ac_button;
+	mainwin->ac_label    = ac_label;
+
+	/* set context IDs for status bar */
+	mainwin->mainwin_cid = gtk_statusbar_get_context_id
+		(GTK_STATUSBAR(statusbar), "Main Window");
+	mainwin->folderview_cid = gtk_statusbar_get_context_id
+		(GTK_STATUSBAR(statusbar), "Folder View");
+	mainwin->summaryview_cid = gtk_statusbar_get_context_id
+		(GTK_STATUSBAR(statusbar), "Summary View");
+
+	/* allocate colors for summary view and folder view */
+	summaryview->color_marked.red = summaryview->color_marked.green = 0;
+	summaryview->color_marked.blue = (guint16)65535;
+
+	summaryview->color_dim.red = summaryview->color_dim.green =
+		summaryview->color_dim.blue = COLOR_DIM;
+
+	folderview->color_new.red = (guint16)55000;
+	folderview->color_new.green = folderview->color_new.blue = 15000;
+
+	color[0] = summaryview->color_marked;
+	color[1] = summaryview->color_dim;
+	color[2] = folderview->color_new;
+
+	colormap = gdk_window_get_colormap(window->window);
+	gdk_colormap_alloc_colors(colormap, color, 3, FALSE, TRUE, success);
+	for (i = 0; i < 3; i++) {
+		if (success[i] == FALSE)
+			g_warning(_("MainWindow: color allocation %d failed\n"), i);
+	}
+
+	debug_print(_("done.\n"));
+
+	main_window_set_widgets(mainwin, type);
+
+	/* set menu items */
+	ifactory = gtk_item_factory_from_widget(menubar);
+	menuitem = gtk_item_factory_get_item
+		(ifactory, "/View/Code set/Auto detect");
+	gtk_check_menu_item_set_active(GTK_CHECK_MENU_ITEM(menuitem), TRUE);
+
+	switch (prefs_common.toolbar_style) {
+	case TOOLBAR_NONE:
+		menuitem = gtk_item_factory_get_item
+			(ifactory, "/View/Toolbar/None");
+		break;
+	case TOOLBAR_ICON:
+		menuitem = gtk_item_factory_get_item
+			(ifactory, "/View/Toolbar/Icon");
+		break;
+	case TOOLBAR_TEXT:
+		menuitem = gtk_item_factory_get_item
+			(ifactory, "/View/Toolbar/Text");
+		break;
+	case TOOLBAR_BOTH:
+		menuitem = gtk_item_factory_get_item
+			(ifactory, "/View/Toolbar/Icon and text");
+	}
+	gtk_check_menu_item_set_active(GTK_CHECK_MENU_ITEM(menuitem), TRUE);
+
+	gtk_widget_hide(mainwin->hbox_stat);
+	menuitem = gtk_item_factory_get_item(ifactory, "/View/Status bar");
+	gtk_check_menu_item_set_active(GTK_CHECK_MENU_ITEM(menuitem),
+				       prefs_common.show_statusbar);
+
+	menu_set_sensitive(ifactory, "/Summary/Thread view",
+			   prefs_common.enable_thread ? FALSE : TRUE);
+	menu_set_sensitive(ifactory, "/Summary/Unthread view",
+			   prefs_common.enable_thread ? TRUE : FALSE);
+
+	/* set account selection menu */
+	ac_menu = gtk_item_factory_get_widget
+		(ifactory, "/Configuration/Change current account");
+	gtk_signal_connect(GTK_OBJECT(ac_menu), "selection_done",
+			   GTK_SIGNAL_FUNC(ac_menu_popup_closed), mainwin);
+	mainwin->ac_menu = ac_menu;
+
+	main_window_set_toolbar_sensitive(mainwin);
+
+	/* show main window */
+	gtk_widget_set_uposition(mainwin->window,
+				 prefs_common.mainwin_x,
+				 prefs_common.mainwin_y);
+	gtk_widget_set_usize(window, prefs_common.mainwin_width,
+			     prefs_common.mainwin_height);
+	gtk_widget_show(mainwin->window);
+
+	/* initialize views */
+	folderview_init(folderview);
+	summary_init(summaryview);
+	messageview_init(messageview);
+	header_window_init(mainwin->headerwin);
+	log_window_init(mainwin->logwin);
+
+	mainwin->lock_count = 0;
+	mainwin->cursor_count = 0;
+
+	if (!watch_cursor)
+		watch_cursor = gdk_cursor_new(GDK_WATCH);
+
+	mainwin_list = g_list_append(mainwin_list, mainwin);
+
+	return mainwin;
+}
+
+void main_window_cursor_wait(MainWindow *mainwin)
+{
+
+	if (mainwin->cursor_count == 0)
+		gdk_window_set_cursor(mainwin->window->window, watch_cursor);
+
+	mainwin->cursor_count++;
+
+	gdk_flush();
+}
+
+void main_window_cursor_normal(MainWindow *mainwin)
+{
+	if (mainwin->cursor_count)
+		mainwin->cursor_count--;
+
+	if (mainwin->cursor_count == 0)
+		gdk_window_set_cursor(mainwin->window->window, NULL);
+
+	gdk_flush();
+}
+
+/* lock / unlock the user-interface */
+void main_window_lock(MainWindow *mainwin)
+{
+	if (mainwin->lock_count == 0)
+		gtk_widget_set_sensitive(mainwin->ac_button, FALSE);
+
+	mainwin->lock_count++;
+
+	main_window_set_menu_sensitive(mainwin);
+	main_window_set_toolbar_sensitive(mainwin);
+}
+
+void main_window_unlock(MainWindow *mainwin)
+{
+	if (mainwin->lock_count)
+		mainwin->lock_count--;
+
+	main_window_set_menu_sensitive(mainwin);
+	main_window_set_toolbar_sensitive(mainwin);
+
+	if (mainwin->lock_count == 0)
+		gtk_widget_set_sensitive(mainwin->ac_button, TRUE);
+}
+
+void main_window_reflect_prefs_all(void)
+{
+	GList *cur;
+	MainWindow *mainwin;
+
+	for (cur = mainwin_list; cur != NULL; cur = cur->next) {
+		mainwin = (MainWindow *)cur->data;
+
+		main_window_show_cur_account(mainwin);
+		main_window_set_menu_sensitive(mainwin);
+		main_window_set_toolbar_sensitive(mainwin);
+
+		if (prefs_common.immediate_exec)
+			gtk_widget_hide(mainwin->exec_btn);
+		else
+			gtk_widget_show(mainwin->exec_btn);
+
+		summary_change_display_item(mainwin->summaryview);
+		summary_redisplay_msg(mainwin->summaryview);
+		headerview_set_visibility(mainwin->messageview->headerview,
+					  prefs_common.display_header_pane);
+	}
+}
+
+void main_window_set_account_menu(GList *account_list)
+{
+	GList *cur, *cur_ac, *cur_item;
+	GtkWidget *menuitem;
+	MainWindow *mainwin;
+	PrefsAccount *ac_prefs;
+
+	for (cur = mainwin_list; cur != NULL; cur = cur->next) {
+		mainwin = (MainWindow *)cur->data;
+
+		/* destroy all previous menu item */
+		cur_item = GTK_MENU_SHELL(mainwin->ac_menu)->children;
+		while (cur_item != NULL) {
+			GList *next = cur_item->next;
+			gtk_widget_destroy(GTK_WIDGET(cur_item->data));
+			cur_item = next;
+		}
+
+		for (cur_ac = account_list; cur_ac != NULL;
+		     cur_ac = cur_ac->next) {
+			ac_prefs = (PrefsAccount *)cur_ac->data;
+
+			menuitem = gtk_menu_item_new_with_label
+				(ac_prefs->account_name
+				 ? ac_prefs->account_name : _("Untitled"));
+			gtk_widget_show(menuitem);
+			gtk_menu_append(GTK_MENU(mainwin->ac_menu), menuitem);
+			gtk_signal_connect(GTK_OBJECT(menuitem), "activate",
+					   GTK_SIGNAL_FUNC(account_menu_cb),
+					   ac_prefs);
+		}
+	}
+}
+
+static void main_window_show_cur_account(MainWindow *mainwin)
+{
+	gchar *buf;
+	gchar *ac_name;
+
+	ac_name = g_strdup(cur_account
+			   ? (cur_account->account_name
+			      ? cur_account->account_name : _("Untitled"))
+			   : _("none"));
+
+	if (cur_account)
+		buf = g_strdup_printf("%s - %s", ac_name, PROG_VERSION);
+	else
+		buf = g_strdup(PROG_VERSION);
+	gtk_window_set_title(GTK_WINDOW(mainwin->window), buf);
+	g_free(buf);
+
+	//buf = g_strdup_printf(_("Current account: %s"), ac_name);
+	//gtk_label_set_text(GTK_LABEL(mainwin->ac_label), buf);
+	gtk_label_set_text(GTK_LABEL(mainwin->ac_label), ac_name);
+	gtk_widget_queue_resize(mainwin->ac_button);
+	//g_free(buf);
+
+	g_free(ac_name);
+}
+
+void main_window_separation_change(MainWindow *mainwin, SeparateType type)
+{
+	GtkWidget *folder_wid  = GTK_WIDGET_PTR(mainwin->folderview);
+	GtkWidget *summary_wid = GTK_WIDGET_PTR(mainwin->summaryview);
+	GtkWidget *message_wid = GTK_WIDGET_PTR(mainwin->messageview);
+
+	if (mainwin->type == type) return;
+
+	/* remove widgets from those containers */
+	gtk_widget_ref(folder_wid);
+	gtk_widget_ref(summary_wid);
+	gtk_widget_ref(message_wid);
+	gtk_container_remove
+		(GTK_CONTAINER(folder_wid->parent), folder_wid);
+	gtk_container_remove
+		(GTK_CONTAINER(summary_wid->parent), summary_wid);
+	gtk_container_remove
+		(GTK_CONTAINER(message_wid->parent), message_wid);
+
+	/* clean containers */
+	switch (mainwin->type) {
+	case SEPARATE_NONE:
+		gtk_widget_destroy(mainwin->win.sep_none.hpaned);
+		break;
+	case SEPARATE_FOLDER:
+		gtk_widget_destroy(mainwin->win.sep_folder.vpaned);
+		gtk_widget_destroy(mainwin->win.sep_folder.folderwin);
+		break;
+	case SEPARATE_MESSAGE:
+		gtk_widget_destroy(mainwin->win.sep_message.hpaned);
+		gtk_widget_destroy(mainwin->win.sep_message.messagewin);
+		break;
+	case SEPARATE_BOTH:
+		gtk_widget_destroy(mainwin->win.sep_both.messagewin);
+		gtk_widget_destroy(mainwin->win.sep_both.folderwin);
+		break;
+	}
+
+	gtk_widget_hide(mainwin->window);
+	main_window_set_widgets(mainwin, type);
+	gtk_widget_show(mainwin->window);
+
+	gtk_widget_unref(folder_wid);
+	gtk_widget_unref(summary_wid);
+	gtk_widget_unref(message_wid);
+}
+
+void main_window_get_size(MainWindow *mainwin)
+{
+	GtkAllocation *allocation;
+
+	allocation = &(GTK_WIDGET_PTR(mainwin->summaryview)->allocation);
+
+	prefs_common.summaryview_width  = allocation->width;
+
+	if (mainwin->summaryview->msg_is_toggled_on)
+		prefs_common.summaryview_height = allocation->height;
+
+	prefs_common.mainview_width     = allocation->width;
+
+	allocation = &mainwin->window->allocation;
+
+	prefs_common.mainview_height = allocation->height;
+	prefs_common.mainwin_width   = allocation->width;
+	prefs_common.mainwin_height  = allocation->height;
+
+	allocation = &(GTK_WIDGET_PTR(mainwin->folderview)->allocation);
+
+	prefs_common.folderview_width  = allocation->width;
+	prefs_common.folderview_height = allocation->height;
+}
+
+void main_window_get_position(MainWindow *mainwin)
+{
+	gint x, y;
+
+	gtkut_widget_get_uposition(mainwin->window, &x, &y);
+
+	prefs_common.mainview_x = x;
+	prefs_common.mainview_y = y;
+	prefs_common.mainwin_x = x;
+	prefs_common.mainwin_y = y;
+
+	debug_print(_("window position: x = %d, y = %d\n"), x, y);
+}
+
+void main_window_empty_trash(MainWindow *mainwin, gboolean confirm)
+{
+	GList *list;
+
+	if (confirm) {
+		if (alertpanel(_("Empty trash"),
+			       _("Empty all messages in trash?"),
+			       _("Yes"), _("No"), NULL) != G_ALERTDEFAULT)
+			return;
+		manage_window_focus_in(mainwin->window, NULL, NULL);
+	}
+
+	procmsg_empty_trash();
+
+	for (list = folder_get_list(); list != NULL; list = list->next) {
+		Folder *folder;
+
+		folder = list->data;
+		if (folder->trash) {
+			folder_item_scan(folder->trash);
+			folderview_update_item(folder->trash, TRUE);
+		}
+	}
+
+	if (mainwin->summaryview->folder_item &&
+	    mainwin->summaryview->folder_item->stype == F_TRASH)
+		gtk_widget_grab_focus(mainwin->folderview->ctree);
+}
+
+void main_window_add_mailbox(MainWindow *mainwin)
+{
+	gchar *path;
+	Folder *folder;
+
+	path = input_dialog(_("Add mailbox"),
+			    _("Input the location of mailbox.\n"
+			      "If the existing mailbox is specified, it will be\n"
+			      "scanned automatically."),
+			    "Mail");
+	if (!path) return;
+	if (folder_find_from_path(path)) {
+		alertpanel_error(_("The mailbox `%s' already exists."), path);
+		g_free(path);
+		return;
+	}
+	if (!strcmp(path, "Mail"))
+		folder = folder_new(F_MH, _("Mailbox"), path);
+	else
+		folder = folder_new(F_MH, g_basename(path), path);
+	g_free(path);
+
+	if (folder->create_tree(folder) < 0) {
+		alertpanel_error(_("Creation of the mailbox failed.\n"
+				   "Maybe some files already exist, or you don't have the permission to write there."));
+		folder_destroy(folder);
+		return;
+	}
+
+	folder_add(folder);
+	folder_set_ui_func(folder, scan_tree_func, mainwin);
+	folder->scan_tree(folder);
+	folder_set_ui_func(folder, NULL, NULL);
+
+	folderview_set(mainwin->folderview);
+}
+
+typedef enum
+{
+	M_UNLOCKED            = 1 << 0,
+	M_MSG_EXIST           = 1 << 1,
+	M_TARGET_EXIST        = 1 << 2,
+	M_SINGLE_TARGET_EXIST = 1 << 3,
+	M_EXEC                = 1 << 4,
+	M_ALLOW_REEDIT        = 1 << 5,
+	M_HAVE_ACCOUNT        = 1 << 6
+} SensitiveCond;
+
+static SensitiveCond main_window_get_current_state(MainWindow *mainwin)
+{
+	SensitiveCond state = 0;
+	SummarySelection selection;
+
+	selection = summary_get_selection_type(mainwin->summaryview);
+
+	if (mainwin->lock_count == 0)
+		state |= M_UNLOCKED;
+	if (selection != SUMMARY_NONE)
+		state |= M_MSG_EXIST;
+	if (selection == SUMMARY_SELECTED_SINGLE ||
+	    selection == SUMMARY_SELECTED_MULTIPLE)
+		state |= M_TARGET_EXIST;
+	if (selection == SUMMARY_SELECTED_SINGLE)
+		state |= M_SINGLE_TARGET_EXIST;
+	if (mainwin->summaryview->folder_item &&
+	    mainwin->summaryview->folder_item->folder->type != F_NEWS)
+		state |= M_EXEC;
+	if (selection == SUMMARY_SELECTED_SINGLE &&
+	    (mainwin->summaryview->folder_item &&
+	     (mainwin->summaryview->folder_item->stype == F_DRAFT ||
+	      mainwin->summaryview->folder_item->stype == F_QUEUE)))
+		state |= M_ALLOW_REEDIT;
+	if (cur_account)
+		state |= M_HAVE_ACCOUNT;
+
+	return state;
+}
+
+void main_window_set_toolbar_sensitive(MainWindow *mainwin)
+{
+	SensitiveCond state;
+	gboolean sensitive;
+	gint i;
+
+	const struct {
+		GtkWidget *widget;
+		SensitiveCond cond;
+	} entry[] = {
+		{mainwin->get_btn     , M_HAVE_ACCOUNT|M_UNLOCKED},
+		{mainwin->getall_btn  , M_HAVE_ACCOUNT|M_UNLOCKED},
+		{mainwin->compose_btn , M_HAVE_ACCOUNT},
+		{mainwin->reply_btn   , M_HAVE_ACCOUNT|M_SINGLE_TARGET_EXIST},
+		{mainwin->replyall_btn, M_HAVE_ACCOUNT|M_SINGLE_TARGET_EXIST},
+		{mainwin->fwd_btn     , M_HAVE_ACCOUNT|M_SINGLE_TARGET_EXIST},
+		{mainwin->prefs_btn   , M_UNLOCKED},
+		{mainwin->account_btn , M_UNLOCKED},
+		{mainwin->next_btn    , M_MSG_EXIST},
+		{mainwin->delete_btn  , M_TARGET_EXIST|M_EXEC|M_UNLOCKED},
+		{mainwin->exec_btn    , M_MSG_EXIST|M_EXEC|M_UNLOCKED},
+		{NULL, 0}
+	};
+
+	state = main_window_get_current_state(mainwin);
+
+	for (i = 0; entry[i].widget != NULL; i++) {
+		sensitive = ((entry[i].cond & state) == entry[i].cond);
+		gtk_widget_set_sensitive(entry[i].widget, sensitive);
+	}
+}
+
+void main_window_set_menu_sensitive(MainWindow *mainwin)
+{
+	GtkItemFactory *ifactory;
+	SensitiveCond state;
+	gboolean sensitive;
+	gint i;
+
+	static const struct {
+		gchar *const entry;
+		SensitiveCond cond;
+	} entry[] = {
+		{"/File/Add mailbox..."        , M_UNLOCKED},
+		{"/File/Update folder tree"    , M_UNLOCKED},
+		{"/File/Folder"                , M_UNLOCKED},
+		{"/File/Import mbox file..."   , M_UNLOCKED},
+		{"/File/Export to mbox file...", M_UNLOCKED},
+		{"/File/Empty trash"           , M_UNLOCKED},
+		{"/File/Save as...", M_SINGLE_TARGET_EXIST|M_UNLOCKED},
+		{"/File/Print..."  , M_TARGET_EXIST|M_UNLOCKED},
+		{"/File/Close", M_UNLOCKED},
+		{"/File/Exit" , M_UNLOCKED},
+
+		{"/View/Show all header"      , M_SINGLE_TARGET_EXIST},
+		{"/View/View source"          , M_SINGLE_TARGET_EXIST},
+
+		{"/Message/Get new mail"         , M_HAVE_ACCOUNT|M_UNLOCKED},
+		{"/Message/Get from all accounts", M_HAVE_ACCOUNT|M_UNLOCKED},
+		{"/Message/Compose new message"  , M_HAVE_ACCOUNT},
+		{"/Message/Reply"                , M_HAVE_ACCOUNT|M_SINGLE_TARGET_EXIST},
+		{"/Message/Reply to sender"      , M_HAVE_ACCOUNT|M_SINGLE_TARGET_EXIST},
+		{"/Message/Reply to all"         , M_HAVE_ACCOUNT|M_SINGLE_TARGET_EXIST},
+		{"/Message/Forward"              , M_HAVE_ACCOUNT|M_SINGLE_TARGET_EXIST},
+		{"/Message/Forward as attachment", M_HAVE_ACCOUNT|M_SINGLE_TARGET_EXIST},
+		{"/Message/Open in new window"   , M_SINGLE_TARGET_EXIST},
+		{"/Message/Re-edit", M_HAVE_ACCOUNT|M_ALLOW_REEDIT},
+		{"/Message/Move...", M_TARGET_EXIST|M_EXEC|M_UNLOCKED},
+		{"/Message/Copy...", M_TARGET_EXIST|M_EXEC|M_UNLOCKED},
+		{"/Message/Delete" , M_TARGET_EXIST|M_EXEC|M_UNLOCKED},
+		{"/Message/Mark"   , M_TARGET_EXIST},
+		{"/Message/Add sender to address book", M_SINGLE_TARGET_EXIST},
+
+		{"/Summary/Delete duplicated messages", M_MSG_EXIST|M_EXEC|M_UNLOCKED},
+		{"/Summary/Filter messages"           , M_MSG_EXIST|M_EXEC|M_UNLOCKED},
+		{"/Summary/Execute"                   , M_MSG_EXIST|M_EXEC|M_UNLOCKED},
+		{"/Summary/Go to"                     , M_MSG_EXIST},
+		{"/Summary/Go to/Prev message"        , M_MSG_EXIST},
+		{"/Summary/Go to/Next message"        , M_MSG_EXIST},
+		{"/Summary/Go to/Next unread message" , M_MSG_EXIST},
+		{"/Summary/Go to/Prev marked message" , M_MSG_EXIST},
+		{"/Summary/Go to/Next marked message" , M_MSG_EXIST},
+		{"/Summary/Go to/Prev labeled message", M_MSG_EXIST},
+		{"/Summary/Go to/Next labeled message", M_MSG_EXIST},
+		{"/Summary/Sort"                      , M_MSG_EXIST},
+
+		{"/Configuration", M_UNLOCKED},
+
+		{NULL, 0}
+	};
+
+	ifactory = gtk_item_factory_from_widget(mainwin->menubar);
+	state = main_window_get_current_state(mainwin);
+
+	for (i = 0; entry[i].entry != NULL; i++) {
+		sensitive = ((entry[i].cond & state) == entry[i].cond);
+		menu_set_sensitive(ifactory, entry[i].entry, sensitive);
+	}
+}
+
+void main_window_popup(MainWindow *mainwin)
+{
+	gint x, y;
+	gint sx, sy;
+	GtkWidget *widget;
+
+	gdk_window_get_origin(mainwin->window->window, &x, &y);
+	sx = gdk_screen_width();
+	sy = gdk_screen_height();
+	x %= sx; if (x < 0) x += sx;
+	y %= sy; if (y < 0) y += sy;
+	gdk_window_move(mainwin->window->window, x, y);
+	gdk_window_raise(mainwin->window->window);
+	gdk_window_show(mainwin->window->window);
+
+	debug_print("window position: x = %d, y = %d\n", x, y);
+
+	switch (mainwin->type) {
+	case SEPARATE_FOLDER:
+		widget = mainwin->win.sep_folder.folderwin;
+		gdk_window_get_origin(widget->window, &x, &y);
+		x %= sx; if (x < 0) x += sx;
+		y %= sy; if (y < 0) y += sy;
+		gdk_window_move(widget->window, x, y);
+		gdk_window_raise(widget->window);
+		break;
+	case SEPARATE_MESSAGE:
+		widget = mainwin->win.sep_message.messagewin;
+		gdk_window_get_origin(widget->window, &x, &y);
+		x %= sx; if (x < 0) x += sx;
+		y %= sy; if (y < 0) y += sy;
+		gdk_window_move(widget->window, x, y);
+		gdk_window_raise(widget->window);
+		break;
+	case SEPARATE_BOTH:
+		widget = mainwin->win.sep_both.folderwin;
+		gdk_window_get_origin(widget->window, &x, &y);
+		x %= sx; if (x < 0) x += sx;
+		y %= sy; if (y < 0) y += sy;
+		gdk_window_move(widget->window, x, y);
+		gdk_window_raise(widget->window);
+		widget = mainwin->win.sep_both.messagewin;
+		gdk_window_get_origin(widget->window, &x, &y);
+		x %= sx; if (x < 0) x += sx;
+		y %= sy; if (y < 0) y += sy;
+		gdk_window_move(widget->window, x, y);
+		gdk_window_raise(widget->window);
+		break;
+	default:
+	}
+}
+
+static void main_window_set_widgets(MainWindow *mainwin, SeparateType type)
+{
+	GtkWidget *folderwin = NULL;
+	GtkWidget *messagewin = NULL;
+	GtkWidget *hpaned;
+	GtkWidget *vpaned;
+	GtkWidget *vbox_body = mainwin->vbox_body;
+
+	debug_print(_("Setting widgets..."));
+
+	/* create separated window(s) if needed */
+	if (type & SEPARATE_FOLDER) {
+		folderwin = gtk_window_new(GTK_WINDOW_TOPLEVEL);
+		gtk_window_set_policy(GTK_WINDOW(folderwin),
+				      TRUE, TRUE, FALSE);
+		gtk_widget_set_usize(folderwin, -1,
+				     prefs_common.mainview_height);
+		gtk_container_set_border_width(GTK_CONTAINER(folderwin),
+					       BORDER_WIDTH);
+		gtk_signal_connect(GTK_OBJECT(folderwin), "delete_event",
+				   GTK_SIGNAL_FUNC(gtk_widget_hide_on_delete),
+				   NULL);
+	}
+	if (type & SEPARATE_MESSAGE) {
+		messagewin = gtk_window_new(GTK_WINDOW_TOPLEVEL);
+		gtk_window_set_policy(GTK_WINDOW(messagewin),
+				      TRUE, TRUE, FALSE);
+		gtk_widget_set_usize
+			(messagewin, prefs_common.mainview_width,
+			 prefs_common.mainview_height
+			 - prefs_common.summaryview_height
+			 + DEFAULT_HEADERVIEW_HEIGHT);
+		gtk_container_set_border_width(GTK_CONTAINER(messagewin),
+					       BORDER_WIDTH);
+		gtk_signal_connect(GTK_OBJECT(messagewin), "delete_event",
+				   GTK_SIGNAL_FUNC(gtk_widget_hide_on_delete),
+				   NULL);
+	}
+
+	switch (type) {
+	case SEPARATE_NONE:
+		hpaned = gtk_hpaned_new();
+		gtk_widget_show(hpaned);
+		gtk_box_pack_start(GTK_BOX(vbox_body), hpaned, TRUE, TRUE, 0);
+		gtk_paned_add1(GTK_PANED(hpaned),
+			       GTK_WIDGET_PTR(mainwin->folderview));
+
+		vpaned = gtk_vpaned_new();
+		if (mainwin->summaryview->msg_is_toggled_on) {
+			gtk_paned_add2(GTK_PANED(hpaned), vpaned);
+			gtk_paned_add1(GTK_PANED(vpaned),
+				       GTK_WIDGET_PTR(mainwin->summaryview));
+		} else {
+			gtk_paned_add2(GTK_PANED(hpaned),
+				       GTK_WIDGET_PTR(mainwin->summaryview));
+			gtk_widget_ref(vpaned);
+		}
+		gtk_widget_set_usize(GTK_WIDGET_PTR(mainwin->summaryview),
+				     prefs_common.summaryview_width,
+				     prefs_common.summaryview_height);
+		gtk_paned_add2(GTK_PANED(vpaned),
+			       GTK_WIDGET_PTR(mainwin->messageview));
+		gtk_widget_set_usize(GTK_WIDGET_PTR(mainwin->messageview),
+				     prefs_common.mainview_width, -1);
+		gtk_widget_set_usize(mainwin->window,
+				     prefs_common.folderview_width +
+				     prefs_common.mainview_width,
+				     prefs_common.mainwin_height);
+		gtk_widget_show_all(vpaned);
+
+		mainwin->win.sep_none.hpaned = hpaned;
+		mainwin->win.sep_none.vpaned = vpaned;
+		break;
+	case SEPARATE_FOLDER:
+		vpaned = gtk_vpaned_new();
+		if (mainwin->summaryview->msg_is_toggled_on) {
+			gtk_box_pack_start(GTK_BOX(vbox_body), vpaned,
+					   TRUE, TRUE, 0);
+			gtk_paned_add1(GTK_PANED(vpaned),
+				       GTK_WIDGET_PTR(mainwin->summaryview));
+		} else {
+			gtk_box_pack_start(GTK_BOX(vbox_body),
+					   GTK_WIDGET_PTR(mainwin->summaryview),
+					   TRUE, TRUE, 0);
+			gtk_widget_ref(vpaned);
+		}
+		gtk_paned_add2(GTK_PANED(vpaned),
+			       GTK_WIDGET_PTR(mainwin->messageview));
+		gtk_widget_show_all(vpaned);
+		gtk_widget_set_usize(GTK_WIDGET_PTR(mainwin->summaryview),
+				     prefs_common.summaryview_width,
+				     prefs_common.summaryview_height);
+		gtk_widget_set_usize(GTK_WIDGET_PTR(mainwin->messageview),
+				     prefs_common.mainview_width, -1);
+		gtk_widget_set_usize(mainwin->window,
+				     prefs_common.mainview_width,
+				     prefs_common.mainview_height);
+
+		gtk_container_add(GTK_CONTAINER(folderwin),
+				  GTK_WIDGET_PTR(mainwin->folderview));
+
+		mainwin->win.sep_folder.folderwin = folderwin;
+		mainwin->win.sep_folder.vpaned    = vpaned;
+
+		gtk_widget_show_all(folderwin);
+		break;
+	case SEPARATE_MESSAGE:
+		hpaned = gtk_hpaned_new();
+		gtk_box_pack_start(GTK_BOX(vbox_body), hpaned, TRUE, TRUE, 0);
+
+		gtk_paned_add1(GTK_PANED(hpaned),
+			       GTK_WIDGET_PTR(mainwin->folderview));
+		gtk_paned_add2(GTK_PANED(hpaned),
+			       GTK_WIDGET_PTR(mainwin->summaryview));
+		gtk_widget_set_usize(GTK_WIDGET_PTR(mainwin->summaryview),
+				     prefs_common.summaryview_width,
+				     prefs_common.summaryview_height);
+		gtk_widget_set_usize(mainwin->window,
+				     prefs_common.folderview_width +
+				     prefs_common.mainview_width,
+				     prefs_common.mainwin_height);
+		gtk_widget_show_all(hpaned);
+		gtk_container_add(GTK_CONTAINER(messagewin),
+				  GTK_WIDGET_PTR(mainwin->messageview));
+
+		mainwin->win.sep_message.messagewin = messagewin;
+		mainwin->win.sep_message.hpaned     = hpaned;
+
+		gtk_widget_show_all(messagewin);
+		break;
+	case SEPARATE_BOTH:
+		gtk_box_pack_start(GTK_BOX(vbox_body),
+				   GTK_WIDGET_PTR(mainwin->summaryview),
+				   TRUE, TRUE, 0);
+		gtk_widget_set_usize(GTK_WIDGET_PTR(mainwin->summaryview),
+				     prefs_common.summaryview_width,
+				     prefs_common.summaryview_height);
+		gtk_widget_set_usize(mainwin->window,
+				     prefs_common.mainview_width,
+				     prefs_common.mainwin_height);
+		gtk_container_add(GTK_CONTAINER(folderwin),
+				  GTK_WIDGET_PTR(mainwin->folderview));
+		gtk_container_add(GTK_CONTAINER(messagewin),
+				  GTK_WIDGET_PTR(mainwin->messageview));
+
+		mainwin->win.sep_both.folderwin = folderwin;
+		mainwin->win.sep_both.messagewin = messagewin;
+
+		gtk_widget_show_all(folderwin);
+		gtk_widget_show_all(messagewin);
+		break;
+	}
+
+	mainwin->type = type;
+
+	debug_print(_("done.\n"));
+}
+
+#include "pixmaps/stock_mail_receive.xpm"
+#include "pixmaps/stock_mail_receive_all.xpm"
+#include "pixmaps/stock_mail_compose.xpm"
+#include "pixmaps/stock_mail_reply.xpm"
+#include "pixmaps/stock_mail_reply_to_all.xpm"
+#include "pixmaps/stock_mail_forward.xpm"
+#include "pixmaps/stock_mail_send.xpm"
+#include "pixmaps/stock_preferences.xpm"
+#include "pixmaps/stock_properties.xpm"
+#include "pixmaps/stock_down_arrow.xpm"
+#include "pixmaps/stock_close.xpm"
+#include "pixmaps/stock_exec.xpm"
+
+#define CREATE_TOOLBAR_ICON(xpm_d) \
+{ \
+	icon = gdk_pixmap_create_from_xpm_d(container->window, &mask, \
+					    &container->style->white, \
+					    xpm_d); \
+	icon_wid = gtk_pixmap_new(icon, mask); \
+}
+
+static void main_window_toolbar_create(MainWindow *mainwin,
+				       GtkWidget *container)
+{
+	GtkWidget *toolbar;
+	GdkPixmap *icon;
+	GdkBitmap *mask;
+	GtkWidget *icon_wid;
+	GtkWidget *get_btn;
+	GtkWidget *getall_btn;
+	GtkWidget *compose_btn;
+	GtkWidget *reply_btn;
+	GtkWidget *replyall_btn;
+	GtkWidget *fwd_btn;
+	GtkWidget *send_btn;
+	GtkWidget *prefs_btn;
+	GtkWidget *account_btn;
+	GtkWidget *next_btn;
+	GtkWidget *delete_btn;
+	GtkWidget *exec_btn;
+
+	toolbar = gtk_toolbar_new(GTK_ORIENTATION_HORIZONTAL,
+				  GTK_TOOLBAR_BOTH);
+	gtk_container_add(GTK_CONTAINER(container), toolbar);
+	gtk_container_set_border_width(GTK_CONTAINER(container), 2);
+	gtk_toolbar_set_button_relief(GTK_TOOLBAR(toolbar), GTK_RELIEF_NONE);
+	gtk_toolbar_set_space_style(GTK_TOOLBAR(toolbar),
+				    GTK_TOOLBAR_SPACE_LINE);
+
+	CREATE_TOOLBAR_ICON(stock_mail_receive_xpm);
+	get_btn = gtk_toolbar_append_item(GTK_TOOLBAR(toolbar),
+					  _("Get"),
+					  _("Incorporate new mail"),
+					  "Get",
+					  icon_wid, toolbar_inc_cb, mainwin);
+	CREATE_TOOLBAR_ICON(stock_mail_receive_all_xpm);
+	getall_btn = gtk_toolbar_append_item(GTK_TOOLBAR(toolbar),
+					     _("Get all"),
+					     _("Incorporate new mail of all accounts"),
+					     "Get all",
+					     icon_wid,
+					     toolbar_inc_all_cb,
+					     mainwin);
+
+	gtk_toolbar_append_space(GTK_TOOLBAR(toolbar));
+
+	CREATE_TOOLBAR_ICON(stock_mail_send_xpm);
+	send_btn = gtk_toolbar_append_item(GTK_TOOLBAR(toolbar),
+					   _("Send"),
+					   _("Send queued message(s)"),
+					   "Send",
+					   icon_wid,
+					   toolbar_send_cb,
+					   mainwin);
+
+	gtk_toolbar_append_space(GTK_TOOLBAR(toolbar));
+
+	CREATE_TOOLBAR_ICON(stock_mail_compose_xpm);
+	compose_btn = gtk_toolbar_append_item(GTK_TOOLBAR(toolbar),
+					      _("Compose"),
+					      _("Compose new message"),
+					      "New",
+					      icon_wid,
+					      toolbar_compose_cb,
+					      mainwin);
+	CREATE_TOOLBAR_ICON(stock_mail_reply_xpm);
+	reply_btn = gtk_toolbar_append_item(GTK_TOOLBAR(toolbar),
+					    _("Reply"),
+					    _("Reply to the message"),
+					    "Reply",
+					    icon_wid,
+					    toolbar_reply_cb,
+					    mainwin);
+	CREATE_TOOLBAR_ICON(stock_mail_reply_to_all_xpm);
+	replyall_btn = gtk_toolbar_append_item(GTK_TOOLBAR(toolbar),
+					       _("Reply all"),
+					       _("Reply to all"),
+					       "Reply to all",
+					       icon_wid,
+					       toolbar_reply_to_all_cb,
+					       mainwin);
+	CREATE_TOOLBAR_ICON(stock_mail_forward_xpm);
+	fwd_btn = gtk_toolbar_append_item(GTK_TOOLBAR(toolbar),
+					  _("Forward"),
+					  _("Forward the message"),
+					  "Fwd",
+					  icon_wid,
+					  toolbar_forward_cb,
+					  mainwin);
+
+	gtk_toolbar_append_space(GTK_TOOLBAR(toolbar));
+
+	CREATE_TOOLBAR_ICON(stock_close_xpm);
+	delete_btn = gtk_toolbar_append_item(GTK_TOOLBAR(toolbar),
+					  _("Delete"),
+					  _("Delete the message"),
+					  "Delete",
+					  icon_wid,
+					  toolbar_delete_cb,
+					  mainwin);
+
+	CREATE_TOOLBAR_ICON(stock_exec_xpm);
+	exec_btn = gtk_toolbar_append_item(GTK_TOOLBAR(toolbar),
+					   _("Execute"),
+					   _("Execute marked process"),
+					   "Execute",
+					   icon_wid,
+					   toolbar_exec_cb,
+					   mainwin);
+
+	CREATE_TOOLBAR_ICON(stock_down_arrow_xpm);
+	next_btn = gtk_toolbar_append_item(GTK_TOOLBAR(toolbar),
+					   _("Next"),
+					   _("Next unread message"),
+					   "Next unread",
+					   icon_wid,
+					   toolbar_next_unread_cb,
+					   mainwin);
+
+	gtk_toolbar_append_space(GTK_TOOLBAR(toolbar));
+
+	CREATE_TOOLBAR_ICON(stock_preferences_xpm);
+	prefs_btn = gtk_toolbar_append_item(GTK_TOOLBAR(toolbar),
+					    _("Prefs"),
+					    _("Common preference"),
+					    "Prefs",
+					    icon_wid,
+					    toolbar_prefs_cb,
+					    mainwin);
+	CREATE_TOOLBAR_ICON(stock_properties_xpm);
+	account_btn = gtk_toolbar_append_item(GTK_TOOLBAR(toolbar),
+					      _("Account"),
+					      _("Account setting"),
+					      "Account",
+					      icon_wid,
+					      toolbar_account_cb,
+					      mainwin);
+	gtk_signal_connect(GTK_OBJECT(account_btn), "button_press_event",
+			   GTK_SIGNAL_FUNC(toolbar_account_button_pressed),
+			   mainwin);
+
+	mainwin->toolbar      = toolbar;
+	mainwin->get_btn      = get_btn;
+	mainwin->getall_btn   = getall_btn;
+	mainwin->compose_btn  = compose_btn;
+	mainwin->reply_btn    = reply_btn;
+	mainwin->replyall_btn = replyall_btn;
+	mainwin->fwd_btn      = fwd_btn;
+	mainwin->send_btn     = send_btn;
+	mainwin->prefs_btn    = prefs_btn;
+	mainwin->account_btn  = account_btn;
+	mainwin->next_btn     = next_btn;
+	mainwin->delete_btn   = delete_btn;
+	mainwin->exec_btn     = exec_btn;
+
+	gtk_widget_show_all(toolbar);
+}
+
+/* callback functions */
+
+static void toolbar_inc_cb	(GtkWidget	*widget,
+				 gpointer	 data)
+{
+	MainWindow *mainwin = (MainWindow *)data;
+
+	inc_mail_cb(mainwin, 0, NULL);
+}
+
+static void toolbar_inc_all_cb	(GtkWidget	*widget,
+				 gpointer	 data)
+{
+	MainWindow *mainwin = (MainWindow *)data;
+
+	inc_all_account_mail_cb(mainwin, 0, NULL);
+}
+
+static void toolbar_send_cb	(GtkWidget	*widget,
+				 gpointer	 data)
+{
+	MainWindow *mainwin = (MainWindow *)data;
+
+	send_queue_cb(mainwin, 0, NULL);
+}
+
+static void toolbar_compose_cb	(GtkWidget	*widget,
+				 gpointer	 data)
+{
+	MainWindow *mainwin = (MainWindow *)data;
+
+	compose_cb(mainwin, 0, NULL);
+}
+
+static void toolbar_reply_cb	(GtkWidget	*widget,
+				 gpointer	 data)
+{
+	MainWindow *mainwin = (MainWindow *)data;
+
+	reply_cb(mainwin, COMPOSE_REPLY, NULL);
+}
+
+static void toolbar_reply_to_all_cb	(GtkWidget	*widget,
+					 gpointer	 data)
+{
+	MainWindow *mainwin = (MainWindow *)data;
+
+	reply_cb(mainwin, COMPOSE_REPLY_TO_ALL, NULL);
+}
+
+static void toolbar_forward_cb	(GtkWidget	*widget,
+				 gpointer	 data)
+{
+	MainWindow *mainwin = (MainWindow *)data;
+
+	reply_cb(mainwin, COMPOSE_FORWARD, NULL);
+}
+
+static void toolbar_delete_cb	(GtkWidget	*widget,
+				 gpointer	 data)
+{
+	MainWindow *mainwin = (MainWindow *)data;
+
+	summary_delete(mainwin->summaryview);
+}
+
+static void toolbar_exec_cb	(GtkWidget	*widget,
+				 gpointer	 data)
+{
+	MainWindow *mainwin = (MainWindow *)data;
+
+	summary_execute(mainwin->summaryview);
+}
+
+static void toolbar_next_unread_cb	(GtkWidget	*widget,
+					 gpointer	 data)
+{
+	MainWindow *mainwin = (MainWindow *)data;
+
+	next_unread_cb(mainwin, 0, NULL);
+}
+
+static void toolbar_prefs_cb	(GtkWidget	*widget,
+				 gpointer	 data)
+{
+	prefs_common_open();
+}
+
+static void toolbar_account_cb	(GtkWidget	*widget,
+				 gpointer	 data)
+{
+	MainWindow *mainwin = (MainWindow *)data;
+
+	prefs_account_open_cb(mainwin, 0, NULL);
+}
+
+static void toolbar_account_button_pressed(GtkWidget *widget,
+					   GdkEventButton *event,
+					   gpointer data)
+{
+	MainWindow *mainwin = (MainWindow *)data;
+
+	if (!event) return;
+	if (event->button != 3) return;
+
+	gtk_button_set_relief(GTK_BUTTON(widget), GTK_RELIEF_NORMAL);
+	gtk_object_set_data(GTK_OBJECT(mainwin->ac_menu), "menu_button",
+			    widget);
+
+	gtk_menu_popup(GTK_MENU(mainwin->ac_menu), NULL, NULL,
+		       menu_button_position, widget,
+		       event->button, event->time);
+}
+
+static void ac_label_button_pressed(GtkWidget *widget, GdkEventButton *event,
+				    gpointer data)
+{
+	MainWindow *mainwin = (MainWindow *)data;
+
+	if (!event) return;
+
+	gtk_button_set_relief(GTK_BUTTON(widget), GTK_RELIEF_NORMAL);
+	gtk_object_set_data(GTK_OBJECT(mainwin->ac_menu), "menu_button",
+			    widget);
+
+	gtk_menu_popup(GTK_MENU(mainwin->ac_menu), NULL, NULL,
+		       menu_button_position, widget,
+		       event->button, event->time);
+}
+
+static void ac_menu_popup_closed(GtkMenuShell *menu_shell, gpointer data)
+{
+	MainWindow *mainwin = (MainWindow *)data;
+	GtkWidget *button;
+
+	button = gtk_object_get_data(GTK_OBJECT(menu_shell), "menu_button");
+	gtk_button_set_relief(GTK_BUTTON(button), GTK_RELIEF_NONE);
+	gtk_object_remove_data(GTK_OBJECT(mainwin->ac_menu), "menu_button");
+	manage_window_focus_in(mainwin->window, NULL, NULL);
+}
+
+static gint main_window_close_cb(GtkWidget *widget, GdkEventAny *event,
+				 gpointer data)
+{
+	MainWindow *mainwin = (MainWindow *)data;
+
+	if (mainwin->lock_count == 0)
+		app_exit_cb(data, 0, widget);
+
+	return TRUE;
+}
+
+static void add_mailbox_cb(MainWindow *mainwin, guint action,
+			   GtkWidget *widget)
+{
+	main_window_add_mailbox(mainwin);
+}
+
+static void update_folderview_cb(MainWindow *mainwin, guint action,
+				 GtkWidget *widget)
+{
+	summary_show(mainwin->summaryview, NULL, FALSE);
+	folderview_update_all();
+}
+
+static void new_folder_cb(MainWindow *mainwin, guint action,
+			  GtkWidget *widget)
+{
+	folderview_new_folder(mainwin->folderview);
+}
+
+static void rename_folder_cb(MainWindow *mainwin, guint action,
+			     GtkWidget *widget)
+{
+	folderview_rename_folder(mainwin->folderview);
+}
+
+static void delete_folder_cb(MainWindow *mainwin, guint action,
+			     GtkWidget *widget)
+{
+	folderview_delete_folder(mainwin->folderview);
+}
+
+static void import_mbox_cb(MainWindow *mainwin, guint action,
+			   GtkWidget *widget)
+{
+	import_mbox(mainwin->summaryview->folder_item);
+}
+
+static void export_mbox_cb(MainWindow *mainwin, guint action,
+			   GtkWidget *widget)
+{
+	export_mbox(mainwin->summaryview->folder_item);
+}
+
+static void empty_trash_cb(MainWindow *mainwin, guint action,
+			   GtkWidget *widget)
+{
+	main_window_empty_trash(mainwin, TRUE);
+}
+
+static void save_as_cb(MainWindow *mainwin, guint action, GtkWidget *widget)
+{
+	summary_save_as(mainwin->summaryview);
+}
+
+static void print_cb(MainWindow *mainwin, guint action, GtkWidget *widget)
+{
+	summary_print(mainwin->summaryview);
+}
+
+static void app_exit_cb(MainWindow *mainwin, guint action, GtkWidget *widget)
+{
+	if (prefs_common.confirm_on_exit) {
+		if (alertpanel(_("Exit"), _("Exit this program?"),
+			       _("OK"), _("Cancel"), NULL) != G_ALERTDEFAULT)
+			return;
+		manage_window_focus_in(mainwin->window, NULL, NULL);
+	}
+
+	app_will_exit(widget, mainwin);
+}
+
+static void toggle_folder_cb(MainWindow *mainwin, guint action,
+			     GtkWidget *widget)
+{
+	switch (mainwin->type) {
+	case SEPARATE_NONE:
+	case SEPARATE_MESSAGE:
+		break;
+	case SEPARATE_FOLDER:
+		if (GTK_CHECK_MENU_ITEM(widget)->active)
+			gtk_widget_show(mainwin->win.sep_folder.folderwin);
+		else
+			gtk_widget_hide(mainwin->win.sep_folder.folderwin);
+		break;
+	case SEPARATE_BOTH:
+		if (GTK_CHECK_MENU_ITEM(widget)->active)
+			gtk_widget_show(mainwin->win.sep_both.folderwin);
+		else
+			gtk_widget_hide(mainwin->win.sep_both.folderwin);
+		break;
+	}
+}
+
+static void toggle_message_cb(MainWindow *mainwin, guint action,
+			      GtkWidget *widget)
+{
+	switch (mainwin->type) {
+	case SEPARATE_NONE:
+	case SEPARATE_FOLDER:
+		break;
+	case SEPARATE_MESSAGE:
+		if (GTK_CHECK_MENU_ITEM(widget)->active)
+			gtk_widget_show(mainwin->win.sep_message.messagewin);
+		else
+			gtk_widget_hide(mainwin->win.sep_message.messagewin);
+		break;
+	case SEPARATE_BOTH:
+		if (GTK_CHECK_MENU_ITEM(widget)->active)
+			gtk_widget_show(mainwin->win.sep_both.messagewin);
+		else
+			gtk_widget_hide(mainwin->win.sep_both.messagewin);
+		break;
+	}
+}
+
+static void toggle_toolbar_cb(MainWindow *mainwin, guint action,
+			      GtkWidget *widget)
+{
+	switch ((ToolbarStyle)action) {
+	case TOOLBAR_NONE:
+		gtk_widget_hide(mainwin->handlebox);
+	case TOOLBAR_ICON:
+		gtk_toolbar_set_style(GTK_TOOLBAR(mainwin->toolbar),
+				      GTK_TOOLBAR_ICONS);
+		break;
+	case TOOLBAR_TEXT:
+		gtk_toolbar_set_style(GTK_TOOLBAR(mainwin->toolbar),
+				      GTK_TOOLBAR_TEXT);
+		break;
+	case TOOLBAR_BOTH:
+		gtk_toolbar_set_style(GTK_TOOLBAR(mainwin->toolbar),
+				      GTK_TOOLBAR_BOTH);
+		break;
+	}
+
+	if (action != TOOLBAR_NONE) {
+		gtk_widget_show(mainwin->handlebox);
+		gtk_widget_queue_resize(mainwin->handlebox);
+	}
+
+	mainwin->toolbar_style = (ToolbarStyle)action;
+	prefs_common.toolbar_style = (ToolbarStyle)action;
+}
+
+static void toggle_statusbar_cb(MainWindow *mainwin, guint action,
+				GtkWidget *widget)
+{
+	if (GTK_CHECK_MENU_ITEM(widget)->active) {
+		gtk_widget_show(mainwin->hbox_stat);
+		prefs_common.show_statusbar = TRUE;
+	} else {
+		gtk_widget_hide(mainwin->hbox_stat);
+		prefs_common.show_statusbar = FALSE;
+	}
+}
+
+static void separate_widget_cb(MainWindow *mainwin, guint action,
+			       GtkWidget *widget)
+{
+	SeparateType type;
+
+	type = mainwin->type ^ action;
+	main_window_separation_change(mainwin, type);
+
+	prefs_common.sep_folder = (type & SEPARATE_FOLDER)  != 0;
+	prefs_common.sep_msg    = (type & SEPARATE_MESSAGE) != 0;
+}
+
+static void addressbook_open_cb(MainWindow *mainwin, guint action,
+				GtkWidget *widget)
+{
+	addressbook_open(NULL);
+}
+
+static void log_window_show_cb(MainWindow *mainwin, guint action,
+			       GtkWidget *widget)
+{
+	log_window_show(mainwin->logwin);
+}
+
+static void inc_mail_cb(MainWindow *mainwin, guint action, GtkWidget *widget)
+{
+	inc_mail(mainwin);
+}
+
+static void inc_all_account_mail_cb(MainWindow *mainwin, guint action,
+				    GtkWidget *widget)
+{
+	inc_all_account_mail(mainwin);
+}
+
+static void send_queue_cb(MainWindow *mainwin, guint action, GtkWidget *widget)
+{
+	GList *list;
+
+	if (procmsg_send_queue() < 0)
+		alertpanel_error(_("Some errors occurred while sending queued messages."));
+
+	statusbar_pop_all();
+
+	for (list = folder_get_list(); list != NULL; list = list->next) {
+		Folder *folder;
+
+		folder = list->data;
+		if (folder->queue) {
+			folder_item_scan(folder->queue);
+			folderview_update_item(folder->queue, TRUE);
+		}
+	}
+}
+
+static void compose_cb(MainWindow *mainwin, guint action, GtkWidget *widget)
+{
+	PrefsAccount *ac = NULL;
+
+	if (mainwin->summaryview->folder_item) {
+		ac = mainwin->summaryview->folder_item->folder->account;
+		if (ac && ac->protocol == A_NNTP) {
+			compose_new_with_recipient
+				(ac, mainwin->summaryview->folder_item->path);
+			return;
+		}
+	}
+
+	compose_new(ac);
+}
+
+static void reply_cb(MainWindow *mainwin, guint action, GtkWidget *widget)
+{
+	MsgInfo *msginfo;
+
+	msginfo = gtk_ctree_node_get_row_data
+		(GTK_CTREE(mainwin->summaryview->ctree),
+		 mainwin->summaryview->selected);
+
+	if (!msginfo) return;
+
+	switch (action) {
+	case COMPOSE_REPLY:
+		compose_reply(msginfo, prefs_common.reply_with_quote,
+			      FALSE, FALSE);
+		break;
+	case COMPOSE_REPLY_TO_SENDER:
+		compose_reply(msginfo, prefs_common.reply_with_quote,
+			      FALSE, TRUE);
+		break;
+	case COMPOSE_REPLY_TO_ALL:
+		compose_reply(msginfo, prefs_common.reply_with_quote,
+			      TRUE, FALSE);
+		break;
+	case COMPOSE_FORWARD:
+		compose_forward(msginfo, FALSE);
+		break;
+	case COMPOSE_FORWARD_AS_ATTACH:
+		compose_forward(msginfo, TRUE);
+		break;
+	default:
+		g_warning("reply_cb(): invalid action type: %d\n", action);
+	}
+
+	summary_set_marks_selected(mainwin->summaryview);
+}
+
+static void move_to_cb(MainWindow *mainwin, guint action, GtkWidget *widget)
+{
+	summary_move_to(mainwin->summaryview);
+}
+
+static void copy_to_cb(MainWindow *mainwin, guint action, GtkWidget *widget)
+{
+	summary_copy_to(mainwin->summaryview);
+}
+
+static void delete_cb(MainWindow *mainwin, guint action, GtkWidget *widget)
+{
+	summary_delete(mainwin->summaryview);
+}
+
+static void open_msg_cb(MainWindow *mainwin, guint action, GtkWidget *widget)
+{
+	summary_open_msg(mainwin->summaryview);
+}
+
+static void view_source_cb(MainWindow *mainwin, guint action,
+			   GtkWidget *widget)
+{
+	summary_view_source(mainwin->summaryview);
+}
+
+static void reedit_cb(MainWindow *mainwin, guint action, GtkWidget *widget)
+{
+	summary_reedit(mainwin->summaryview);
+}
+
+static void mark_cb(MainWindow *mainwin, guint action, GtkWidget *widget)
+{
+	summary_mark(mainwin->summaryview);
+}
+
+static void unmark_cb(MainWindow *mainwin, guint action, GtkWidget *widget)
+{
+	summary_unmark(mainwin->summaryview);
+}
+
+static void mark_as_unread_cb(MainWindow *mainwin, guint action,
+			      GtkWidget *widget)
+{
+	summary_mark_as_unread(mainwin->summaryview);
+}
+
+static void mark_as_read_cb(MainWindow *mainwin, guint action,
+			    GtkWidget *widget)
+{
+	summary_mark_as_read(mainwin->summaryview);
+}
+
+static void mark_all_read_cb(MainWindow *mainwin, guint action,
+			     GtkWidget *widget)
+{
+	summary_mark_all_read(mainwin->summaryview);
+}
+
+static void add_address_cb(MainWindow *mainwin, guint action,
+			   GtkWidget *widget)
+{
+	summary_add_address(mainwin->summaryview);
+}
+
+static void set_charset_cb(MainWindow *mainwin, guint action,
+			   GtkWidget *widget)
+{
+	const gchar *str;
+
+	str = conv_get_charset_str((CharSet)action);
+	g_free(prefs_common.force_charset);
+	prefs_common.force_charset = str ? g_strdup(str) : NULL;
+
+	summary_redisplay_msg(mainwin->summaryview);
+
+	debug_print(_("forced charset: %s\n"), str ? str : "Auto-Detect");
+}
+
+static void thread_cb(MainWindow *mainwin, guint action, GtkWidget *widget)
+{
+	GtkItemFactory *ifactory;
+
+	ifactory = gtk_item_factory_from_widget(widget);
+
+	if (0 == action) {
+		summary_thread_build(mainwin->summaryview, FALSE);
+		prefs_common.enable_thread = TRUE;
+		menu_set_sensitive(ifactory, "/Summary/Thread view",   FALSE);
+		menu_set_sensitive(ifactory, "/Summary/Unthread view", TRUE);
+	} else {
+		summary_unthread(mainwin->summaryview);
+		prefs_common.enable_thread = FALSE;
+		menu_set_sensitive(ifactory, "/Summary/Thread view",   TRUE);
+		menu_set_sensitive(ifactory, "/Summary/Unthread view", FALSE);
+	}
+}
+
+static void set_display_item_cb(MainWindow *mainwin, guint action,
+				GtkWidget *widget)
+{
+	prefs_summary_display_item_set();
+}
+
+static void sort_summary_cb(MainWindow *mainwin, guint action,
+			    GtkWidget *widget)
+{
+	summary_sort(mainwin->summaryview, (SummarySortType)action);
+}
+
+static void attract_by_subject_cb(MainWindow *mainwin, guint action,
+				  GtkWidget *widget)
+{
+	summary_attract_by_subject(mainwin->summaryview);
+}
+
+static void delete_duplicated_cb(MainWindow *mainwin, guint action,
+				 GtkWidget *widget)
+{
+	summary_delete_duplicated(mainwin->summaryview);
+}
+
+static void filter_cb(MainWindow *mainwin, guint action, GtkWidget *widget)
+{
+	summary_filter(mainwin->summaryview);
+}
+
+static void execute_summary_cb(MainWindow *mainwin, guint action,
+			       GtkWidget *widget)
+{
+	summary_execute(mainwin->summaryview);
+}
+
+static void update_summary_cb(MainWindow *mainwin, guint action,
+			      GtkWidget *widget)
+{
+	FolderItem *fitem;
+	FolderView *folderview = mainwin->folderview;
+
+	if (!mainwin->summaryview->folder_item) return;
+	if (!folderview->opened) return;
+
+	fitem = gtk_ctree_node_get_row_data(GTK_CTREE(folderview->ctree),
+					    folderview->opened);
+	if (!fitem) return;
+
+	summary_show(mainwin->summaryview, fitem, TRUE);
+}
+
+static void prev_cb(MainWindow *mainwin, guint action, GtkWidget *widget)
+{
+	summary_step(mainwin->summaryview, GTK_SCROLL_STEP_BACKWARD);
+}
+
+static void next_cb(MainWindow *mainwin, guint action, GtkWidget *widget)
+{
+	summary_step(mainwin->summaryview, GTK_SCROLL_STEP_FORWARD);
+}
+
+static void prev_unread_cb(MainWindow *mainwin, guint action,
+			   GtkWidget *widget)
+{
+	summary_select_prev_unread(mainwin->summaryview);
+}
+
+static void next_unread_cb(MainWindow *mainwin, guint action,
+			   GtkWidget *widget)
+{
+	summary_select_next_unread(mainwin->summaryview);
+}
+
+static void prev_marked_cb(MainWindow *mainwin, guint action,
+			   GtkWidget *widget)
+{
+	summary_select_prev_marked(mainwin->summaryview);
+}
+
+static void next_marked_cb(MainWindow *mainwin, guint action,
+			   GtkWidget *widget)
+{
+	summary_select_next_marked(mainwin->summaryview);
+}
+
+static void prev_labeled_cb(MainWindow *mainwin, guint action,
+			    GtkWidget *widget)
+{
+	summary_select_prev_labeled(mainwin->summaryview);
+}
+
+static void next_labeled_cb(MainWindow *mainwin, guint action,
+			    GtkWidget *widget)
+{
+	summary_select_next_labeled(mainwin->summaryview);
+}
+
+static void goto_folder_cb(MainWindow *mainwin, guint action,
+			   GtkWidget *widget)
+{
+	FolderItem *to_folder;
+
+	to_folder = foldersel_folder_sel(NULL, NULL);
+
+	if (to_folder)
+		folderview_select(mainwin->folderview, to_folder);
+}
+
+static void copy_cb(MainWindow *mainwin, guint action, GtkWidget *widget)
+{
+	messageview_copy_clipboard(mainwin->messageview);
+}
+
+static void allsel_cb(MainWindow *mainwin, guint action, GtkWidget *widget)
+{
+	if (GTK_WIDGET_HAS_FOCUS(mainwin->summaryview->ctree))
+		summary_select_all(mainwin->summaryview);
+	else if (mainwin->summaryview->msg_is_toggled_on &&
+		 GTK_WIDGET_HAS_FOCUS(mainwin->messageview->textview->text))
+		messageview_select_all(mainwin->messageview);
+}
+
+static void prefs_common_open_cb(MainWindow *mainwin, guint action,
+				 GtkWidget *widget)
+{
+	prefs_common_open();
+}
+
+static void prefs_filter_open_cb(MainWindow *mainwin, guint action,
+				 GtkWidget *widget)
+{
+	prefs_filter_open();
+}
+
+static void prefs_account_open_cb(MainWindow *mainwin, guint action,
+				  GtkWidget *widget)
+{
+	if (!cur_account) {
+		new_account_cb(mainwin, 0, widget);
+	} else {
+		gboolean prev_default = cur_account->is_default;
+
+		prefs_account_open(cur_account);
+		if (!prev_default && cur_account->is_default)
+			account_set_as_default(cur_account);
+		account_save_config_all();
+		account_set_menu();
+		main_window_reflect_prefs_all();
+	}
+}
+
+static void new_account_cb(MainWindow *mainwin, guint action,
+			   GtkWidget *widget)
+{
+	account_edit_open();
+	if (!compose_get_compose_list()) account_add();
+}
+
+static void account_menu_cb(GtkMenuItem	*menuitem, gpointer data)
+{
+	cur_account = (PrefsAccount *)data;
+	main_window_reflect_prefs_all();
+}
+
+static void manual_open_cb(MainWindow *mainwin, guint action,
+			   GtkWidget *widget)
+{
+	manual_open((ManualLang)action);
+}
+
+static void scan_tree_func(Folder *folder, FolderItem *item, gpointer data)
+{
+	MainWindow *mainwin = (MainWindow *)data;
+	gchar *str;
+
+	if (item->path)
+		str = g_strdup_printf(_("Scanning folder %s%c%s ..."),
+				      LOCAL_FOLDER(folder)->rootpath,
+				      G_DIR_SEPARATOR,
+				      item->path);
+	else
+		str = g_strdup_printf(_("Scanning folder %s ..."),
+				      LOCAL_FOLDER(folder)->rootpath);
+
+	STATUSBAR_PUSH(mainwin, str);
+	STATUSBAR_POP(mainwin);
+	g_free(str);
+}
diff -urN sylpheed-0.6.2.orig/src/prefs_common.c sylpheed-0.6.2/src/prefs_common.c
--- sylpheed-0.6.2.orig/src/prefs_common.c	Sun Sep  9 15:25:10 2001
+++ sylpheed-0.6.2/src/prefs_common.c	Fri Oct  5 14:16:42 2001
@@ -87,8 +87,10 @@
 
 static struct Compose {
 	GtkWidget *checkbtn_quote;
+	GtkWidget *checkbtn_quote_forward;
 	GtkWidget *entry_quotemark;
 	GtkWidget *text_quotefmt;
+	GtkWidget *text_forwardfmt;
 	GtkWidget *checkbtn_autosig;
 	GtkWidget *entry_sigsep;
 
@@ -252,11 +254,17 @@
 	{"reply_with_quote", "TRUE", &prefs_common.reply_with_quote, P_BOOL,
 	 &compose.checkbtn_quote,
 	 prefs_set_data_from_toggle, prefs_set_toggle},
+	{"forward_with_quote", "TRUE", &prefs_common.forward_with_quote,
+	 P_BOOL, &compose.checkbtn_quote_forward,
+	 prefs_set_data_from_toggle, prefs_set_toggle},
 	{"quote_mark", "> ", &prefs_common.quotemark, P_STRING,
 	 &compose.entry_quotemark, prefs_set_data_from_entry, prefs_set_entry},
 	{"quote_format", "On %d\\n%f wrote:\\n\\n",
 	 &prefs_common.quotefmt, P_STRING, &compose.text_quotefmt,
 	 prefs_set_data_from_text, prefs_set_text},
+	{"forward_format", "\\n\\nBegin forwarded message:\\n\\nDate: %d\\nFrom: %f\\nTo: %t\\nNewsgroups: %g\\nSubject: %s\\n\\n",
+	 &prefs_common.forwardfmt, P_STRING, &compose.text_forwardfmt,
+	 prefs_set_data_from_text, prefs_set_text},
 
 	{"auto_signature", "TRUE", &prefs_common.auto_sig, P_BOOL,
 	 &compose.checkbtn_autosig,
@@ -1008,14 +1016,18 @@
 	GtkWidget *frame_quote;
 	GtkWidget *vbox_quote;
 	GtkWidget *checkbtn_quote;
+	GtkWidget *checkbtn_quote_forward;
 	GtkWidget *hbox1;
 	GtkWidget *label_quotemark;
 	GtkWidget *entry_quotemark;
 	GtkWidget *hbox2;
 	GtkWidget *label_quotefmt;
+	GtkWidget *label_forwardfmt;
 	GtkWidget *btn_quotedesc;
 	GtkWidget *scrolledwin_quotefmt;
+	GtkWidget *scrolledwin_forwardfmt;
 	GtkWidget *text_quotefmt;
+	GtkWidget *text_forwardfmt;
 
 	GtkWidget *frame_sig;
 	GtkWidget *checkbtn_autosig;
@@ -1066,6 +1078,8 @@
 
 	PACK_CHECK_BUTTON (hbox1, checkbtn_quote,
 			   _("Quote message when replying"));
+	PACK_CHECK_BUTTON (vbox_quote, checkbtn_quote_forward,
+			   _("Quote message when forwarding"));
 
 	hbox2 = gtk_hbox_new (FALSE, 0);
 	gtk_widget_show (hbox2);
@@ -1097,6 +1111,29 @@
 
 	/* signature */
 
+	hbox2 = gtk_hbox_new (FALSE, 0);
+	gtk_widget_show (hbox2);
+	gtk_box_pack_start (GTK_BOX (vbox_quote), hbox2, TRUE, TRUE, 0);
+
+	label_forwardfmt = gtk_label_new (_("Forward format:"));
+	gtk_widget_show (label_forwardfmt);
+	gtk_box_pack_start (GTK_BOX (hbox2), label_forwardfmt, FALSE,
+			    FALSE, 0);
+
+	scrolledwin_forwardfmt = gtk_scrolled_window_new (NULL, NULL);
+	gtk_widget_show (scrolledwin_forwardfmt);
+	gtk_box_pack_start (GTK_BOX (vbox_quote), scrolledwin_forwardfmt, TRUE, TRUE, 0);
+	gtk_scrolled_window_set_policy
+		(GTK_SCROLLED_WINDOW (scrolledwin_forwardfmt),
+		 GTK_POLICY_NEVER, GTK_POLICY_ALWAYS);
+
+	text_forwardfmt = gtk_text_new (NULL, NULL);
+	gtk_widget_show (text_forwardfmt);
+	gtk_container_add(GTK_CONTAINER(scrolledwin_forwardfmt),
+			  text_forwardfmt);
+	gtk_text_set_editable (GTK_TEXT (text_forwardfmt), TRUE);
+	gtk_widget_set_usize(text_forwardfmt, -1, 60);
+
 	PACK_FRAME(vbox1, frame_sig, _("Signature"));
 
 	hbox1 = gtk_hbox_new (FALSE, 32);
@@ -1163,8 +1200,10 @@
 		(hbox4, checkbtn_wrapatsend, _("Wrap before sending"));
 
 	compose.checkbtn_quote   = checkbtn_quote;
+	compose.checkbtn_quote_forward   = checkbtn_quote_forward;
 	compose.entry_quotemark  = entry_quotemark;
 	compose.text_quotefmt    = text_quotefmt;
+	compose.text_forwardfmt    = text_forwardfmt;
 	compose.checkbtn_autosig = checkbtn_autosig;
 	compose.entry_sigsep     = entry_sigsep;
 
@@ -2412,6 +2451,7 @@
 		 "%I:\n"
 		 "%s:\n"
 		 "%t:\n"
+		 "%g:\n"
 		 "%c:\n"
 		 "%i:\n"
 		 "%%:");
@@ -2428,6 +2468,7 @@
 		   "Subject\n"
 		   "To\n"
 		   "Cc\n"
+			 "Newsgroups\n"
 		   "Message-ID\n"
 		   "%"));
 
diff -urN sylpheed-0.6.2.orig/src/prefs_common.h sylpheed-0.6.2/src/prefs_common.h
--- sylpheed-0.6.2.orig/src/prefs_common.h	Sun Sep  9 15:24:46 2001
+++ sylpheed-0.6.2/src/prefs_common.h	Fri Oct  5 14:13:33 2001
@@ -61,8 +61,10 @@
 
 	/* Compose */
 	gboolean reply_with_quote;
+	gboolean forward_with_quote;
 	gchar *quotemark;
 	gchar *quotefmt;
+	gchar *forwardfmt;
 	gboolean auto_sig;
 	gchar *sig_sep;
 	gint linewrap_len;
diff -urN sylpheed-0.6.2.orig/src/prefs_common.h.orig sylpheed-0.6.2/src/prefs_common.h.orig
--- sylpheed-0.6.2.orig/src/prefs_common.h.orig	Thu Jan  1 01:00:00 1970
+++ sylpheed-0.6.2/src/prefs_common.h.orig	Sun Sep  9 15:24:46 2001
@@ -0,0 +1,204 @@
+/*
+ * Sylpheed -- a GTK+ based, lightweight, and fast e-mail client
+ * Copyright (C) 1999-2001 Hiroyuki Yamamoto
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef __PREFS_COMMON_H__
+#define __PREFS_COMMON_H__
+
+#ifdef HAVE_CONFIG_H
+#  include "config.h"
+#endif
+
+#include <glib.h>
+
+#include "mainwindow.h"
+#include "codeconv.h"
+#include "textview.h"
+
+typedef struct _PrefsCommon	PrefsCommon;
+
+typedef enum {
+	RECV_DIALOG_ALWAYS,
+	RECV_DIALOG_ACTIVE,
+	RECV_DIALOG_NEVER
+} RecvDialogMode;
+
+struct _PrefsCommon
+{
+	/* Receive */
+	gboolean use_extinc;
+	gchar *extinc_cmd;
+	gboolean inc_local;
+	gboolean filter_on_inc;
+	gchar *spool_path;
+	gboolean scan_all_after_inc;
+	gboolean autochk_newmail;
+	gint autochk_itv;
+	gboolean chk_on_startup;
+	gint max_articles;
+
+	/* Send */
+	gboolean use_extsend;
+	gchar *extsend_cmd;
+	gboolean savemsg;
+	gboolean queue_msg;
+	gchar *outgoing_charset;
+
+	/* Compose */
+	gboolean reply_with_quote;
+	gchar *quotemark;
+	gchar *quotefmt;
+	gboolean auto_sig;
+	gchar *sig_sep;
+	gint linewrap_len;
+	gboolean linewrap_quote;
+	gboolean linewrap_at_send;
+	gboolean auto_exteditor;
+	gboolean reply_account_autosel;
+	gboolean show_ruler;
+
+	/* Display */
+	gchar *widgetfont;
+	gchar *textfont;
+	gchar *normalfont;
+	gchar *boldfont;
+	gchar *smallfont;
+	gboolean display_folder_unread;
+	ToolbarStyle toolbar_style;
+	gboolean show_statusbar;
+	gboolean trans_hdr;
+	gboolean enable_thread;
+	gboolean enable_hscrollbar;
+	gboolean expand_thread;
+	gboolean bold_unread;
+	gboolean swap_from;
+	gchar *date_format;
+
+	/* Filtering */
+	GSList *fltlist;
+
+	gboolean show_mark;
+	gboolean show_unread;
+	gboolean show_mime;
+	gboolean show_number;
+	gboolean show_size;
+	gboolean show_date;
+	gboolean show_from;
+	gboolean show_subject;
+
+	/* Widget size */
+	gint folderview_x;
+	gint folderview_y;
+	gint folderview_width;
+	gint folderview_height;
+	gint folder_col_folder;
+	gint folder_col_new;
+	gint folder_col_unread;
+	gint folder_col_total;
+
+	gint summaryview_width;
+	gint summaryview_height;
+	gint summary_col_mark;
+	gint summary_col_unread;
+	gint summary_col_mime;
+	gint summary_col_number;
+	gint summary_col_size;
+	gint summary_col_date;
+	gint summary_col_from;
+	gint summary_col_subject;
+
+	gint mainview_x;
+	gint mainview_y;
+	gint mainview_width;
+	gint mainview_height;
+	gint mainwin_x;
+	gint mainwin_y;
+	gint mainwin_width;
+	gint mainwin_height;
+
+	gint msgwin_width;
+	gint msgwin_height;
+
+	gint compose_width;
+	gint compose_height;
+
+	/* Message */
+	gboolean enable_color;
+	gint quote_level1_col;
+	gint quote_level2_col;
+	gint quote_level3_col;
+	gint uri_col;
+	gushort sig_col;
+	gboolean recycle_quote_colors;
+	gboolean conv_mb_alnum;
+	gboolean display_header_pane;
+	gboolean display_header;
+	gboolean head_space;
+	gint line_space;
+	gboolean enable_smooth_scroll;
+	gint scroll_step;
+	gboolean scroll_halfpage;
+
+	gchar *force_charset;
+
+	gboolean show_other_header;
+	GSList *disphdr_list;
+
+	/* MIME viewer */
+	gchar *mime_image_viewer;
+	gchar *mime_audio_player;
+
+	/* Privacy */
+	gboolean default_encrypt;
+	gboolean default_sign;
+	gboolean auto_check_signatures;
+	gboolean gpg_signature_popup;
+	gboolean passphrase_grab;
+	gchar *default_signkey;
+	gboolean gpg_warning;
+
+	/* Interface */
+	gboolean sep_folder;
+	gboolean sep_msg;
+	gboolean emulate_emacs;
+	gboolean open_unread_on_enter;
+	gboolean open_inbox_on_inc;
+	gboolean immediate_exec;
+	RecvDialogMode recv_dialog_mode;
+	gboolean add_address_by_click;
+
+	gboolean confirm_on_exit;
+	gboolean clean_on_exit;
+	gboolean ask_on_clean;
+	gboolean warn_queued_on_exit;
+
+	/* Other */
+	gchar *uri_cmd;
+	gchar *print_cmd;
+	gchar *ext_editor_cmd;
+};
+
+extern PrefsCommon prefs_common;
+
+void prefs_common_read_config	(void);
+void prefs_common_save_config	(void);
+void prefs_common_open		(void);
+
+void prefs_summary_display_item_set	(void);
+
+#endif /* __PREFS_COMMON_H__ */
diff -urN sylpheed-0.6.2.orig/src/summaryview.c sylpheed-0.6.2/src/summaryview.c
--- sylpheed-0.6.2.orig/src/summaryview.c	Tue Sep 11 16:14:03 2001
+++ sylpheed-0.6.2/src/summaryview.c	Fri Oct  5 14:13:33 2001
@@ -3493,10 +3493,10 @@
 		compose_reply(msginfo, FALSE, TRUE, FALSE);
 		break;
 	case COMPOSE_FORWARD:
-		compose_forward(msginfo, FALSE);
+		compose_forward(msginfo, prefs_common.forward_with_quote, FALSE);
 		break;
 	case COMPOSE_FORWARD_AS_ATTACH:
-		compose_forward(msginfo, TRUE);
+		compose_forward(msginfo, prefs_common.forward_with_quote, TRUE);
 		break;
 	default:
 		g_warning("summary_reply_cb(): invalid action: %d\n", action);
diff -urN sylpheed-0.6.2.orig/src/summaryview.c.orig sylpheed-0.6.2/src/summaryview.c.orig
--- sylpheed-0.6.2.orig/src/summaryview.c.orig	Thu Jan  1 01:00:00 1970
+++ sylpheed-0.6.2/src/summaryview.c.orig	Tue Sep 11 16:14:03 2001
@@ -0,0 +1,3734 @@
+/*
+ * Sylpheed -- a GTK+ based, lightweight, and fast e-mail client
+ * Copyright (C) 1999-2001 Hiroyuki Yamamoto
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include "defs.h"
+
+#include <glib.h>
+#include <gdk/gdkkeysyms.h>
+#include <gtk/gtkscrolledwindow.h>
+#include <gtk/gtkwidget.h>
+#include <gtk/gtkpixmap.h>
+#include <gtk/gtkctree.h>
+#include <gtk/gtkcontainer.h>
+#include <gtk/gtksignal.h>
+#include <gtk/gtktext.h>
+#include <gtk/gtkmenu.h>
+#include <gtk/gtkmenuitem.h>
+#include <gtk/gtkitemfactory.h>
+#include <gtk/gtkvbox.h>
+#include <gtk/gtkhbox.h>
+#include <gtk/gtkwindow.h>
+#include <gtk/gtkstyle.h>
+#include <gtk/gtkarrow.h>
+#include <gtk/gtkeventbox.h>
+#include <gtk/gtkstatusbar.h>
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <ctype.h>
+#include <unistd.h>
+
+#include "intl.h"
+#include "main.h"
+#include "menu.h"
+#include "mainwindow.h"
+#include "folderview.h"
+#include "summaryview.h"
+#include "messageview.h"
+#include "foldersel.h"
+#include "procmsg.h"
+#include "procheader.h"
+#include "headerwindow.h"
+#include "sourcewindow.h"
+#include "prefs_common.h"
+#include "account.h"
+#include "compose.h"
+#include "utils.h"
+#include "gtkutils.h"
+#include "filesel.h"
+#include "manage_window.h"
+#include "alertpanel.h"
+#include "inputdialog.h"
+#include "statusbar.h"
+#include "filter.h"
+#include "folder.h"
+#include "colorlabel.h"
+#include "inc.h"
+
+#include "pixmaps/dir-open.xpm"
+#include "pixmaps/mark.xpm"
+#include "pixmaps/deleted.xpm"
+#include "pixmaps/new.xpm"
+#include "pixmaps/unread.xpm"
+#include "pixmaps/replied.xpm"
+#include "pixmaps/forwarded.xpm"
+#include "pixmaps/clip.xpm"
+
+#define STATUSBAR_PUSH(mainwin, str) \
+{ \
+	gtk_statusbar_push(GTK_STATUSBAR(mainwin->statusbar), \
+			   mainwin->summaryview_cid, str); \
+	gtkut_widget_wait_for_draw(mainwin->hbox_stat); \
+}
+
+#define STATUSBAR_POP(mainwin) \
+{ \
+	gtk_statusbar_pop(GTK_STATUSBAR(mainwin->statusbar), \
+			  mainwin->summaryview_cid); \
+}
+
+#define SUMMARY_COL_MARK_WIDTH		10
+#define SUMMARY_COL_UNREAD_WIDTH	13
+#define SUMMARY_COL_MIME_WIDTH		10
+
+static GdkFont *boldfont;
+static GdkFont *smallfont;
+
+static GtkStyle *bold_style;
+static GtkStyle *bold_marked_style;
+static GtkStyle *bold_deleted_style;
+
+static GdkPixmap *folderxpm;
+static GdkBitmap *folderxpmmask;
+
+static GdkPixmap *markxpm;
+static GdkBitmap *markxpmmask;
+static GdkPixmap *deletedxpm;
+static GdkBitmap *deletedxpmmask;
+
+static GdkPixmap *newxpm;
+static GdkBitmap *newxpmmask;
+static GdkPixmap *unreadxpm;
+static GdkBitmap *unreadxpmmask;
+static GdkPixmap *repliedxpm;
+static GdkBitmap *repliedxpmmask;
+static GdkPixmap *forwardedxpm;
+static GdkBitmap *forwardedxpmmask;
+
+static GdkPixmap *clipxpm;
+static GdkBitmap *clipxpmmask;
+
+static void summary_free_msginfo_func	(GtkCTree		*ctree,
+					 GtkCTreeNode		*node,
+					 gpointer		 data);
+static void summary_set_marks_func	(GtkCTree		*ctree,
+					 GtkCTreeNode		*node,
+					 gpointer		 data);
+static void summary_write_cache_func	(GtkCTree		*ctree,
+					 GtkCTreeNode		*node,
+					 gpointer		 data);
+
+static void summary_set_menu_sensitive	(SummaryView		*summaryview);
+
+static void summary_select_node		(SummaryView		*summaryview,
+					 GtkCTreeNode		*node,
+					 gboolean		 display_msg);
+
+static guint summary_get_msgnum		(SummaryView		*summaryview,
+					 GtkCTreeNode		*node);
+
+static GtkCTreeNode *summary_find_prev_unread_msg
+					(SummaryView		*summaryview,
+					 GtkCTreeNode		*current_node);
+static GtkCTreeNode *summary_find_next_unread_msg
+					(SummaryView		*summaryview,
+					 GtkCTreeNode		*current_node);
+static GtkCTreeNode *summary_find_prev_marked_msg
+					(SummaryView		*summaryview,
+					 GtkCTreeNode		*current_node);
+static GtkCTreeNode *summary_find_next_marked_msg
+					(SummaryView		*summaryview,
+					 GtkCTreeNode		*current_node);
+static GtkCTreeNode *summary_find_prev_labeled_msg
+					(SummaryView		*summaryview,
+					 GtkCTreeNode		*current_node);
+static GtkCTreeNode *summary_find_next_labeled_msg
+					(SummaryView		*summaryview,
+					 GtkCTreeNode		*current_node);
+static GtkCTreeNode *summary_find_msg_by_msgnum
+					(SummaryView		*summaryview,
+					 guint			 msgnum);
+
+static void summary_update_status	(SummaryView		*summaryview);
+
+/* display functions */
+static void summary_status_show		(SummaryView		*summaryview);
+static void summary_set_ctree_from_list	(SummaryView		*summaryview,
+					 GSList			*mlist);
+static void summary_set_header		(gchar			*text[],
+					 MsgInfo		*msginfo);
+static void summary_display_msg		(SummaryView		*summaryview,
+					 GtkCTreeNode		*row,
+					 gboolean		 new_window);
+static void summary_toggle_view		(SummaryView		*summaryview);
+static void summary_set_row_marks	(SummaryView		*summaryview,
+					 GtkCTreeNode		*row);
+
+/* message handling */
+static void summary_mark_row		(SummaryView		*summaryview,
+					 GtkCTreeNode		*row);
+static void summary_mark_row_as_read	(SummaryView		*summaryview,
+					 GtkCTreeNode		*row);
+static void summary_mark_row_as_unread	(SummaryView		*summaryview,
+					 GtkCTreeNode		*row);
+static void summary_delete_row		(SummaryView		*summaryview,
+					 GtkCTreeNode		*row);
+static void summary_unmark_row		(SummaryView		*summaryview,
+					 GtkCTreeNode		*row);
+static void summary_move_row_to		(SummaryView		*summaryview,
+					 GtkCTreeNode		*row,
+					 FolderItem		*to_folder);
+static void summary_copy_row_to		(SummaryView		*summaryview,
+					 GtkCTreeNode		*row,
+					 FolderItem		*to_folder);
+
+static void summary_delete_duplicated_func
+					(GtkCTree		*ctree,
+					 GtkCTreeNode		*node,
+					 SummaryView		*summaryview);
+
+static void summary_execute_move	(SummaryView		*summaryview);
+static void summary_execute_move_func	(GtkCTree		*ctree,
+					 GtkCTreeNode		*node,
+					 gpointer		 data);
+static void summary_execute_copy	(SummaryView		*summaryview);
+static void summary_execute_copy_func	(GtkCTree		*ctree,
+					 GtkCTreeNode		*node,
+					 gpointer		 data);
+static void summary_execute_delete	(SummaryView		*summaryview);
+static void summary_execute_delete_func	(GtkCTree		*ctree,
+					 GtkCTreeNode		*node,
+					 gpointer		 data);
+
+static void summary_unthread_for_exec		(SummaryView	*summaryview);
+static void summary_unthread_for_exec_func	(GtkCTree	*ctree,
+						 GtkCTreeNode	*node,
+						 gpointer	 data);
+
+static void summary_filter_func		(GtkCTree		*ctree,
+					 GtkCTreeNode		*node,
+					 gpointer		 data);
+
+static void summary_colorlabel_menu_item_activate_cb
+					  (GtkWidget	*widget,
+					   gpointer	 data);
+static void summary_colorlabel_menu_item_activate_item_cb
+					  (GtkMenuItem	*label_menu_item,
+					   gpointer	 data);
+static void summary_colorlabel_menu_create(SummaryView	*summaryview);
+
+/* callback functions */
+static void summary_toggle_pressed	(GtkWidget		*eventbox,
+					 GdkEventButton		*event,
+					 SummaryView		*summaryview);
+static void summary_button_pressed	(GtkWidget		*ctree,
+					 GdkEventButton		*event,
+					 SummaryView		*summaryview);
+static void summary_button_released	(GtkWidget		*ctree,
+					 GdkEventButton		*event,
+					 SummaryView		*summaryview);
+static void summary_key_pressed		(GtkWidget		*ctree,
+					 GdkEventKey		*event,
+					 SummaryView		*summaryview);
+static void summary_open_row		(GtkSCTree		*sctree,
+					 SummaryView		*summaryview);
+static void summary_tree_expanded	(GtkCTree		*ctree,
+					 GtkCTreeNode		*node,
+					 SummaryView		*summaryview);
+static void summary_tree_collapsed	(GtkCTree		*ctree,
+					 GtkCTreeNode		*node,
+					 SummaryView		*summaryview);
+static void summary_selected		(GtkCTree		*ctree,
+					 GtkCTreeNode		*row,
+					 gint			 column,
+					 SummaryView		*summaryview);
+static void summary_col_resized		(GtkCList		*clist,
+					 gint			 column,
+					 gint			 width,
+					 SummaryView		*summaryview);
+static void summary_reply_cb		(SummaryView		*summaryview,
+					 guint			 action,
+					 GtkWidget		*widget);
+static void summary_show_all_header_cb	(SummaryView		*summaryview,
+					 guint			 action,
+					 GtkWidget		*widget);
+
+static void summary_add_address_cb	(SummaryView		*summaryview,
+					 guint			 action,
+					 GtkWidget		*widget);
+
+static void summary_mark_clicked	(GtkWidget		*button,
+					 SummaryView		*summaryview);
+static void summary_unread_clicked	(GtkWidget		*button,
+					 SummaryView		*summaryview);
+static void summary_mime_clicked	(GtkWidget		*button,
+					 SummaryView		*summaryview);
+static void summary_num_clicked		(GtkWidget		*button,
+					 SummaryView		*summaryview);
+static void summary_size_clicked	(GtkWidget		*button,
+					 SummaryView		*summaryview);
+static void summary_date_clicked	(GtkWidget		*button,
+					 SummaryView		*summaryview);
+static void summary_from_clicked	(GtkWidget		*button,
+					 SummaryView		*summaryview);
+static void summary_subject_clicked	(GtkWidget		*button,
+					 SummaryView		*summaryview);
+
+static void summary_start_drag		(GtkWidget        *widget, 
+					 int button,
+					 GdkEvent *event,
+					 SummaryView      *summaryview);
+static void summary_drag_data_get       (GtkWidget        *widget,
+					 GdkDragContext   *drag_context,
+					 GtkSelectionData *selection_data,
+					 guint             info,
+					 guint             time,
+					 SummaryView      *summaryview);
+
+/* custom compare functions for sorting */
+
+static gint summary_cmp_by_mark		(GtkCList		*clist,
+					 gconstpointer		 ptr1,
+					 gconstpointer		 ptr2);
+static gint summary_cmp_by_unread	(GtkCList		*clist,
+					 gconstpointer		 ptr1,
+					 gconstpointer		 ptr2);
+static gint summary_cmp_by_mime		(GtkCList		*clist,
+					 gconstpointer		 ptr1,
+					 gconstpointer		 ptr2);
+static gint summary_cmp_by_num		(GtkCList		*clist,
+					 gconstpointer		 ptr1,
+					 gconstpointer		 ptr2);
+static gint summary_cmp_by_size		(GtkCList		*clist,
+					 gconstpointer		 ptr1,
+					 gconstpointer		 ptr2);
+static gint summary_cmp_by_date		(GtkCList		*clist,
+					 gconstpointer		 ptr1,
+					 gconstpointer		 ptr2);
+static gint summary_cmp_by_from		(GtkCList		*clist,
+					 gconstpointer		 ptr1,
+					 gconstpointer		 ptr2);
+static gint summary_cmp_by_subject	(GtkCList		*clist,
+					 gconstpointer		 ptr1,
+					 gconstpointer		 ptr2);
+static gint summary_cmp_by_label	(GtkCList		*clist,
+					 gconstpointer		 ptr1,
+					 gconstpointer		 ptr2);
+
+GtkTargetEntry summary_drag_types[1] =
+{
+	{"text/plain", GTK_TARGET_SAME_APP, TARGET_DUMMY}
+};
+
+static GtkItemFactoryEntry summary_popup_entries[] =
+{
+	{N_("/_Reply"),			NULL, summary_reply_cb,	COMPOSE_REPLY, NULL},
+	{N_("/Repl_y to sender"),	NULL, summary_reply_cb,	COMPOSE_REPLY_TO_SENDER, NULL},
+	{N_("/Reply to a_ll"),		NULL, summary_reply_cb,	COMPOSE_REPLY_TO_ALL, NULL},
+	{N_("/_Forward"),		NULL, summary_reply_cb, COMPOSE_FORWARD, NULL},
+	{N_("/Forward as a_ttachment"),
+					NULL, summary_reply_cb, COMPOSE_FORWARD_AS_ATTACH, NULL},
+	{N_("/---"),			NULL, NULL,		0, "<Separator>"},
+	{N_("/Re-_edit"),		NULL, summary_reedit,   0, NULL},
+	{N_("/---"),			NULL, NULL,		0, "<Separator>"},
+	{N_("/M_ove..."),		NULL, summary_move_to,	0, NULL},
+	{N_("/_Copy..."),		NULL, summary_copy_to,	0, NULL},
+	{N_("/_Delete"),		NULL, summary_delete,	0, NULL},
+	{N_("/E_xecute"),		NULL, summary_execute,	0, NULL},
+	{N_("/---"),			NULL, NULL,		0, "<Separator>"},
+	{N_("/_Mark"),			NULL, NULL,		0, "<Branch>"},
+	{N_("/_Mark/_Mark"),		NULL, summary_mark,	0, NULL},
+	{N_("/_Mark/_Unmark"),		NULL, summary_unmark,	0, NULL},
+	{N_("/_Mark/---"),		NULL, NULL,		0, "<Separator>"},
+	{N_("/_Mark/Mark as unr_ead"),	NULL, summary_mark_as_unread, 0, NULL},
+	{N_("/_Mark/Mark as rea_d"),
+					NULL, summary_mark_as_read, 0, NULL},
+	{N_("/_Mark/Mark all _read"),	NULL, summary_mark_all_read, 0, NULL},
+	{N_("/Color la_bel"),		NULL, NULL,		0, NULL},
+	{N_("/---"),			NULL, NULL,		0, "<Separator>"},
+	{N_("/Add sender to address boo_k"),
+					NULL, summary_add_address_cb, 0, NULL},
+	{N_("/---"),			NULL, NULL,		0, "<Separator>"},
+	{N_("/Open in new _window"),	NULL, summary_open_msg,	0, NULL},
+	{N_("/View so_urce"),		NULL, summary_view_source, 0, NULL},
+	{N_("/Show all _header"),	NULL, summary_show_all_header_cb, 0, NULL},
+	{N_("/---"),			NULL, NULL,		0, "<Separator>"},
+	{N_("/_Save as..."),		NULL, summary_save_as,	0, NULL},
+	{N_("/_Print..."),		NULL, summary_print,	0, NULL},
+	{N_("/---"),			NULL, NULL,		0, "<Separator>"},
+	{N_("/Select _all"),		NULL, summary_select_all, 0, NULL}
+};
+
+SummaryView *summary_create(void)
+{
+	SummaryView *summaryview;
+	gchar *titles[N_SUMMARY_COLS] = {_("M"), _("U")};
+	GtkWidget *vbox;
+	GtkWidget *scrolledwin;
+	GtkWidget *ctree;
+	GtkWidget *hbox;
+	GtkWidget *statlabel_folder;
+	GtkWidget *statlabel_select;
+	GtkWidget *statlabel_msgs;
+	GtkWidget *toggle_eventbox;
+	GtkWidget *toggle_arrow;
+	GtkWidget *popupmenu;
+	GtkItemFactory *popupfactory;
+	gint n_entries;
+	gint i;
+
+	debug_print(_("Creating summary view...\n"));
+	summaryview = g_new0(SummaryView, 1);
+
+	vbox = gtk_vbox_new(FALSE, 2);
+
+	scrolledwin = gtk_scrolled_window_new(NULL, NULL);
+	gtk_scrolled_window_set_policy(GTK_SCROLLED_WINDOW(scrolledwin),
+				       GTK_POLICY_AUTOMATIC,
+				       GTK_POLICY_ALWAYS);
+	gtk_box_pack_start(GTK_BOX(vbox), scrolledwin, TRUE, TRUE, 0);
+	gtk_widget_set_usize(vbox,
+			     prefs_common.summaryview_width,
+			     prefs_common.summaryview_height);
+
+	if (prefs_common.trans_hdr) {
+		titles[S_COL_NUMBER]  = _("No.");
+		titles[S_COL_DATE]    = _("Date");
+		titles[S_COL_FROM]    = _("From");
+		titles[S_COL_SUBJECT] = _("Subject");
+	} else {
+		titles[S_COL_NUMBER]  = "No.";
+		titles[S_COL_DATE]    = "Date";
+		titles[S_COL_FROM]    = "From";
+		titles[S_COL_SUBJECT] = "Subject";
+	}
+	titles[S_COL_SIZE] = _("Size");
+
+	ctree = gtk_sctree_new_with_titles(N_SUMMARY_COLS, S_COL_SUBJECT, titles);
+	gtk_scrolled_window_set_hadjustment(GTK_SCROLLED_WINDOW(scrolledwin),
+					    GTK_CLIST(ctree)->hadjustment);
+	gtk_scrolled_window_set_vadjustment(GTK_SCROLLED_WINDOW(scrolledwin),
+					    GTK_CLIST(ctree)->vadjustment);
+	gtk_container_add(GTK_CONTAINER(scrolledwin), ctree);
+	gtk_clist_set_selection_mode(GTK_CLIST(ctree), GTK_SELECTION_EXTENDED);
+	gtk_clist_set_column_justification(GTK_CLIST(ctree), S_COL_MARK,
+					   GTK_JUSTIFY_CENTER);
+	gtk_clist_set_column_justification(GTK_CLIST(ctree), S_COL_UNREAD,
+					   GTK_JUSTIFY_CENTER);
+	gtk_clist_set_column_justification(GTK_CLIST(ctree), S_COL_MIME,
+					   GTK_JUSTIFY_CENTER);
+	gtk_clist_set_column_justification(GTK_CLIST(ctree), S_COL_NUMBER,
+					   GTK_JUSTIFY_RIGHT);
+	gtk_clist_set_column_justification(GTK_CLIST(ctree), S_COL_SIZE,
+					   GTK_JUSTIFY_RIGHT);
+	gtk_clist_set_column_width(GTK_CLIST(ctree), S_COL_MARK,
+				   SUMMARY_COL_MARK_WIDTH);
+	gtk_clist_set_column_width(GTK_CLIST(ctree), S_COL_UNREAD,
+				   SUMMARY_COL_UNREAD_WIDTH);
+	gtk_clist_set_column_width(GTK_CLIST(ctree), S_COL_MIME,
+				   SUMMARY_COL_MIME_WIDTH);
+	gtk_clist_set_column_width(GTK_CLIST(ctree), S_COL_NUMBER,
+				   prefs_common.summary_col_number);
+	gtk_clist_set_column_width(GTK_CLIST(ctree), S_COL_SIZE,
+				   prefs_common.summary_col_size);
+	gtk_clist_set_column_width(GTK_CLIST(ctree), S_COL_DATE,
+				   prefs_common.summary_col_date);
+	gtk_clist_set_column_width(GTK_CLIST(ctree), S_COL_FROM,
+				   prefs_common.summary_col_from);
+	gtk_clist_set_column_width(GTK_CLIST(ctree), S_COL_SUBJECT,
+				   prefs_common.summary_col_subject);
+	gtk_ctree_set_line_style(GTK_CTREE(ctree), GTK_CTREE_LINES_DOTTED);
+	gtk_ctree_set_expander_style(GTK_CTREE(ctree),
+				     GTK_CTREE_EXPANDER_SQUARE);
+#if 0
+	gtk_ctree_set_line_style(GTK_CTREE(ctree), GTK_CTREE_LINES_NONE);
+	gtk_ctree_set_expander_style(GTK_CTREE(ctree),
+				     GTK_CTREE_EXPANDER_TRIANGLE);
+#endif
+	gtk_ctree_set_indent(GTK_CTREE(ctree), 18);
+	gtk_object_set_user_data(GTK_OBJECT(ctree), summaryview);
+
+	/* don't let title buttons take key focus */
+	for (i = 0; i < N_SUMMARY_COLS; i++)
+		GTK_WIDGET_UNSET_FLAGS(GTK_CLIST(ctree)->column[i].button,
+				       GTK_CAN_FOCUS);
+
+	/* connect signal to the buttons for sorting */
+#define CLIST_BUTTON_SIGNAL_CONNECT(col, func) \
+	gtk_signal_connect \
+		(GTK_OBJECT(GTK_CLIST(ctree)->column[col].button), \
+		 "clicked", \
+		 GTK_SIGNAL_FUNC(func), \
+		 summaryview)
+
+	CLIST_BUTTON_SIGNAL_CONNECT(S_COL_MARK   , summary_mark_clicked);
+	CLIST_BUTTON_SIGNAL_CONNECT(S_COL_UNREAD , summary_unread_clicked);
+	CLIST_BUTTON_SIGNAL_CONNECT(S_COL_MIME   , summary_mime_clicked);
+	CLIST_BUTTON_SIGNAL_CONNECT(S_COL_NUMBER , summary_num_clicked);
+	CLIST_BUTTON_SIGNAL_CONNECT(S_COL_SIZE   , summary_size_clicked);
+	CLIST_BUTTON_SIGNAL_CONNECT(S_COL_DATE   , summary_date_clicked);
+	CLIST_BUTTON_SIGNAL_CONNECT(S_COL_FROM   , summary_from_clicked);
+	CLIST_BUTTON_SIGNAL_CONNECT(S_COL_SUBJECT, summary_subject_clicked);
+
+#undef CLIST_BUTTON_SIGNAL_CONNECT
+
+	/* create status label */
+	hbox = gtk_hbox_new(FALSE, 0);
+	gtk_box_pack_end(GTK_BOX(vbox), hbox, FALSE, FALSE, 0);
+
+	statlabel_folder = gtk_label_new("");
+	gtk_box_pack_start(GTK_BOX(hbox), statlabel_folder, FALSE, FALSE, 2);
+	statlabel_select = gtk_label_new("");
+	gtk_box_pack_start(GTK_BOX(hbox), statlabel_select, FALSE, FALSE, 16);
+
+	/* toggle view button */
+	toggle_eventbox = gtk_event_box_new();
+	gtk_box_pack_end(GTK_BOX(hbox), toggle_eventbox, FALSE, FALSE, 4);
+	toggle_arrow = gtk_arrow_new(GTK_ARROW_DOWN, GTK_SHADOW_OUT);
+	gtk_container_add(GTK_CONTAINER(toggle_eventbox), toggle_arrow);
+
+	statlabel_msgs = gtk_label_new("");
+	gtk_box_pack_end(GTK_BOX(hbox), statlabel_msgs, FALSE, FALSE, 4);
+
+	/* create popup menu */
+	n_entries = sizeof(summary_popup_entries) /
+		sizeof(summary_popup_entries[0]);
+	popupmenu = menu_create_items(summary_popup_entries, n_entries,
+				      "<SummaryView>", &popupfactory,
+				      summaryview);
+
+	/* connect signals */
+	gtk_signal_connect(GTK_OBJECT(ctree), "tree_select_row",
+			   GTK_SIGNAL_FUNC(summary_selected), summaryview);
+	gtk_signal_connect(GTK_OBJECT(ctree), "button_press_event",
+			   GTK_SIGNAL_FUNC(summary_button_pressed),
+			   summaryview);
+	gtk_signal_connect(GTK_OBJECT(ctree), "button_release_event",
+			   GTK_SIGNAL_FUNC(summary_button_released),
+			   summaryview);
+	gtk_signal_connect(GTK_OBJECT(ctree), "key_press_event",
+			   GTK_SIGNAL_FUNC(summary_key_pressed), summaryview);
+	gtk_signal_connect(GTK_OBJECT(ctree), "resize_column",
+			   GTK_SIGNAL_FUNC(summary_col_resized), summaryview);
+        gtk_signal_connect(GTK_OBJECT(ctree), "open_row",
+			   GTK_SIGNAL_FUNC(summary_open_row), summaryview);
+
+	gtk_signal_connect_after(GTK_OBJECT(ctree), "tree_expand",
+				 GTK_SIGNAL_FUNC(summary_tree_expanded),
+				 summaryview);
+	gtk_signal_connect_after(GTK_OBJECT(ctree), "tree_collapse",
+				 GTK_SIGNAL_FUNC(summary_tree_collapsed),
+				 summaryview);
+
+	gtk_signal_connect(GTK_OBJECT(ctree), "start_drag",
+			   GTK_SIGNAL_FUNC(summary_start_drag),
+			   summaryview);
+	gtk_signal_connect(GTK_OBJECT(ctree), "drag_data_get",
+			   GTK_SIGNAL_FUNC(summary_drag_data_get),
+			   summaryview);
+
+	gtk_signal_connect(GTK_OBJECT(toggle_eventbox), "button_press_event",
+			   GTK_SIGNAL_FUNC(summary_toggle_pressed),
+			   summaryview);
+
+	summaryview->vbox = vbox;
+	summaryview->scrolledwin = scrolledwin;
+	summaryview->ctree = ctree;
+	summaryview->hbox = hbox;
+	summaryview->statlabel_folder = statlabel_folder;
+	summaryview->statlabel_select = statlabel_select;
+	summaryview->statlabel_msgs = statlabel_msgs;
+	summaryview->toggle_eventbox = toggle_eventbox;
+	summaryview->toggle_arrow = toggle_arrow;
+	summaryview->popupmenu = popupmenu;
+	summaryview->popupfactory = popupfactory;
+	summaryview->msg_is_toggled_on = TRUE;
+	summaryview->sort_mode = SORT_BY_NONE;
+	summaryview->sort_type = GTK_SORT_ASCENDING;
+
+	summary_change_display_item(summaryview);
+
+	gtk_widget_show_all(vbox);
+
+	return summaryview;
+}
+
+void summary_init(SummaryView *summaryview)
+{
+	GtkStyle *style;
+	GtkWidget *pixmap;
+
+	PIXMAP_CREATE(summaryview->ctree, markxpm, markxpmmask, mark_xpm);
+	PIXMAP_CREATE(summaryview->ctree, deletedxpm, deletedxpmmask,
+		      deleted_xpm);
+	PIXMAP_CREATE(summaryview->ctree, newxpm, newxpmmask, new_xpm);
+	PIXMAP_CREATE(summaryview->ctree, unreadxpm, unreadxpmmask, unread_xpm);
+	PIXMAP_CREATE(summaryview->ctree, repliedxpm, repliedxpmmask,
+		      replied_xpm);
+	PIXMAP_CREATE(summaryview->ctree, forwardedxpm, forwardedxpmmask,
+		      forwarded_xpm);
+	PIXMAP_CREATE(summaryview->ctree, clipxpm, clipxpmmask, clip_xpm);
+	PIXMAP_CREATE(summaryview->hbox, folderxpm, folderxpmmask,
+		      dir_open_xpm);
+
+	pixmap = gtk_pixmap_new(clipxpm, clipxpmmask);
+	gtk_clist_set_column_widget(GTK_CLIST(summaryview->ctree),
+				    S_COL_MIME, pixmap);
+	gtk_widget_show(pixmap);
+
+	if (!bold_style) {
+		bold_style = gtk_style_copy
+			(gtk_widget_get_style(summaryview->ctree));
+		if (!boldfont)
+			boldfont = gdk_fontset_load(prefs_common.boldfont);
+		bold_style->font = boldfont;
+		bold_marked_style = gtk_style_copy(bold_style);
+		bold_marked_style->fg[GTK_STATE_NORMAL] =
+			summaryview->color_marked;
+		bold_deleted_style = gtk_style_copy(bold_style);
+		bold_deleted_style->fg[GTK_STATE_NORMAL] =
+			summaryview->color_dim;
+	}
+
+	if (!smallfont)
+		smallfont = gdk_fontset_load(prefs_common.smallfont);
+
+	style = gtk_style_copy(gtk_widget_get_style
+				(summaryview->statlabel_folder));
+	if (smallfont) style->font = smallfont;
+	gtk_widget_set_style(summaryview->statlabel_folder, style);
+	gtk_widget_set_style(summaryview->statlabel_select, style);
+	gtk_widget_set_style(summaryview->statlabel_msgs, style);
+
+	pixmap = gtk_pixmap_new(folderxpm, folderxpmmask);
+	gtk_box_pack_start(GTK_BOX(summaryview->hbox), pixmap, FALSE, FALSE, 4);
+	gtk_box_reorder_child(GTK_BOX(summaryview->hbox), pixmap, 0);
+	gtk_widget_show(pixmap);
+
+	summary_clear_list(summaryview);
+	summary_colorlabel_menu_create(summaryview);
+	summary_set_menu_sensitive(summaryview);
+}
+
+gboolean summary_show(SummaryView *summaryview, FolderItem *item,
+		      gboolean update_cache)
+{
+	GtkCTree *ctree = GTK_CTREE(summaryview->ctree);
+	GtkCTreeNode *node;
+	GSList *mlist = NULL;
+	gchar *buf;
+	gboolean is_refresh;
+	guint selected_msgnum = 0;
+	guint displayed_msgnum = 0;
+	GtkCTreeNode *selected_node = summaryview->folderview->selected;
+	static gboolean locked = FALSE;
+
+	if (locked)
+		return FALSE;
+
+	inc_lock();
+	locked = TRUE;
+
+	STATUSBAR_POP(summaryview->mainwin);
+
+	is_refresh = (!prefs_common.open_inbox_on_inc &&
+		      item == summaryview->folder_item &&
+		      update_cache == FALSE) ? TRUE : FALSE;
+	if (is_refresh) {
+		selected_msgnum = summary_get_msgnum(summaryview,
+						     summaryview->selected);
+		displayed_msgnum = summary_get_msgnum(summaryview,
+						      summaryview->displayed);
+	}
+
+	/* process the marks if any */
+	if (summaryview->mainwin->lock_count == 0 &&
+	    (summaryview->moved > 0 || summaryview->copied > 0)) {
+		AlertValue val;
+
+		val = alertpanel(_("Process mark"),
+				 _("Some marks are left. Process it?"),
+				 _("Yes"), _("No"), _("Cancel"));
+		if (G_ALERTDEFAULT == val)
+			summary_execute(summaryview);
+		else if (G_ALERTALTERNATE == val)
+			summary_write_cache(summaryview);
+		else {
+			locked = FALSE;
+			inc_unlock();
+			return FALSE;
+		}
+	} else
+		summary_write_cache(summaryview);
+
+	summaryview->folderview->opened = selected_node;
+
+	gtk_clist_freeze(GTK_CLIST(ctree));
+
+	summary_clear_list(summaryview);
+	summary_set_menu_sensitive(summaryview);
+	if (!is_refresh)
+		messageview_clear(summaryview->messageview);
+
+	buf = NULL;
+	if (!item || !item->path || !item->parent || item->no_select ||
+	    (item->folder->type == F_MH &&
+	     ((buf = folder_item_get_path(item)) == NULL ||
+	      change_dir(buf) < 0))) {
+		g_free(buf);
+		debug_print(_("empty folder\n\n"));
+		if (is_refresh)
+			messageview_clear(summaryview->messageview);
+		summary_clear_all(summaryview);
+		summaryview->folder_item = item;
+		gtk_clist_thaw(GTK_CLIST(ctree));
+		locked = FALSE;
+		inc_unlock();
+		return TRUE;
+	}
+	g_free(buf);
+
+	summaryview->folder_item = item;
+
+	gtk_signal_handler_block_by_data(GTK_OBJECT(ctree), summaryview);
+
+	buf = g_strdup_printf(_("Scanning folder (%s)..."), item->path);
+	debug_print("%s\n", buf);
+	STATUSBAR_PUSH(summaryview->mainwin, buf);
+	g_free(buf);
+
+	main_window_cursor_wait(summaryview->mainwin);
+
+	mlist = item->folder->get_msg_list(item->folder, item, !update_cache);
+
+	STATUSBAR_POP(summaryview->mainwin);
+
+	/* set ctree and hash table from the msginfo list
+	   creating thread, and count the number of messages */
+	summary_set_ctree_from_list(summaryview, mlist);
+
+	g_slist_free(mlist);
+
+	summary_write_cache(summaryview);
+
+	gtk_signal_handler_unblock_by_data(GTK_OBJECT(ctree), summaryview);
+
+	gtk_clist_thaw(GTK_CLIST(ctree));
+
+	if (is_refresh) {
+		summaryview->displayed =
+			summary_find_msg_by_msgnum(summaryview,
+						   displayed_msgnum);
+		if (!summaryview->displayed)
+			messageview_clear(summaryview->messageview);
+		summary_select_by_msgnum(summaryview, selected_msgnum);
+		if (!summaryview->selected) {
+			/* no selected message - select first unread
+			   message, but do not display it */
+			node = summary_find_next_unread_msg(summaryview, NULL);
+			if (node == NULL && GTK_CLIST(ctree)->row_list != NULL)
+				node = GTK_CTREE_NODE
+					(GTK_CLIST(ctree)->row_list_end);
+			summary_select_node(summaryview, node, FALSE);
+		}
+	} else {
+		/* select first unread message */
+		node = summary_find_next_unread_msg(summaryview, NULL);
+		if (node == NULL && GTK_CLIST(ctree)->row_list != NULL)
+			node = GTK_CTREE_NODE(GTK_CLIST(ctree)->row_list_end);
+		summary_select_node(summaryview, node,
+				    prefs_common.open_unread_on_enter);
+	}
+
+	summary_status_show(summaryview);
+
+	summary_set_menu_sensitive(summaryview);
+
+	main_window_set_toolbar_sensitive(summaryview->mainwin);
+
+	debug_print("\n");
+	STATUSBAR_PUSH(summaryview->mainwin, _("Done."));
+
+	main_window_cursor_normal(summaryview->mainwin);
+	locked = FALSE;
+	inc_unlock();
+
+	return TRUE;
+}
+
+void summary_clear_list(SummaryView *summaryview)
+{
+	GtkCList *clist = GTK_CLIST(summaryview->ctree);
+	gint optimal_width;
+
+	gtk_clist_freeze(clist);
+
+	gtk_ctree_pre_recursive(GTK_CTREE(summaryview->ctree),
+				NULL, summary_free_msginfo_func, NULL);
+
+	summaryview->folder_item = NULL;
+
+	summaryview->display_msg = FALSE;
+
+	summaryview->selected  = NULL;
+	summaryview->displayed = NULL;
+	summaryview->newmsgs   = summaryview->unread     = 0;
+	summaryview->messages  = summaryview->total_size = 0;
+	summaryview->deleted   = summaryview->moved      = 0;
+	summaryview->copied    = 0;
+	if (summaryview->msgid_table) {
+		g_hash_table_destroy(summaryview->msgid_table);
+		summaryview->msgid_table = NULL;
+	}
+	summaryview->mlist = NULL;
+	if (summaryview->folder_table) {
+		g_hash_table_destroy(summaryview->folder_table);
+		summaryview->folder_table = NULL;
+	}
+	summaryview->sort_mode = SORT_BY_NONE;
+	summaryview->sort_type = GTK_SORT_ASCENDING;
+
+	gtk_clist_clear(clist);
+	optimal_width = gtk_clist_optimal_column_width(clist, S_COL_SUBJECT);
+	gtk_clist_set_column_width(clist, S_COL_SUBJECT, optimal_width);
+
+	gtk_clist_thaw(clist);
+}
+
+void summary_clear_all(SummaryView *summaryview)
+{
+	summary_clear_list(summaryview);
+	summary_set_menu_sensitive(summaryview);
+	main_window_set_toolbar_sensitive(summaryview->mainwin);
+	summary_status_show(summaryview);
+}
+
+SummarySelection summary_get_selection_type(SummaryView *summaryview)
+{
+	GtkCList *clist = GTK_CLIST(summaryview->ctree);
+	SummarySelection selection;
+
+	if (!clist->row_list)
+		selection = SUMMARY_NONE;
+	else if (!clist->selection)
+		selection = SUMMARY_SELECTED_NONE;
+	else if (!clist->selection->next)
+		selection = SUMMARY_SELECTED_SINGLE;
+	else
+		selection = SUMMARY_SELECTED_MULTIPLE;
+
+	return selection;
+}
+
+static void summary_set_menu_sensitive(SummaryView *summaryview)
+{
+	GtkItemFactory *ifactory = summaryview->popupfactory;
+	SummarySelection selection;
+	gboolean sens;
+
+	selection = summary_get_selection_type(summaryview);
+	main_window_set_menu_sensitive(summaryview->mainwin);
+
+	if (selection == SUMMARY_NONE) {
+		GtkWidget *submenu;
+
+		submenu = gtk_item_factory_get_widget
+			(summaryview->popupfactory, "/Mark");
+		menu_set_insensitive_all(GTK_MENU_SHELL(submenu));
+		menu_set_insensitive_all
+			(GTK_MENU_SHELL(summaryview->popupmenu));
+		return;
+	}
+
+	if (summaryview->folder_item->folder->type != F_NEWS) {
+		menu_set_sensitive(ifactory, "/Move...", TRUE);
+		menu_set_sensitive(ifactory, "/Copy...", TRUE);
+		if (summaryview->folder_item->stype != F_TRASH)
+			menu_set_sensitive(ifactory, "/Delete", TRUE);
+	}
+
+	menu_set_sensitive(ifactory, "/Execute", TRUE);
+
+	menu_set_sensitive(ifactory, "/Mark", TRUE);
+	menu_set_sensitive(ifactory, "/Mark/Mark",   TRUE);
+	menu_set_sensitive(ifactory, "/Mark/Unmark", TRUE);
+
+	menu_set_sensitive(ifactory, "/Mark/Mark as unread", TRUE);
+	menu_set_sensitive(ifactory, "/Mark/Mark as read",   TRUE);
+	menu_set_sensitive(ifactory, "/Mark/Mark all read",  TRUE);
+
+	menu_set_sensitive(ifactory, "/Color label", TRUE);
+
+	sens = (selection == SUMMARY_SELECTED_MULTIPLE) ? FALSE : TRUE;
+	menu_set_sensitive(ifactory, "/Reply",			  sens);
+	menu_set_sensitive(ifactory, "/Reply to sender",	  sens);
+	menu_set_sensitive(ifactory, "/Reply to all",		  sens);
+	menu_set_sensitive(ifactory, "/Forward",		  sens);
+	menu_set_sensitive(ifactory, "/Forward as attachment",	  sens);
+
+	menu_set_sensitive(ifactory, "/Add sender to address book", sens);
+
+	menu_set_sensitive(ifactory, "/Open in new window", sens);
+	menu_set_sensitive(ifactory, "/View source", sens);
+	menu_set_sensitive(ifactory, "/Show all header", sens);
+	if (summaryview->folder_item->stype == F_DRAFT ||
+	    summaryview->folder_item->stype == F_QUEUE)
+		menu_set_sensitive(ifactory, "/Re-edit", sens);
+
+	menu_set_sensitive(ifactory, "/Save as...", sens);
+	menu_set_sensitive(ifactory, "/Print...",   TRUE);
+
+	menu_set_sensitive(ifactory, "/Select all", TRUE);
+}
+
+void summary_select_prev_unread(SummaryView *summaryview)
+{
+	GtkCTreeNode *node;
+	GtkCTree *ctree = GTK_CTREE(summaryview->ctree);
+
+	node = summary_find_prev_unread_msg(summaryview, summaryview->selected);
+
+	if (!node) {
+		AlertValue val;
+
+		val = alertpanel(_("No more unread messages"),
+				 _("No unread message found. "
+				   "Search from the end?"),
+				 _("Yes"), _("No"), NULL);
+		if (val != G_ALERTDEFAULT) return;
+		node = summary_find_prev_unread_msg(summaryview, NULL);
+	}
+
+	if (!node) {
+		alertpanel_notice(_("No unread messages."));
+	} else {
+		gtkut_ctree_expand_parent_all(ctree, node);
+		gtk_sctree_unselect_all(GTK_SCTREE(ctree));
+		gtk_sctree_select(GTK_SCTREE(ctree), node);
+		if (summaryview->displayed == node)
+			summaryview->displayed = NULL;
+		summary_display_msg(summaryview, node, FALSE);
+	}
+}
+
+void summary_select_next_unread(SummaryView *summaryview)
+{
+	GtkCTreeNode *node;
+	GtkCTree *ctree = GTK_CTREE(summaryview->ctree);
+
+	node = summary_find_next_unread_msg(summaryview, summaryview->selected);
+
+	if (node) {
+		gtkut_ctree_expand_parent_all(ctree, node);
+		gtk_sctree_unselect_all(GTK_SCTREE(ctree));
+		gtk_sctree_select(GTK_SCTREE(ctree), node);
+		if (summaryview->displayed == node)
+			summaryview->displayed = NULL;
+		summary_display_msg(summaryview, node, FALSE);
+	} else {
+		AlertValue val;
+
+		val = alertpanel(_("No more unread messages"),
+				 _("No unread message found. "
+				   "Go to next folder?"),
+				 _("Yes"), _("No"), NULL);
+		if (val == G_ALERTDEFAULT) {
+			if (gtk_signal_n_emissions_by_name
+				(GTK_OBJECT(ctree), "key_press_event") > 0)
+					gtk_signal_emit_stop_by_name
+						(GTK_OBJECT(ctree),
+						 "key_press_event");
+			folderview_select_next_unread(summaryview->folderview);
+		}
+	}
+}
+
+void summary_select_prev_marked(SummaryView *summaryview)
+{
+	GtkCTreeNode *node;
+	GtkCTree *ctree = GTK_CTREE(summaryview->ctree);
+
+	node = summary_find_prev_marked_msg(summaryview, summaryview->selected);
+
+	if (!node) {
+		AlertValue val;
+
+		val = alertpanel(_("No more marked messages"),
+				 _("No marked message found. "
+				   "Search from the end?"),
+				 _("Yes"), _("No"), NULL);
+		if (val != G_ALERTDEFAULT) return;
+		node = summary_find_prev_marked_msg(summaryview, NULL);
+	}
+
+	if (!node) {
+		alertpanel_notice(_("No marked messages."));
+	} else {
+		gtkut_ctree_expand_parent_all(ctree, node);
+		gtk_sctree_unselect_all(GTK_SCTREE(ctree));
+		gtk_sctree_select(GTK_SCTREE(ctree), node);
+		if (summaryview->displayed == node)
+			summaryview->displayed = NULL;
+		summary_display_msg(summaryview, node, FALSE);
+	}
+}
+
+void summary_select_next_marked(SummaryView *summaryview)
+{
+	GtkCTreeNode *node;
+	GtkCTree *ctree = GTK_CTREE(summaryview->ctree);
+
+	node = summary_find_next_marked_msg(summaryview, summaryview->selected);
+
+	if (!node) {
+		AlertValue val;
+
+		val = alertpanel(_("No more marked messages"),
+				 _("No marked message found. "
+				   "Search from the beginning?"),
+				 _("Yes"), _("No"), NULL);
+		if (val != G_ALERTDEFAULT) return;
+		node = summary_find_next_marked_msg(summaryview, NULL);
+	}
+
+	if (!node) {
+		alertpanel_notice(_("No marked messages."));
+	} else {
+		gtkut_ctree_expand_parent_all(ctree, node);
+		gtk_sctree_unselect_all(GTK_SCTREE(ctree));
+		gtk_sctree_select(GTK_SCTREE(ctree), node);
+		if (summaryview->displayed == node)
+			summaryview->displayed = NULL;
+		summary_display_msg(summaryview, node, FALSE);
+	}
+}
+
+void summary_select_prev_labeled(SummaryView *summaryview)
+{
+	GtkCTreeNode *node;
+	GtkCTree *ctree = GTK_CTREE(summaryview->ctree);
+
+	node = summary_find_prev_labeled_msg(summaryview, summaryview->selected);
+
+	if (!node) {
+		AlertValue val;
+
+		val = alertpanel(_("No more labeled messages"),
+				 _("No labeled message found. "
+				   "Search from the end?"),
+				 _("Yes"), _("No"), NULL);
+		if (val != G_ALERTDEFAULT) return;
+		node = summary_find_prev_labeled_msg(summaryview, NULL);
+	}
+
+	if (!node) {
+		alertpanel_notice(_("No labeled messages."));
+	} else {
+		gtkut_ctree_expand_parent_all(ctree, node);
+		gtk_sctree_unselect_all(GTK_SCTREE(ctree));
+		gtk_sctree_select(GTK_SCTREE(ctree), node);
+		if (summaryview->displayed == node)
+			summaryview->displayed = NULL;
+		summary_display_msg(summaryview, node, FALSE);
+	}
+}
+
+void summary_select_next_labeled(SummaryView *summaryview)
+{
+	GtkCTreeNode *node;
+	GtkCTree *ctree = GTK_CTREE(summaryview->ctree);
+
+	node = summary_find_next_labeled_msg(summaryview, summaryview->selected);
+
+	if (!node) {
+		AlertValue val;
+
+		val = alertpanel(_("No more labeled messages"),
+				 _("No labeled message found. "
+				   "Search from the beginning?"),
+				 _("Yes"), _("No"), NULL);
+		if (val != G_ALERTDEFAULT) return;
+		node = summary_find_next_labeled_msg(summaryview, NULL);
+	}
+
+	if (!node) {
+		alertpanel_notice(_("No labeled messages."));
+	} else {
+		gtkut_ctree_expand_parent_all(ctree, node);
+		gtk_sctree_unselect_all(GTK_SCTREE(ctree));
+		gtk_sctree_select(GTK_SCTREE(ctree), node);
+		if (summaryview->displayed == node)
+			summaryview->displayed = NULL;
+		summary_display_msg(summaryview, node, FALSE);
+	}
+}
+
+void summary_select_by_msgnum(SummaryView *summaryview, guint msgnum)
+{
+	GtkCTreeNode *node;
+
+	node = summary_find_msg_by_msgnum(summaryview, msgnum);
+	summary_select_node(summaryview, node, FALSE);
+}
+
+/**
+ * summary_select_node:
+ * @summaryview: Summary view.
+ * @node: Summary tree node.
+ * @display_msg: TRUE to display the selected message.
+ *
+ * Select @node (bringing it into view by scrolling and expanding its
+ * thread, if necessary) and unselect all others.  If @display_msg is
+ * TRUE, display the corresponding message in the message view.
+ **/
+static void summary_select_node(SummaryView *summaryview, GtkCTreeNode *node,
+				gboolean display_msg)
+{
+	GtkCTree *ctree = GTK_CTREE(summaryview->ctree);
+
+	if (node) {
+		GTK_EVENTS_FLUSH();
+		gtkut_ctree_expand_parent_all(ctree, node);
+		gtk_ctree_node_moveto(ctree, node, -1, 0.5, 0);
+		gtk_widget_grab_focus(GTK_WIDGET(ctree));
+		gtk_sctree_unselect_all(GTK_SCTREE(ctree));
+		summaryview->display_msg = display_msg;
+		gtk_sctree_select(GTK_SCTREE(ctree), node);
+	}
+}
+
+static guint summary_get_msgnum(SummaryView *summaryview, GtkCTreeNode *node)
+{
+	GtkCTree *ctree = GTK_CTREE(summaryview->ctree);
+	MsgInfo *msginfo;
+
+	if (!node)
+		return 0;
+	msginfo = gtk_ctree_node_get_row_data(ctree, node);
+	return msginfo->msgnum;
+}
+
+static GtkCTreeNode *summary_find_prev_unread_msg(SummaryView *summaryview,
+						  GtkCTreeNode *current_node)
+{
+	GtkCTree *ctree = GTK_CTREE(summaryview->ctree);
+	GtkCTreeNode *node;
+	MsgInfo *msginfo;
+
+	if (current_node)
+		node = current_node;
+	else
+		node = GTK_CTREE_NODE(GTK_CLIST(ctree)->row_list_end);
+
+	for (; node != NULL; node = GTK_CTREE_NODE_PREV(node)) {
+		msginfo = gtk_ctree_node_get_row_data(ctree, node);
+		if (MSG_IS_UNREAD(msginfo->flags)) break;
+	}
+
+	return node;
+}
+
+static GtkCTreeNode *summary_find_next_unread_msg(SummaryView *summaryview,
+						  GtkCTreeNode *current_node)
+{
+	GtkCTree *ctree = GTK_CTREE(summaryview->ctree);
+	GtkCTreeNode *node;
+	MsgInfo *msginfo;
+
+	if (current_node)
+		node = current_node;
+	else
+		node = GTK_CTREE_NODE(GTK_CLIST(ctree)->row_list);
+
+	for (; node != NULL; node = gtkut_ctree_node_next(ctree, node)) {
+		msginfo = gtk_ctree_node_get_row_data(ctree, node);
+		if (MSG_IS_UNREAD(msginfo->flags)) break;
+	}
+
+	return node;
+}
+
+static GtkCTreeNode *summary_find_prev_marked_msg(SummaryView *summaryview,
+						  GtkCTreeNode *current_node)
+{
+	GtkCTree *ctree = GTK_CTREE(summaryview->ctree);
+	GtkCTreeNode *node;
+	MsgInfo *msginfo;
+
+	if (current_node)
+		node = GTK_CTREE_NODE_PREV(current_node);
+	else
+		node = GTK_CTREE_NODE(GTK_CLIST(ctree)->row_list_end);
+
+	for (; node != NULL; node = GTK_CTREE_NODE_PREV(node)) {
+		msginfo = gtk_ctree_node_get_row_data(ctree, node);
+		if (MSG_IS_MARKED(msginfo->flags)) break;
+	}
+
+	return node;
+}
+
+static GtkCTreeNode *summary_find_next_marked_msg(SummaryView *summaryview,
+						  GtkCTreeNode *current_node)
+{
+	GtkCTree *ctree = GTK_CTREE(summaryview->ctree);
+	GtkCTreeNode *node;
+	MsgInfo *msginfo;
+
+	if (current_node)
+		node = gtkut_ctree_node_next(ctree, current_node);
+	else
+		node = GTK_CTREE_NODE(GTK_CLIST(ctree)->row_list);
+
+	for (; node != NULL; node = gtkut_ctree_node_next(ctree, node)) {
+		msginfo = gtk_ctree_node_get_row_data(ctree, node);
+		if (MSG_IS_MARKED(msginfo->flags)) break;
+	}
+
+	return node;
+}
+
+static GtkCTreeNode *summary_find_prev_labeled_msg(SummaryView *summaryview,
+						   GtkCTreeNode *current_node)
+{
+	GtkCTree *ctree = GTK_CTREE(summaryview->ctree);
+	GtkCTreeNode *node;
+	MsgInfo *msginfo;
+
+	if (current_node)
+		node = GTK_CTREE_NODE_PREV(current_node);
+	else
+		node = GTK_CTREE_NODE(GTK_CLIST(ctree)->row_list_end);
+
+	for (; node != NULL; node = GTK_CTREE_NODE_PREV(node)) {
+		msginfo = gtk_ctree_node_get_row_data(ctree, node);
+		if (MSG_GET_COLORLABEL_VALUE(msginfo->flags) > 0) break;
+	}
+
+	return node;
+}
+
+static GtkCTreeNode *summary_find_next_labeled_msg(SummaryView *summaryview,
+						   GtkCTreeNode *current_node)
+{
+	GtkCTree *ctree = GTK_CTREE(summaryview->ctree);
+	GtkCTreeNode *node;
+	MsgInfo *msginfo;
+
+	if (current_node)
+		node = gtkut_ctree_node_next(ctree, current_node);
+	else
+		node = GTK_CTREE_NODE(GTK_CLIST(ctree)->row_list);
+
+	for (; node != NULL; node = gtkut_ctree_node_next(ctree, node)) {
+		msginfo = gtk_ctree_node_get_row_data(ctree, node);
+		if (MSG_GET_COLORLABEL_VALUE(msginfo->flags) > 0) break;
+	}
+
+	return node;
+}
+
+static GtkCTreeNode *summary_find_msg_by_msgnum(SummaryView *summaryview,
+						guint msgnum)
+{
+	GtkCTree *ctree = GTK_CTREE(summaryview->ctree);
+	GtkCTreeNode *node;
+	MsgInfo *msginfo;
+
+	node = GTK_CTREE_NODE(GTK_CLIST(ctree)->row_list);
+
+	for (; node != NULL; node = gtkut_ctree_node_next(ctree, node)) {
+		msginfo = gtk_ctree_node_get_row_data(ctree, node);
+		if (msginfo->msgnum == msgnum) break;
+	}
+
+	return node;
+}
+
+static guint attract_hash_func(gconstpointer key)
+{
+	gchar *str;
+	gchar *p;
+	guint h;
+
+	Xstrdup_a(str, (const gchar *)key, return 0);
+	trim_subject(str);
+
+	p = str;
+	h = *p;
+
+	if (h) {
+		for (p += 1; *p != '\0'; p++)
+			h = (h << 5) - h + *p;
+	}
+
+	return h;
+}
+
+static gint attract_compare_func(gconstpointer a, gconstpointer b)
+{
+	return subject_compare((const gchar *)a, (const gchar *)b) == 0;
+}
+
+void summary_attract_by_subject(SummaryView *summaryview)
+{
+	GtkCTree *ctree = GTK_CTREE(summaryview->ctree);
+	GtkCList *clist = GTK_CLIST(ctree);
+	GtkCTreeNode *src_node;
+	GtkCTreeNode *dst_node, *sibling;
+	GtkCTreeNode *tmp;
+	MsgInfo *src_msginfo, *dst_msginfo;
+	GHashTable *subject_table;
+
+	debug_print(_("Attracting messages by subject..."));
+	STATUSBAR_PUSH(summaryview->mainwin,
+		       _("Attracting messages by subject..."));
+
+	main_window_cursor_wait(summaryview->mainwin);
+	gtk_clist_freeze(clist);
+
+	subject_table = g_hash_table_new(attract_hash_func,
+					 attract_compare_func);
+
+	for (src_node = GTK_CTREE_NODE(clist->row_list);
+	     src_node != NULL;
+	     src_node = tmp) {
+		tmp = GTK_CTREE_ROW(src_node)->sibling;
+		src_msginfo = GTKUT_CTREE_NODE_GET_ROW_DATA(src_node);
+		if (!src_msginfo) continue;
+		if (!src_msginfo->subject) continue;
+
+		/* find attracting node */
+		dst_node = g_hash_table_lookup(subject_table,
+					       src_msginfo->subject);
+
+		if (dst_node) {
+			dst_msginfo = GTKUT_CTREE_NODE_GET_ROW_DATA(dst_node);
+
+			/* if the time difference is more than 20 days,
+			   don't attract */
+			if (ABS(src_msginfo->date_t - dst_msginfo->date_t)
+			    > 60 * 60 * 24 * 20)
+				continue;
+
+			sibling = GTK_CTREE_ROW(dst_node)->sibling;
+			if (src_node != sibling)
+				gtk_ctree_move(ctree, src_node, NULL, sibling);
+		}
+
+		g_hash_table_insert(subject_table,
+				    src_msginfo->subject, src_node);
+	}
+
+	g_hash_table_destroy(subject_table);
+
+	gtk_ctree_node_moveto(ctree, summaryview->selected, -1, 0.5, 0);
+
+	gtk_clist_thaw(clist);
+
+	debug_print(_("done.\n"));
+	STATUSBAR_POP(summaryview->mainwin);
+
+	main_window_cursor_normal(summaryview->mainwin);
+}
+
+static void summary_free_msginfo_func(GtkCTree *ctree, GtkCTreeNode *node,
+				      gpointer data)
+{
+	MsgInfo *msginfo = gtk_ctree_node_get_row_data(ctree, node);
+
+	if (msginfo)
+		procmsg_msginfo_free(msginfo);
+}
+
+static void summary_set_marks_func(GtkCTree *ctree, GtkCTreeNode *node,
+				   gpointer data)
+{
+	SummaryView *summaryview = data;
+	MsgInfo *msginfo;
+
+	msginfo = gtk_ctree_node_get_row_data(ctree, node);
+
+	if (MSG_IS_NEW(msginfo->flags))
+		summaryview->newmsgs++;
+	if (MSG_IS_UNREAD(msginfo->flags))
+		summaryview->unread++;
+	if (MSG_IS_DELETED(msginfo->flags))
+		summaryview->deleted++;
+
+	summaryview->messages++;
+	summaryview->total_size += msginfo->size;
+
+	summary_set_row_marks(summaryview, node);
+}
+
+static void summary_update_status(SummaryView *summaryview)
+{
+	GtkCTree *ctree = GTK_CTREE(summaryview->ctree);
+	GtkCTreeNode *node;
+	MsgInfo *msginfo;
+
+	summaryview->newmsgs = summaryview->unread =
+	summaryview->messages = summaryview->total_size =
+	summaryview->deleted = summaryview->moved = summaryview->copied = 0;
+
+	for (node = GTK_CTREE_NODE(GTK_CLIST(ctree)->row_list);
+	     node != NULL; node = gtkut_ctree_node_next(ctree, node)) {
+		msginfo = GTKUT_CTREE_NODE_GET_ROW_DATA(node);
+
+		if (MSG_IS_NEW(msginfo->flags))
+			summaryview->newmsgs++;
+		if (MSG_IS_UNREAD(msginfo->flags))
+			summaryview->unread++;
+		if (MSG_IS_DELETED(msginfo->flags))
+			summaryview->deleted++;
+		if (MSG_IS_MOVE(msginfo->flags))
+			summaryview->moved++;
+		if (MSG_IS_COPY(msginfo->flags))
+			summaryview->copied++;
+		summaryview->messages++;
+		summaryview->total_size += msginfo->size;
+	}
+}
+
+static void summary_status_show(SummaryView *summaryview)
+{
+	gchar *str;
+	gchar *del, *mv, *cp;
+	gchar *sel;
+	gchar *spc;
+	GList *rowlist, *cur;
+	guint n_selected = 0;
+	off_t sel_size = 0;
+	MsgInfo *msginfo;
+
+	if (!summaryview->folder_item) {
+		gtk_label_set(GTK_LABEL(summaryview->statlabel_folder), "");
+		gtk_label_set(GTK_LABEL(summaryview->statlabel_select), "");
+		gtk_label_set(GTK_LABEL(summaryview->statlabel_msgs),   "");
+		return;
+	}
+
+	rowlist = GTK_CLIST(summaryview->ctree)->selection;
+	for (cur = rowlist; cur != NULL; cur = cur->next) {
+		msginfo = gtk_ctree_node_get_row_data
+			(GTK_CTREE(summaryview->ctree),
+			 GTK_CTREE_NODE(cur->data));
+		sel_size += msginfo->size;
+		n_selected++;
+	}
+
+	gtk_label_set(GTK_LABEL(summaryview->statlabel_folder),
+		      summaryview->folder_item &&
+		      summaryview->folder_item->folder->type == F_NEWS
+		      ? g_basename(summaryview->folder_item->path)
+		      : summaryview->folder_item->path);
+
+	if (summaryview->deleted)
+		del = g_strdup_printf(_("%d deleted"), summaryview->deleted);
+	else
+		del = g_strdup("");
+	if (summaryview->moved)
+		mv = g_strdup_printf(_("%s%d moved"),
+				     summaryview->deleted ? _(", ") : "",
+				     summaryview->moved);
+	else
+		mv = g_strdup("");
+	if (summaryview->copied)
+		cp = g_strdup_printf(_("%s%d copied"),
+				     summaryview->deleted ||
+				     summaryview->moved ? _(", ") : "",
+				     summaryview->copied);
+	else
+		cp = g_strdup("");
+
+	if (summaryview->deleted || summaryview->moved || summaryview->copied)
+		spc = "    ";
+	else
+		spc = "";
+
+	if (n_selected)
+		sel = g_strdup_printf(" (%s)", to_human_readable(sel_size));
+	else
+		sel = g_strdup("");
+	str = g_strconcat(n_selected ? itos(n_selected) : "",
+			  n_selected ? _(" item(s) selected") : "",
+			  sel, spc, del, mv, cp, NULL);
+	gtk_label_set(GTK_LABEL(summaryview->statlabel_select), str);
+	g_free(str);
+	g_free(sel);
+	g_free(del);
+	g_free(mv);
+	g_free(cp);
+
+	if (summaryview->folder_item &&
+	    FOLDER_IS_LOCAL(summaryview->folder_item->folder)) {
+		str = g_strdup_printf(_("%d new, %d unread, %d total (%s)"),
+				      summaryview->newmsgs,
+				      summaryview->unread,
+				      summaryview->messages,
+				      to_human_readable(summaryview->total_size));
+	} else {
+		str = g_strdup_printf(_("%d new, %d unread, %d total"),
+				      summaryview->newmsgs,
+				      summaryview->unread,
+				      summaryview->messages);
+	}
+	gtk_label_set(GTK_LABEL(summaryview->statlabel_msgs), str);
+	g_free(str);
+
+	folderview_update_msg_num(summaryview->folderview,
+				  summaryview->folderview->opened,
+				  summaryview->newmsgs,
+				  summaryview->unread,
+				  summaryview->messages);
+}
+
+void summary_sort(SummaryView *summaryview, SummarySortType type)
+{
+	GtkCTree *ctree = GTK_CTREE(summaryview->ctree);
+	GtkCList *clist = GTK_CLIST(summaryview->ctree);
+	GtkCListCompareFunc cmp_func;
+
+	switch (type) {
+	case SORT_BY_MARK:
+		cmp_func = (GtkCListCompareFunc)summary_cmp_by_mark;
+		break;
+	case SORT_BY_UNREAD:
+		cmp_func = (GtkCListCompareFunc)summary_cmp_by_unread;
+		break;
+	case SORT_BY_MIME:
+		cmp_func = (GtkCListCompareFunc)summary_cmp_by_mime;
+		break;
+	case SORT_BY_NUMBER:
+		cmp_func = (GtkCListCompareFunc)summary_cmp_by_num;
+		break;
+	case SORT_BY_SIZE:
+		cmp_func = (GtkCListCompareFunc)summary_cmp_by_size;
+		break;
+	case SORT_BY_DATE:
+		cmp_func = (GtkCListCompareFunc)summary_cmp_by_date;
+		break;
+	case SORT_BY_FROM:
+		cmp_func = (GtkCListCompareFunc)summary_cmp_by_from;
+		break;
+	case SORT_BY_SUBJECT:
+		cmp_func = (GtkCListCompareFunc)summary_cmp_by_subject;
+		break;
+	case SORT_BY_LABEL:
+		cmp_func = (GtkCListCompareFunc)summary_cmp_by_label;
+		break;
+	default:
+		return;
+	}
+
+	debug_print(_("Sorting summary..."));
+	STATUSBAR_PUSH(summaryview->mainwin, _("Sorting summary..."));
+
+	main_window_cursor_wait(summaryview->mainwin);
+
+	gtk_clist_set_compare_func(clist, cmp_func);
+
+	/* toggle sort type if the same column is selected */
+	if (summaryview->sort_mode == type)
+		summaryview->sort_type =
+			summaryview->sort_type == GTK_SORT_ASCENDING
+			? GTK_SORT_DESCENDING : GTK_SORT_ASCENDING;
+	else
+		summaryview->sort_type = GTK_SORT_ASCENDING;
+	gtk_clist_set_sort_type(clist, summaryview->sort_type);
+	summaryview->sort_mode = type;
+
+	gtk_ctree_sort_node(ctree, NULL);
+
+	gtk_ctree_node_moveto(ctree, summaryview->selected, -1, 0.5, 0);
+	//gtkut_ctree_set_focus_row(ctree, summaryview->selected);
+
+	debug_print(_("done.\n"));
+	STATUSBAR_POP(summaryview->mainwin);
+
+	main_window_cursor_normal(summaryview->mainwin);
+}
+
+static void summary_set_ctree_from_list(SummaryView *summaryview,
+					GSList *mlist)
+{
+	GtkCTree *ctree = GTK_CTREE(summaryview->ctree);
+	MsgInfo *msginfo;
+	GtkCTreeNode *node, *parent;
+	gchar *text[N_SUMMARY_COLS];
+	GHashTable *msgid_table;
+
+	if (!mlist) return;
+
+	debug_print(_("\tSetting summary from message data..."));
+	STATUSBAR_PUSH(summaryview->mainwin,
+		       _("Setting summary from message data..."));
+	gdk_flush();
+
+	msgid_table = g_hash_table_new(g_str_hash, g_str_equal);
+	summaryview->msgid_table = msgid_table;
+
+	if (prefs_common.enable_thread) {
+		for (; mlist != NULL; mlist = mlist->next) {
+			msginfo = (MsgInfo *)mlist->data;
+			parent = NULL;
+
+			summary_set_header(text, msginfo);
+
+			/* search parent node for threading */
+			if (msginfo->inreplyto)
+				parent = g_hash_table_lookup
+					(msgid_table, msginfo->inreplyto);
+
+			node = gtk_ctree_insert_node
+				(ctree, parent, NULL, text, 2,
+				 NULL, NULL, NULL, NULL, FALSE,
+				 parent ? TRUE : FALSE);
+			GTKUT_CTREE_NODE_SET_ROW_DATA(node, msginfo);
+			summary_set_marks_func(ctree, node, summaryview);
+
+			/* preserve previous node if the message is
+			   duplicated */
+			if (msginfo->msgid &&
+			    g_hash_table_lookup(msgid_table, msginfo->msgid)
+			    == NULL)
+				g_hash_table_insert(msgid_table,
+						    msginfo->msgid, node);
+		}
+
+		/* complete the thread */
+		summary_thread_build(summaryview, TRUE);
+	} else {
+		for (; mlist != NULL; mlist = mlist->next) {
+			msginfo = (MsgInfo *)mlist->data;
+
+			summary_set_header(text, msginfo);
+
+			node = gtk_ctree_insert_node
+				(ctree, NULL, NULL, text, 2,
+				 NULL, NULL, NULL, NULL, FALSE, FALSE);
+			GTKUT_CTREE_NODE_SET_ROW_DATA(node, msginfo);
+			summary_set_marks_func(ctree, node, summaryview);
+
+			if (msginfo->msgid && *msginfo->msgid &&
+			    g_hash_table_lookup(msgid_table, msginfo->msgid)
+			    == NULL)
+				g_hash_table_insert(msgid_table,
+						    msginfo->msgid, node);
+		}
+	}
+
+	if (prefs_common.enable_hscrollbar) {
+		gint optimal_width;
+
+		optimal_width = gtk_clist_optimal_column_width
+			(GTK_CLIST(ctree), S_COL_SUBJECT);
+		gtk_clist_set_column_width(GTK_CLIST(ctree), S_COL_SUBJECT,
+					   optimal_width);
+	}
+
+	debug_print(_("done.\n"));
+	STATUSBAR_POP(summaryview->mainwin);
+	if (debug_mode)
+		debug_print("\tmsgid hash table size = %d\n",
+			    g_hash_table_size(msgid_table));
+}
+
+struct wcachefp
+{
+	FILE *cache_fp;
+	FILE *mark_fp;
+};
+
+gint summary_write_cache(SummaryView *summaryview)
+{
+	struct wcachefp fps;
+	GtkCTree *ctree = GTK_CTREE(summaryview->ctree);
+	gint ver = CACHE_VERSION;
+	gchar *buf;
+	gchar *cachefile, *markfile;
+
+	if (!summaryview->folder_item || !summaryview->folder_item->path)
+		return -1;
+
+	cachefile = folder_item_get_cache_file(summaryview->folder_item);
+	g_return_val_if_fail(cachefile != NULL, -1);
+	if ((fps.cache_fp = fopen(cachefile, "w")) == NULL) {
+		FILE_OP_ERROR(cachefile, "fopen");
+		g_free(cachefile);
+		return -1;
+	}
+	if (change_file_mode_rw(fps.cache_fp, cachefile) < 0)
+		FILE_OP_ERROR(cachefile, "chmod");
+	g_free(cachefile);
+
+	markfile = folder_item_get_mark_file(summaryview->folder_item);
+	if ((fps.mark_fp = fopen(markfile, "w")) == NULL) {
+		FILE_OP_ERROR(markfile, "fopen");
+		fclose(fps.cache_fp);
+		g_free(markfile);
+		return -1;
+	}
+	if (change_file_mode_rw(fps.mark_fp, markfile) < 0)
+		FILE_OP_ERROR(markfile, "chmod");
+	g_free(markfile);
+
+	buf = g_strdup_printf(_("Writing summary cache (%s)..."),
+			      summaryview->folder_item->path);
+	debug_print(buf);
+	STATUSBAR_PUSH(summaryview->mainwin, buf);
+	g_free(buf);
+
+	WRITE_CACHE_DATA_INT(ver, fps.cache_fp);
+	ver = MARK_VERSION;
+	WRITE_CACHE_DATA_INT(ver, fps.mark_fp);
+
+	gtk_ctree_pre_recursive(ctree, NULL, summary_write_cache_func, &fps);
+
+	fclose(fps.cache_fp);
+	fclose(fps.mark_fp);
+
+	debug_print(_("done.\n"));
+	STATUSBAR_POP(summaryview->mainwin);
+
+	return 0;
+}
+
+static void summary_write_cache_func(GtkCTree *ctree, GtkCTreeNode *node,
+				     gpointer data)
+{
+	struct wcachefp *fps = data;
+	MsgInfo *msginfo = gtk_ctree_node_get_row_data(ctree, node);
+
+	if (msginfo == NULL) return;
+
+	procmsg_write_cache(msginfo, fps->cache_fp);
+	procmsg_write_flags(msginfo, fps->mark_fp);
+}
+
+static void summary_set_header(gchar *text[], MsgInfo *msginfo)
+{
+	static gchar date_modified[80];
+	static gchar *to = NULL;
+
+	text[S_COL_MARK]   = NULL;
+	text[S_COL_UNREAD] = NULL;
+	text[S_COL_MIME]   = NULL;
+	text[S_COL_NUMBER] = itos(msginfo->msgnum);
+	text[S_COL_SIZE]   = to_human_readable(msginfo->size);
+
+	if (msginfo->date_t) {
+		procheader_date_get_localtime(date_modified,
+					      sizeof(date_modified),
+					      msginfo->date_t);
+		text[S_COL_DATE] = date_modified;
+	} else if (msginfo->date)
+		text[S_COL_DATE] = msginfo->date;
+	else
+		text[S_COL_DATE] = _("(No Date)");
+
+	text[S_COL_FROM] = msginfo->fromname ? msginfo->fromname :
+		_("(No From)");
+	if (prefs_common.swap_from && msginfo->from && msginfo->to &&
+	    cur_account && cur_account->address) {
+		gchar *from;
+
+		Xalloca(from, strlen(msginfo->from) + 1, return);
+		strcpy(from, msginfo->from);
+		extract_address(from);
+		if (!strcmp(from, cur_account->address)) {
+			g_free(to);
+			to = g_strconcat("-->", msginfo->to, NULL);
+			text[S_COL_FROM] = to;
+		}
+	}
+
+	text[S_COL_SUBJECT] = msginfo->subject ? msginfo->subject :
+		_("(No Subject)");
+}
+
+static void summary_display_msg(SummaryView *summaryview, GtkCTreeNode *row,
+				gboolean new_window)
+{
+	GtkCTree *ctree = GTK_CTREE(summaryview->ctree);
+	MsgInfo *msginfo;
+	gchar *filename;
+	static gboolean lock = FALSE;
+
+	if (!new_window && summaryview->displayed == row) return;
+	g_return_if_fail(row != NULL);
+
+	if (lock) return;
+	lock = TRUE;
+
+	STATUSBAR_POP(summaryview->mainwin);
+	GTK_EVENTS_FLUSH();
+
+	msginfo = gtk_ctree_node_get_row_data(ctree, row);
+
+	filename = procmsg_get_message_file(msginfo);
+	if (!filename) {
+		lock = FALSE;
+		return;
+	}
+	g_free(filename);
+
+	if (MSG_IS_NEW(msginfo->flags))
+		summaryview->newmsgs--;
+	if (MSG_IS_UNREAD(msginfo->flags))
+		summaryview->unread--;
+	if (MSG_IS_NEW(msginfo->flags) || MSG_IS_UNREAD(msginfo->flags)) {
+		MSG_UNSET_PERM_FLAGS(msginfo->flags, MSG_NEW | MSG_UNREAD);
+		summary_set_row_marks(summaryview, row);
+		gtk_clist_thaw(GTK_CLIST(ctree));
+		summary_status_show(summaryview);
+	}
+
+	if (new_window) {
+		MessageView *msgview;
+
+		msgview = messageview_create_with_new_window();
+		messageview_show(msgview, msginfo);
+	} else {
+		MessageView *msgview;
+
+		msgview = summaryview->messageview;
+
+		summaryview->displayed = row;
+		if (!summaryview->msg_is_toggled_on)
+			summary_toggle_view(summaryview);
+		messageview_show(msgview, msginfo);
+		if (msgview->type == MVIEW_TEXT ||
+		    (msgview->type == MVIEW_MIME &&
+		     GTK_CLIST(msgview->mimeview->ctree)->row_list == NULL))
+			gtk_widget_grab_focus(summaryview->ctree);
+		GTK_EVENTS_FLUSH();
+		gtkut_ctree_node_move_if_on_the_edge(ctree, row);
+	}
+
+	if (GTK_WIDGET_VISIBLE(summaryview->headerwin->window))
+		header_window_show(summaryview->headerwin, msginfo);
+
+	lock = FALSE;
+}
+
+void summary_redisplay_msg(SummaryView *summaryview)
+{
+	GtkCTreeNode *node;
+
+	if (summaryview->displayed) {
+		node = summaryview->displayed;
+		summaryview->displayed = NULL;
+		summary_display_msg(summaryview, node, FALSE);
+	}
+}
+
+void summary_open_msg(SummaryView *summaryview)
+{
+	if (!summaryview->selected) return;
+
+	summary_display_msg(summaryview, summaryview->selected, TRUE);
+}
+
+void summary_view_source(SummaryView * summaryview)
+{
+	GtkCTree *ctree = GTK_CTREE(summaryview->ctree);
+	MsgInfo *msginfo;
+	SourceWindow *srcwin;
+
+	if (!summaryview->selected) return;
+
+	srcwin = source_window_create();
+	msginfo = gtk_ctree_node_get_row_data(ctree, summaryview->selected);
+	source_window_show_msg(srcwin, msginfo);
+	source_window_show(srcwin);
+}
+
+void summary_reedit(SummaryView *summaryview)
+{
+	MsgInfo *msginfo;
+
+	if (!summaryview->selected) return;
+	if (!summaryview->folder_item) return;
+	if (summaryview->folder_item->stype != F_DRAFT &&
+	    summaryview->folder_item->stype != F_QUEUE) return;
+
+	msginfo = gtk_ctree_node_get_row_data(GTK_CTREE(summaryview->ctree),
+					      summaryview->selected);
+	if (!msginfo) return;
+
+	compose_reedit(msginfo);
+}
+
+void summary_step(SummaryView *summaryview, GtkScrollType type)
+{
+	GtkCTree *ctree = GTK_CTREE(summaryview->ctree);
+
+	if (type == GTK_SCROLL_STEP_FORWARD) {
+		GtkCTreeNode *node;
+		node = gtkut_ctree_node_next(ctree, summaryview->selected);
+		if (node)
+			gtkut_ctree_expand_parent_all(ctree, node);
+	}
+
+	gtk_signal_emit_by_name(GTK_OBJECT(ctree), "scroll_vertical",
+				type, 0.0);
+
+	if (summaryview->msg_is_toggled_on)
+		summary_display_msg(summaryview, summaryview->selected, FALSE);
+}
+
+static void summary_toggle_view(SummaryView *summaryview)
+{
+	MainWindow *mainwin = summaryview->mainwin;
+	union CompositeWin *cwin = &mainwin->win;
+	GtkWidget *vpaned = NULL;
+	GtkWidget *container = NULL;
+
+	switch (mainwin->type) {
+	case SEPARATE_NONE:
+		vpaned = cwin->sep_none.vpaned;
+		container = cwin->sep_none.hpaned;
+		break;
+	case SEPARATE_FOLDER:
+		vpaned = cwin->sep_folder.vpaned;
+		container = mainwin->vbox_body;
+		break;
+	case SEPARATE_MESSAGE:
+	case SEPARATE_BOTH:
+		return;
+	}
+
+	if (vpaned->parent != NULL) {
+		summaryview->msg_is_toggled_on = FALSE;
+		summaryview->displayed = NULL;
+		gtk_widget_ref(vpaned);
+		gtk_container_remove(GTK_CONTAINER(container), vpaned);
+		gtk_widget_reparent(GTK_WIDGET_PTR(summaryview), container);
+		gtk_arrow_set(GTK_ARROW(summaryview->toggle_arrow),
+			      GTK_ARROW_UP, GTK_SHADOW_OUT);
+	} else {
+		summaryview->msg_is_toggled_on = TRUE;
+		gtk_widget_reparent(GTK_WIDGET_PTR(summaryview), vpaned);
+		gtk_container_add(GTK_CONTAINER(container), vpaned);
+		gtk_widget_unref(vpaned);
+		gtk_arrow_set(GTK_ARROW(summaryview->toggle_arrow),
+			      GTK_ARROW_DOWN, GTK_SHADOW_OUT);
+	}
+
+	gtk_widget_grab_focus(summaryview->ctree);
+}
+
+static gboolean summary_search_unread_recursive(GtkCTree *ctree,
+						GtkCTreeNode *node)
+{
+	MsgInfo *msginfo;
+
+	if (node) {
+		msginfo = gtk_ctree_node_get_row_data(ctree, node);
+		if (msginfo && MSG_IS_UNREAD(msginfo->flags))
+			return TRUE;
+		node = GTK_CTREE_ROW(node)->children;
+	} else
+		node = GTK_CTREE_NODE(GTK_CLIST(ctree)->row_list);
+
+	while (node) {
+		if (summary_search_unread_recursive(ctree, node) == TRUE)
+			return TRUE;
+		node = GTK_CTREE_ROW(node)->sibling;
+	}
+
+	return FALSE;
+}
+
+static gboolean summary_have_unread_children(SummaryView *summaryview,
+					     GtkCTreeNode *node)
+{
+	GtkCTree *ctree = GTK_CTREE(summaryview->ctree);
+
+	if (!node) return FALSE;
+
+	node = GTK_CTREE_ROW(node)->children;
+
+	while (node) {
+		if (summary_search_unread_recursive(ctree, node) == TRUE)
+			return TRUE;
+		node = GTK_CTREE_ROW(node)->sibling;
+	}
+
+	return FALSE;
+}
+
+static void summary_set_row_marks(SummaryView *summaryview, GtkCTreeNode *row)
+{
+	GtkCTree *ctree = GTK_CTREE(summaryview->ctree);
+	GtkStyle *style = NULL;
+	MsgInfo *msginfo;
+	MsgFlags flags;
+
+	msginfo = gtk_ctree_node_get_row_data(ctree, row);
+	if (!msginfo) return;
+
+	flags = msginfo->flags;
+
+	gtk_ctree_node_set_foreground(ctree, row, NULL);
+
+	/* set new/unread column */
+	if (MSG_IS_NEW(flags)) {
+		gtk_ctree_node_set_pixmap(ctree, row, S_COL_UNREAD,
+					  newxpm, newxpmmask);
+	} else if (MSG_IS_UNREAD(flags)) {
+		gtk_ctree_node_set_pixmap(ctree, row, S_COL_UNREAD,
+					  unreadxpm, unreadxpmmask);
+	} else if (MSG_IS_REPLIED(flags)) {
+		gtk_ctree_node_set_pixmap(ctree, row, S_COL_UNREAD,
+					  repliedxpm, repliedxpmmask);
+	} else if (MSG_IS_FORWARDED(flags)) {
+		gtk_ctree_node_set_pixmap(ctree, row, S_COL_UNREAD,
+					  forwardedxpm, forwardedxpmmask);
+	} else {
+		gtk_ctree_node_set_text(ctree, row, S_COL_UNREAD, NULL);
+	}
+
+	if (prefs_common.bold_unread &&
+	    (MSG_IS_UNREAD(flags) ||
+	     (!GTK_CTREE_ROW(row)->expanded &&
+	      GTK_CTREE_ROW(row)->children &&
+	      summary_have_unread_children(summaryview, row))))
+		style = bold_style;
+
+	/* set mark column */
+	if (MSG_IS_DELETED(flags)) {
+		gtk_ctree_node_set_pixmap(ctree, row, S_COL_MARK,
+					  deletedxpm, deletedxpmmask);
+		if (style)
+			style = bold_deleted_style;
+		else
+			gtk_ctree_node_set_foreground
+				(ctree, row, &summaryview->color_dim);
+	} else if (MSG_IS_MARKED(flags)) {
+		gtk_ctree_node_set_pixmap(ctree, row, S_COL_MARK,
+					  markxpm, markxpmmask);
+	} else if (MSG_IS_MOVE(flags)) {
+		gtk_ctree_node_set_text(ctree, row, S_COL_MARK, "o");
+		if (style)
+			style = bold_marked_style;
+		else
+			gtk_ctree_node_set_foreground
+				(ctree, row, &summaryview->color_marked);
+	} else if (MSG_IS_COPY(flags)) {
+		gtk_ctree_node_set_text(ctree, row, S_COL_MARK, "O");
+		if (style)
+			style = bold_marked_style;
+		else
+			gtk_ctree_node_set_foreground
+				(ctree, row, &summaryview->color_marked);
+	} else {
+		gtk_ctree_node_set_text(ctree, row, S_COL_MARK, NULL);
+	}
+
+	if (MSG_IS_MIME(flags)) {
+		gtk_ctree_node_set_pixmap(ctree, row, S_COL_MIME,
+					  clipxpm, clipxpmmask);
+	} else {
+		gtk_ctree_node_set_text(ctree, row, S_COL_MIME, NULL);
+	}
+
+	gtk_ctree_node_set_row_style(ctree, row, style);
+
+	if (MSG_GET_COLORLABEL(flags))
+		summary_set_colorlabel_color(ctree, row,
+					     MSG_GET_COLORLABEL_VALUE(flags));
+}
+
+void summary_set_marks_selected(SummaryView *summaryview)
+{
+	summary_set_row_marks(summaryview, summaryview->selected);
+}
+
+static void summary_mark_row(SummaryView *summaryview, GtkCTreeNode *row)
+{
+	GtkCTree *ctree = GTK_CTREE(summaryview->ctree);
+	MsgInfo *msginfo;
+
+	msginfo = gtk_ctree_node_get_row_data(ctree, row);
+	msginfo->to_folder = NULL;
+	if (MSG_IS_DELETED(msginfo->flags))
+		summaryview->deleted--;
+	if (MSG_IS_MOVE(msginfo->flags))
+		summaryview->moved--;
+	if (MSG_IS_COPY(msginfo->flags))
+		summaryview->copied--;
+	MSG_UNSET_PERM_FLAGS(msginfo->flags, MSG_DELETED);
+	MSG_UNSET_TMP_FLAGS(msginfo->flags, MSG_MOVE | MSG_COPY);
+	MSG_SET_PERM_FLAGS(msginfo->flags, MSG_MARKED);
+	summary_set_row_marks(summaryview, row);
+	debug_print(_("Message %d is marked\n"), msginfo->msgnum);
+}
+
+void summary_mark(SummaryView *summaryview)
+{
+	GtkCTree *ctree = GTK_CTREE(summaryview->ctree);
+	GList *cur;
+
+	for (cur = GTK_CLIST(ctree)->selection; cur != NULL; cur = cur->next)
+		summary_mark_row(summaryview, GTK_CTREE_NODE(cur->data));
+
+	/* summary_step(summaryview, GTK_SCROLL_STEP_FORWARD); */
+}
+
+static void summary_mark_row_as_read(SummaryView *summaryview,
+				     GtkCTreeNode *row)
+{
+	GtkCTree *ctree = GTK_CTREE(summaryview->ctree);
+	MsgInfo *msginfo;
+
+	msginfo = gtk_ctree_node_get_row_data(ctree, row);
+	if (MSG_IS_NEW(msginfo->flags))
+		summaryview->newmsgs--;
+	if (MSG_IS_UNREAD(msginfo->flags))
+		summaryview->unread--;
+	if (MSG_IS_NEW(msginfo->flags) ||
+	    MSG_IS_UNREAD(msginfo->flags)) {
+		MSG_UNSET_PERM_FLAGS(msginfo->flags, MSG_NEW | MSG_UNREAD);
+		summary_set_row_marks(summaryview, row);
+		debug_print(_("Message %d is marked as being read\n"),
+			    msginfo->msgnum);
+	}
+}
+
+void summary_mark_as_read(SummaryView *summaryview)
+{
+	GtkCTree *ctree = GTK_CTREE(summaryview->ctree);
+	GList *cur;
+
+	for (cur = GTK_CLIST(ctree)->selection; cur != NULL; cur = cur->next)
+		summary_mark_row_as_read(summaryview,
+					 GTK_CTREE_NODE(cur->data));
+
+	summary_status_show(summaryview);
+}
+
+void summary_mark_all_read(SummaryView *summaryview)
+{
+	GtkCTree *ctree = GTK_CTREE(summaryview->ctree);
+	GtkCList *clist = GTK_CLIST(summaryview->ctree);
+	GtkCTreeNode *node;
+
+	gtk_clist_freeze(clist);
+	for (node = GTK_CTREE_NODE(GTK_CLIST(ctree)->row_list); node != NULL;
+	     node = gtkut_ctree_node_next(ctree, node))
+		summary_mark_row_as_read(summaryview, node);
+	for (node = GTK_CTREE_NODE(GTK_CLIST(ctree)->row_list); node != NULL;
+	     node = gtkut_ctree_node_next(ctree, node)) {
+		if (!GTK_CTREE_ROW(node)->expanded)
+			summary_set_row_marks(summaryview, node);
+	}
+	gtk_clist_thaw(clist);
+
+	summary_status_show(summaryview);
+}
+
+static void summary_mark_row_as_unread(SummaryView *summaryview,
+				       GtkCTreeNode *row)
+{
+	GtkCTree *ctree = GTK_CTREE(summaryview->ctree);
+	MsgInfo *msginfo;
+
+	msginfo = gtk_ctree_node_get_row_data(ctree, row);
+	if (MSG_IS_DELETED(msginfo->flags)) {
+		msginfo->to_folder = NULL;
+		MSG_UNSET_PERM_FLAGS(msginfo->flags, MSG_DELETED);
+		summaryview->deleted--;
+	}
+	MSG_UNSET_PERM_FLAGS(msginfo->flags, MSG_REPLIED | MSG_FORWARDED);
+	if (!MSG_IS_UNREAD(msginfo->flags)) {
+		MSG_SET_PERM_FLAGS(msginfo->flags, MSG_UNREAD);
+		summaryview->unread++;
+		debug_print(_("Message %d is marked as unread\n"),
+			    msginfo->msgnum);
+	}
+	summary_set_row_marks(summaryview, row);
+}
+
+void summary_mark_as_unread(SummaryView *summaryview)
+{
+	GtkCTree *ctree = GTK_CTREE(summaryview->ctree);
+	GList *cur;
+
+	for (cur = GTK_CLIST(ctree)->selection; cur != NULL; cur = cur->next)
+		summary_mark_row_as_unread(summaryview,
+					   GTK_CTREE_NODE(cur->data));
+
+	summary_status_show(summaryview);
+}
+
+static void summary_delete_row(SummaryView *summaryview, GtkCTreeNode *row)
+{
+	GtkCTree *ctree = GTK_CTREE(summaryview->ctree);
+	MsgInfo *msginfo;
+
+	msginfo = gtk_ctree_node_get_row_data(ctree, row);
+
+	if (MSG_IS_DELETED(msginfo->flags)) return;
+
+	msginfo->to_folder = NULL;
+	if (MSG_IS_MOVE(msginfo->flags))
+		summaryview->moved--;
+	if (MSG_IS_COPY(msginfo->flags))
+		summaryview->copied--;
+	MSG_UNSET_PERM_FLAGS(msginfo->flags, MSG_MARKED);
+	MSG_UNSET_TMP_FLAGS(msginfo->flags, MSG_MOVE | MSG_COPY);
+	MSG_SET_PERM_FLAGS(msginfo->flags, MSG_DELETED);
+	summaryview->deleted++;
+
+	if (!prefs_common.immediate_exec)
+		summary_set_row_marks(summaryview, row);
+
+	debug_print(_("Message %s/%d is set to delete\n"),
+		    msginfo->folder->path, msginfo->msgnum);
+}
+
+void summary_delete(SummaryView *summaryview)
+{
+	GtkCTree *ctree = GTK_CTREE(summaryview->ctree);
+	GList *cur;
+
+	if (!summaryview->folder_item ||
+	    summaryview->folder_item->folder->type == F_NEWS) return;
+
+	/* if current folder is trash, don't delete */
+	if (summaryview->folder_item->stype == F_TRASH) {
+		alertpanel_notice(_("Current folder is Trash."));
+		return;
+	}
+
+	for (cur = GTK_CLIST(ctree)->selection; cur != NULL; cur = cur->next)
+		summary_delete_row(summaryview, GTK_CTREE_NODE(cur->data));
+
+	summary_step(summaryview, GTK_SCROLL_STEP_FORWARD);
+
+	if (prefs_common.immediate_exec)
+		summary_execute(summaryview);
+	else
+		summary_status_show(summaryview);
+}
+
+void summary_delete_duplicated(SummaryView *summaryview)
+{
+	if (!summaryview->folder_item ||
+	    summaryview->folder_item->folder->type == F_NEWS) return;
+	if (summaryview->folder_item->stype == F_TRASH) return;
+
+	main_window_cursor_wait(summaryview->mainwin);
+	debug_print(_("Deleting duplicated messages..."));
+	STATUSBAR_PUSH(summaryview->mainwin,
+		       _("Deleting duplicated messages..."));
+
+	gtk_ctree_pre_recursive(GTK_CTREE(summaryview->ctree), NULL,
+				GTK_CTREE_FUNC(summary_delete_duplicated_func),
+				summaryview);
+
+	if (prefs_common.immediate_exec)
+		summary_execute(summaryview);
+	else
+		summary_status_show(summaryview);
+
+	debug_print(_("done.\n"));
+	STATUSBAR_POP(summaryview->mainwin);
+	main_window_cursor_normal(summaryview->mainwin);
+}
+
+static void summary_delete_duplicated_func(GtkCTree *ctree, GtkCTreeNode *node,
+					   SummaryView *summaryview)
+{
+	GtkCTreeNode *found;
+	MsgInfo *msginfo = GTK_CTREE_ROW(node)->row.data;
+
+	if (!msginfo->msgid || !*msginfo->msgid) return;
+
+	found = g_hash_table_lookup(summaryview->msgid_table, msginfo->msgid);
+
+	if (found && found != node)
+		summary_delete_row(summaryview, node);
+}
+
+static void summary_unmark_row(SummaryView *summaryview, GtkCTreeNode *row)
+{
+	GtkCTree *ctree = GTK_CTREE(summaryview->ctree);
+	MsgInfo *msginfo;
+
+	msginfo = gtk_ctree_node_get_row_data(ctree, row);
+	msginfo->to_folder = NULL;
+	if (MSG_IS_DELETED(msginfo->flags))
+		summaryview->deleted--;
+	if (MSG_IS_MOVE(msginfo->flags))
+		summaryview->moved--;
+	if (MSG_IS_COPY(msginfo->flags))
+		summaryview->copied--;
+	MSG_UNSET_PERM_FLAGS(msginfo->flags, MSG_MARKED | MSG_DELETED);
+	MSG_UNSET_TMP_FLAGS(msginfo->flags, MSG_MOVE | MSG_COPY);
+	summary_set_row_marks(summaryview, row);
+
+	debug_print(_("Message %s/%d is unmarked\n"),
+		    msginfo->folder->path, msginfo->msgnum);
+}
+
+void summary_unmark(SummaryView *summaryview)
+{
+	GtkCTree *ctree = GTK_CTREE(summaryview->ctree);
+	GList *cur;
+
+	for (cur = GTK_CLIST(ctree)->selection; cur != NULL;
+	     cur = cur->next)
+		summary_unmark_row(summaryview, GTK_CTREE_NODE(cur->data));
+
+	summary_status_show(summaryview);
+}
+
+static void summary_move_row_to(SummaryView *summaryview, GtkCTreeNode *row,
+				FolderItem *to_folder)
+{
+	GtkCTree *ctree = GTK_CTREE(summaryview->ctree);
+	MsgInfo *msginfo;
+
+	g_return_if_fail(to_folder != NULL);
+
+	msginfo = gtk_ctree_node_get_row_data(ctree, row);
+	msginfo->to_folder = to_folder;
+	if (MSG_IS_DELETED(msginfo->flags))
+		summaryview->deleted--;
+	MSG_UNSET_PERM_FLAGS(msginfo->flags, MSG_MARKED | MSG_DELETED);
+	MSG_UNSET_TMP_FLAGS(msginfo->flags, MSG_COPY);
+	if (!MSG_IS_MOVE(msginfo->flags)) {
+		MSG_SET_TMP_FLAGS(msginfo->flags, MSG_MOVE);
+		summaryview->moved++;
+	}
+	if (!prefs_common.immediate_exec)
+		summary_set_row_marks(summaryview, row);
+
+	debug_print(_("Message %d is set to move to %s\n"),
+		    msginfo->msgnum, to_folder->path);
+}
+
+void summary_move_selected_to(SummaryView *summaryview, FolderItem *to_folder)
+{
+	GList *cur;
+
+	if (!to_folder) return;
+	if (!summaryview->folder_item ||
+	    summaryview->folder_item->folder->type == F_NEWS) return;
+	if (summaryview->folder_item == to_folder) {
+		alertpanel_notice(_("Destination is same as current folder."));
+		return;
+	}
+
+	for (cur = GTK_CLIST(summaryview->ctree)->selection;
+	     cur != NULL; cur = cur->next)
+		summary_move_row_to
+			(summaryview, GTK_CTREE_NODE(cur->data), to_folder);
+
+	summary_step(summaryview, GTK_SCROLL_STEP_FORWARD);
+
+	if (prefs_common.immediate_exec)
+		summary_execute(summaryview);
+	else
+		summary_status_show(summaryview);
+}
+
+void summary_move_to(SummaryView *summaryview)
+{
+	FolderItem *to_folder;
+
+	if (!summaryview->folder_item ||
+	    summaryview->folder_item->folder->type == F_NEWS) return;
+
+	to_folder = foldersel_folder_sel(summaryview->folder_item->folder,
+					 NULL);
+	summary_move_selected_to(summaryview, to_folder);
+}
+
+static void summary_copy_row_to(SummaryView *summaryview, GtkCTreeNode *row,
+				FolderItem *to_folder)
+{
+	GtkCTree *ctree = GTK_CTREE(summaryview->ctree);
+	MsgInfo *msginfo;
+
+	g_return_if_fail(to_folder != NULL);
+
+	msginfo = gtk_ctree_node_get_row_data(ctree, row);
+	msginfo->to_folder = to_folder;
+	if (MSG_IS_DELETED(msginfo->flags))
+		summaryview->deleted--;
+	MSG_UNSET_PERM_FLAGS(msginfo->flags, MSG_MARKED | MSG_DELETED);
+	MSG_UNSET_TMP_FLAGS(msginfo->flags, MSG_MOVE);
+	if (!MSG_IS_COPY(msginfo->flags)) {
+		MSG_SET_TMP_FLAGS(msginfo->flags, MSG_COPY);
+		summaryview->copied++;
+	}
+	if (!prefs_common.immediate_exec)
+		summary_set_row_marks(summaryview, row);
+
+	debug_print(_("Message %d is set to copy to %s\n"),
+		    msginfo->msgnum, to_folder->path);
+}
+
+void summary_copy_selected_to(SummaryView *summaryview, FolderItem *to_folder)
+{
+	GList *cur;
+
+	if (!to_folder) return;
+	if (!summaryview->folder_item ||
+	    summaryview->folder_item->folder->type == F_NEWS) return;
+	if (summaryview->folder_item == to_folder) {
+		alertpanel_notice
+			(_("Destination to copy is same as current folder."));
+		return;
+	}
+
+	for (cur = GTK_CLIST(summaryview->ctree)->selection;
+	     cur != NULL; cur = cur->next)
+		summary_copy_row_to
+			(summaryview, GTK_CTREE_NODE(cur->data), to_folder);
+
+	summary_step(summaryview, GTK_SCROLL_STEP_FORWARD);
+
+	if (prefs_common.immediate_exec)
+		summary_execute(summaryview);
+	else
+		summary_status_show(summaryview);
+}
+
+void summary_copy_to(SummaryView *summaryview)
+{
+	FolderItem *to_folder;
+
+	if (!summaryview->folder_item ||
+	    summaryview->folder_item->folder->type == F_NEWS) return;
+
+	to_folder = foldersel_folder_sel(summaryview->folder_item->folder,
+					 NULL);
+	summary_copy_selected_to(summaryview, to_folder);
+}
+
+void summary_add_address(SummaryView *summaryview)
+{
+	MsgInfo *msginfo;
+	gchar *from;
+
+	msginfo = gtk_ctree_node_get_row_data(GTK_CTREE(summaryview->ctree),
+					      summaryview->selected);
+	if (!msginfo) return;
+
+	Xstrdup_a(from, msginfo->from, return);
+	eliminate_address_comment(from);
+	extract_address(from);
+	addressbook_add_contact(msginfo->fromname, from, NULL);
+}
+
+void summary_select_all(SummaryView *summaryview)
+{
+	if (summaryview->messages >= 500) {
+		STATUSBAR_PUSH(summaryview->mainwin,
+			       _("Selecting all messages..."));
+		main_window_cursor_wait(summaryview->mainwin);
+	}
+
+	gtk_clist_select_all(GTK_CLIST(summaryview->ctree));
+
+	if (summaryview->messages >= 500) {
+		STATUSBAR_POP(summaryview->mainwin);
+		main_window_cursor_normal(summaryview->mainwin);
+	}
+}
+
+void summary_unselect_all(SummaryView *summaryview)
+{
+	gtk_sctree_unselect_all(GTK_SCTREE(summaryview->ctree));
+}
+
+void summary_save_as(SummaryView *summaryview)
+{
+	GtkCTree *ctree = GTK_CTREE(summaryview->ctree);
+	MsgInfo *msginfo;
+	gchar *src, *dest;
+
+	if (!summaryview->selected) return;
+	msginfo = gtk_ctree_node_get_row_data(ctree, summaryview->selected);
+	if (!msginfo) return;
+
+	dest = filesel_select_file(_("Save as"), NULL);
+	if (!dest) return;
+	if (is_file_exist(dest)) {
+		AlertValue aval;
+
+		aval = alertpanel(_("Overwrite"),
+				  _("Overwrite existing file?"),
+				  _("OK"), _("Cancel"), NULL);
+		if (G_ALERTDEFAULT != aval) return;
+	}
+
+	src = procmsg_get_message_file(msginfo);
+	copy_file(src, dest);
+	g_free(src);
+}
+
+void summary_print(SummaryView *summaryview)
+{
+	GtkCTree *ctree = GTK_CTREE(summaryview->ctree);
+	GtkCList *clist = GTK_CLIST(summaryview->ctree);
+	MsgInfo *msginfo;
+	GList *cur;
+	gchar *cmdline;
+	gchar *p;
+
+	if (clist->selection == NULL) return;
+
+	cmdline = input_dialog(_("Print"),
+			       _("Enter the print command line:\n"
+				 "(`%s' will be replaced with file name)"),
+			       prefs_common.print_cmd);
+	if (!cmdline) return;
+	if (!(p = strchr(cmdline, '%')) || *(p + 1) != 's' ||
+	    strchr(p + 2, '%')) {
+		alertpanel_error(_("Print command line is invalid:\n`%s'"),
+				 cmdline);
+		g_free(cmdline);
+		return;
+	}
+
+	for (cur = clist->selection; cur != NULL; cur = cur->next) {
+		msginfo = gtk_ctree_node_get_row_data
+			(ctree, GTK_CTREE_NODE(cur->data));
+		if (msginfo) procmsg_print_message(msginfo, cmdline);
+	}
+
+	g_free(cmdline);
+}
+
+void summary_execute(SummaryView *summaryview)
+{
+	GtkCTree *ctree = GTK_CTREE(summaryview->ctree);
+	GtkCList *clist = GTK_CLIST(summaryview->ctree);
+	GtkCTreeNode *node, *next;
+
+	if (!summaryview->folder_item ||
+	    summaryview->folder_item->folder->type == F_NEWS) return;
+
+	gtk_clist_freeze(clist);
+
+	if (prefs_common.enable_thread)
+		summary_unthread_for_exec(summaryview);
+
+	summary_execute_move(summaryview);
+	summary_execute_copy(summaryview);
+	summary_execute_delete(summaryview);
+
+	node = GTK_CTREE_NODE(clist->row_list);
+	while (node != NULL) {
+		next = gtkut_ctree_node_next(ctree, node);
+		if (gtk_ctree_node_get_row_data(ctree, node) == NULL) {
+			if (node == summaryview->displayed) {
+				messageview_clear(summaryview->messageview);
+				summaryview->displayed = NULL;
+			}
+			if (GTK_CTREE_ROW(node)->children != NULL)
+				g_warning("summary_execute(): children != NULL\n");
+			else
+				gtk_ctree_remove_node(ctree, node);
+		}
+		node = next;
+	}
+
+	if (prefs_common.enable_thread)
+		summary_thread_build(summaryview, FALSE);
+
+	summaryview->selected = clist->selection ?
+		GTK_CTREE_NODE(clist->selection->data) : NULL;
+
+	if (!GTK_CLIST(summaryview->ctree)->row_list) {
+		menu_set_insensitive_all
+			(GTK_MENU_SHELL(summaryview->popupmenu));
+		gtk_widget_grab_focus(summaryview->folderview->ctree);
+	} else
+		gtk_widget_grab_focus(summaryview->ctree);
+
+	summary_update_status(summaryview);
+	summary_status_show(summaryview);
+
+	summary_write_cache(summaryview);
+
+	gtk_ctree_node_moveto(ctree, summaryview->selected, -1, 0.5, 0);
+
+	gtk_clist_thaw(clist);
+}
+
+static void summary_execute_move(SummaryView *summaryview)
+{
+	GtkCTree *ctree = GTK_CTREE(summaryview->ctree);
+	GSList *cur;
+
+	summaryview->folder_table = g_hash_table_new(NULL, NULL);
+
+	/* search moving messages and execute */
+	gtk_ctree_pre_recursive(ctree, NULL, summary_execute_move_func,
+				summaryview);
+
+	if (summaryview->mlist) {
+		procmsg_move_messages(summaryview->mlist);
+
+		folder_item_scan_foreach(summaryview->folder_table);
+		folderview_update_item_foreach(summaryview->folder_table);
+
+		for (cur = summaryview->mlist; cur != NULL; cur = cur->next)
+			procmsg_msginfo_free((MsgInfo *)cur->data);
+		g_slist_free(summaryview->mlist);
+		summaryview->mlist = NULL;
+	}
+
+	g_hash_table_destroy(summaryview->folder_table);
+	summaryview->folder_table = NULL;
+}
+
+static void summary_execute_move_func(GtkCTree *ctree, GtkCTreeNode *node,
+				      gpointer data)
+{
+	SummaryView *summaryview = data;
+	MsgInfo *msginfo;
+
+	msginfo = GTKUT_CTREE_NODE_GET_ROW_DATA(node);
+
+	if (msginfo && MSG_IS_MOVE(msginfo->flags) && msginfo->to_folder) {
+		g_hash_table_insert(summaryview->folder_table,
+				    msginfo->to_folder, GINT_TO_POINTER(1));
+
+		summaryview->mlist =
+			g_slist_append(summaryview->mlist, msginfo);
+		gtk_ctree_node_set_row_data(ctree, node, NULL);
+
+		if (msginfo->msgid && *msginfo->msgid &&
+		    node == g_hash_table_lookup(summaryview->msgid_table,
+						msginfo->msgid))
+			g_hash_table_remove(summaryview->msgid_table,
+					    msginfo->msgid);
+	}
+}
+
+static void summary_execute_copy(SummaryView *summaryview)
+{
+	GtkCTree *ctree = GTK_CTREE(summaryview->ctree);
+
+	summaryview->folder_table = g_hash_table_new(NULL, NULL);
+
+	/* search copying messages and execute */
+	gtk_ctree_pre_recursive(ctree, NULL, summary_execute_copy_func,
+				summaryview);
+
+	if (summaryview->mlist) {
+		procmsg_copy_messages(summaryview->mlist);
+
+		folder_item_scan_foreach(summaryview->folder_table);
+		folderview_update_item_foreach(summaryview->folder_table);
+
+		g_slist_free(summaryview->mlist);
+		summaryview->mlist = NULL;
+	}
+
+	g_hash_table_destroy(summaryview->folder_table);
+	summaryview->folder_table = NULL;
+}
+
+static void summary_execute_copy_func(GtkCTree *ctree, GtkCTreeNode *node,
+				      gpointer data)
+{
+	SummaryView *summaryview = data;
+	MsgInfo *msginfo;
+
+	msginfo = GTKUT_CTREE_NODE_GET_ROW_DATA(node);
+
+	if (msginfo && MSG_IS_COPY(msginfo->flags) && msginfo->to_folder) {
+		g_hash_table_insert(summaryview->folder_table,
+				    msginfo->to_folder, GINT_TO_POINTER(1));
+
+		summaryview->mlist =
+			g_slist_append(summaryview->mlist, msginfo);
+
+		MSG_UNSET_TMP_FLAGS(msginfo->flags, MSG_COPY);
+		summary_set_row_marks(summaryview, node);
+	}
+}
+
+static void summary_execute_delete(SummaryView *summaryview)
+{
+	GtkCTree *ctree = GTK_CTREE(summaryview->ctree);
+	FolderItem *trash;
+	GSList *cur;
+
+	trash = summaryview->folder_item->folder->trash;
+	if (summaryview->folder_item->folder->type == F_MH) {
+		g_return_if_fail(trash != NULL);
+	}
+	if (summaryview->folder_item == trash) return;
+
+	/* search deleting messages and execute */
+	gtk_ctree_pre_recursive
+		(ctree, NULL, summary_execute_delete_func, summaryview);
+
+	if (!summaryview->mlist) return;
+
+	folder_item_move_msgs_with_dest(trash, summaryview->mlist);
+
+	for (cur = summaryview->mlist; cur != NULL; cur = cur->next)
+		procmsg_msginfo_free((MsgInfo *)cur->data);
+
+	g_slist_free(summaryview->mlist);
+	summaryview->mlist = NULL;
+
+	folder_item_scan(trash);
+	folderview_update_item(trash, FALSE);
+}
+
+static void summary_execute_delete_func(GtkCTree *ctree, GtkCTreeNode *node,
+					gpointer data)
+{
+	SummaryView *summaryview = data;
+	MsgInfo *msginfo;
+
+	msginfo = GTKUT_CTREE_NODE_GET_ROW_DATA(node);
+
+	if (msginfo && MSG_IS_DELETED(msginfo->flags)) {
+		summaryview->mlist =
+			g_slist_append(summaryview->mlist, msginfo);
+		gtk_ctree_node_set_row_data(ctree, node, NULL);
+
+		if (msginfo->msgid && *msginfo->msgid &&
+		    node == g_hash_table_lookup(summaryview->msgid_table,
+						msginfo->msgid))
+			g_hash_table_remove(summaryview->msgid_table,
+					    msginfo->msgid);
+	}
+}
+
+/* thread functions */
+
+void summary_thread_build(SummaryView *summaryview, gboolean init)
+{
+	GtkCTree *ctree = GTK_CTREE(summaryview->ctree);
+	GtkCTreeNode *node;
+	GtkCTreeNode *next;
+	GtkCTreeNode *parent;
+	MsgInfo *msginfo;
+
+	debug_print(_("Building threads..."));
+	STATUSBAR_PUSH(summaryview->mainwin, _("Building threads..."));
+	main_window_cursor_wait(summaryview->mainwin);
+
+	gtk_signal_handler_block_by_func(GTK_OBJECT(ctree),
+					 summary_tree_expanded, summaryview);
+	gtk_clist_freeze(GTK_CLIST(ctree));
+
+	node = GTK_CTREE_NODE(GTK_CLIST(ctree)->row_list);
+	while (node) {
+		next = GTK_CTREE_ROW(node)->sibling;
+
+		msginfo = GTKUT_CTREE_NODE_GET_ROW_DATA(node);
+		if (msginfo && msginfo->inreplyto) {
+			parent = g_hash_table_lookup(summaryview->msgid_table,
+						     msginfo->inreplyto);
+			if (parent && parent != node) {
+				gtk_ctree_move(ctree, node, parent, NULL);
+				gtk_ctree_expand(ctree, node);
+			}
+		}
+
+		node = next;
+	}
+
+	node = GTK_CTREE_NODE(GTK_CLIST(ctree)->row_list);
+
+	/* for optimization */
+	if (init) {
+		if (prefs_common.expand_thread) {
+			while (node) {
+				next = GTK_CTREE_ROW(node)->sibling;
+				if (GTK_CTREE_ROW(node)->children)
+					gtk_ctree_expand(ctree, node);
+				node = next;
+			}
+		} else if (prefs_common.bold_unread) {
+			while (node) {
+				next = GTK_CTREE_ROW(node)->sibling;
+				if (GTK_CTREE_ROW(node)->children)
+					summary_set_row_marks
+						(summaryview, node);
+				node = next;
+			}
+		}
+	} else {
+		while (node) {
+			next = GTK_CTREE_NODE_NEXT(node);
+			if (prefs_common.expand_thread)
+				gtk_ctree_expand(ctree, node);
+			if (prefs_common.bold_unread &&
+			    GTK_CTREE_ROW(node)->children)
+				summary_set_row_marks(summaryview, node);
+			node = next;
+		}
+	}
+
+	gtk_clist_thaw(GTK_CLIST(ctree));
+	gtk_signal_handler_unblock_by_func(GTK_OBJECT(ctree),
+					   summary_tree_expanded, summaryview);
+
+	debug_print(_("done.\n"));
+	STATUSBAR_POP(summaryview->mainwin);
+	main_window_cursor_normal(summaryview->mainwin);
+}
+
+void summary_unthread(SummaryView *summaryview)
+{
+	GtkCTree *ctree = GTK_CTREE(summaryview->ctree);
+	GtkCTreeNode *node;
+	GtkCTreeNode *child;
+	GtkCTreeNode *sibling;
+	GtkCTreeNode *next_child;
+
+	debug_print(_("Unthreading..."));
+	STATUSBAR_PUSH(summaryview->mainwin, _("Unthreading..."));
+	main_window_cursor_wait(summaryview->mainwin);
+
+	gtk_signal_handler_block_by_func(GTK_OBJECT(ctree),
+					 summary_tree_collapsed, summaryview);
+	gtk_clist_freeze(GTK_CLIST(ctree));
+
+	for (node = GTK_CTREE_NODE(GTK_CLIST(ctree)->row_list);
+	     node != NULL; node = GTK_CTREE_NODE_NEXT(node)) {
+		child = GTK_CTREE_ROW(node)->children;
+		sibling = GTK_CTREE_ROW(node)->sibling;
+
+		while (child != NULL) {
+			next_child = GTK_CTREE_ROW(child)->sibling;
+			gtk_ctree_move(ctree, child, NULL, sibling);
+			child = next_child;
+		}
+	}
+
+	gtk_clist_thaw(GTK_CLIST(ctree));
+	gtk_signal_handler_unblock_by_func(GTK_OBJECT(ctree),
+					   summary_tree_collapsed, summaryview);
+
+	debug_print(_("done.\n"));
+	STATUSBAR_POP(summaryview->mainwin);
+	main_window_cursor_normal(summaryview->mainwin);
+}
+
+static void summary_unthread_for_exec(SummaryView *summaryview)
+{
+	GtkCTreeNode *node;
+	GtkCTree *ctree = GTK_CTREE(summaryview->ctree);
+
+	debug_print(_("Unthreading for execution..."));
+
+	gtk_clist_freeze(GTK_CLIST(ctree));
+
+	for (node = GTK_CTREE_NODE(GTK_CLIST(ctree)->row_list);
+	     node != NULL; node = GTK_CTREE_NODE_NEXT(node)) {
+		summary_unthread_for_exec_func(ctree, node, NULL);
+	}
+
+	gtk_clist_thaw(GTK_CLIST(ctree));
+
+	debug_print(_("done.\n"));
+}
+
+static void summary_unthread_for_exec_func(GtkCTree *ctree, GtkCTreeNode *node,
+					   gpointer data)
+{
+	MsgInfo *msginfo;
+	GtkCTreeNode *top_parent;
+	GtkCTreeNode *child;
+	GtkCTreeNode *sibling;
+
+	msginfo = GTKUT_CTREE_NODE_GET_ROW_DATA(node);
+
+	if (!msginfo ||
+	    (!MSG_IS_MOVE(msginfo->flags) &&
+	     !MSG_IS_DELETED(msginfo->flags)))
+		return;
+	child = GTK_CTREE_ROW(node)->children;
+	if (!child) return;
+
+	for (top_parent = node;
+	     GTK_CTREE_ROW(top_parent)->parent != NULL;
+	     top_parent = GTK_CTREE_ROW(top_parent)->parent)
+		;
+	sibling = GTK_CTREE_ROW(top_parent)->sibling;
+
+	while (child != NULL) {
+		GtkCTreeNode *next_child;
+
+		next_child = GTK_CTREE_ROW(child)->sibling;
+		gtk_ctree_move(ctree, child, NULL, sibling);
+		child = next_child;
+	}
+}
+
+void summary_filter(SummaryView *summaryview)
+{
+	if (!prefs_common.fltlist) return;
+
+	debug_print(_("filtering..."));
+	STATUSBAR_PUSH(summaryview->mainwin, _("Filtering..."));
+	main_window_cursor_wait(summaryview->mainwin);
+
+	gtk_clist_freeze(GTK_CLIST(summaryview->ctree));
+
+	gtk_ctree_pre_recursive(GTK_CTREE(summaryview->ctree), NULL,
+				GTK_CTREE_FUNC(summary_filter_func),
+				summaryview);
+
+	gtk_clist_thaw(GTK_CLIST(summaryview->ctree));
+
+	if (prefs_common.immediate_exec)
+		summary_execute(summaryview);
+	else
+		summary_status_show(summaryview);
+
+	debug_print(_("done.\n"));
+	STATUSBAR_POP(summaryview->mainwin);
+	main_window_cursor_normal(summaryview->mainwin);
+}
+
+static void summary_filter_func(GtkCTree *ctree, GtkCTreeNode *node,
+				gpointer data)
+{
+	MsgInfo *msginfo = GTKUT_CTREE_NODE_GET_ROW_DATA(node);
+	SummaryView *summaryview = data;
+	gchar *file;
+	FolderItem *dest;
+
+	file = procmsg_get_message_file_path(msginfo);
+	dest = filter_get_dest_folder(prefs_common.fltlist, file);
+	g_free(file);
+
+	if (dest && strcmp2(dest->path, FILTER_NOT_RECEIVE) != 0 &&
+	    summaryview->folder_item != dest)
+		summary_move_row_to(summaryview, node, dest);
+}
+
+/* color label */
+
+#define N_COLOR_LABELS colorlabel_get_color_count()
+
+static void summary_colorlabel_menu_item_activate_cb(GtkWidget *widget,
+						     gpointer data)
+{
+	guint color = GPOINTER_TO_UINT(data);
+	SummaryView *summaryview;
+
+	summaryview = gtk_object_get_data(GTK_OBJECT(widget), "summaryview");
+	g_return_if_fail(summaryview != NULL);
+
+	/* "dont_toggle" state set? */
+	if (gtk_object_get_data(GTK_OBJECT(summaryview->colorlabel_menu),
+				"dont_toggle"))
+		return;
+
+	summary_set_colorlabel(summaryview, color, NULL);
+}
+
+/* summary_set_colorlabel_color() - labelcolor parameter is the color *flag*
+ * for the messsage; not the color index */
+void summary_set_colorlabel_color(GtkCTree *ctree, GtkCTreeNode *node,
+				  guint labelcolor)
+{
+	GdkColor color;
+	GtkStyle *style, *prev_style, *ctree_style;
+	MsgInfo *msginfo;
+	gint color_index;
+
+	msginfo = gtk_ctree_node_get_row_data(ctree, node);
+	MSG_UNSET_PERM_FLAGS(msginfo->flags, MSG_CLABEL_FLAG_MASK);
+	MSG_SET_COLORLABEL_VALUE(msginfo->flags, labelcolor);
+
+	color_index = labelcolor == 0 ? -1 : (gint)labelcolor - 1;
+	ctree_style = gtk_widget_get_style(GTK_WIDGET(ctree));
+	prev_style = gtk_ctree_node_get_row_style(ctree, node);
+
+	if (color_index < 0 || color_index >= N_COLOR_LABELS) {
+		if (!prev_style) return;
+		style = gtk_style_copy(prev_style);
+		color = ctree_style->fg[GTK_STATE_NORMAL];
+		style->fg[GTK_STATE_NORMAL] = color;
+		color = ctree_style->fg[GTK_STATE_SELECTED];
+		style->fg[GTK_STATE_SELECTED] = color;
+	} else {
+		if (prev_style)
+			style = gtk_style_copy(prev_style);
+		else
+			style = gtk_style_copy(ctree_style);
+		color = colorlabel_get_color(color_index);
+		style->fg[GTK_STATE_NORMAL] = color;
+		/* get the average of label color and selected fg color
+		   for visibility */
+		style->fg[GTK_STATE_SELECTED].red   = (color.red   + ctree_style->fg[GTK_STATE_SELECTED].red  ) / 2;
+		style->fg[GTK_STATE_SELECTED].green = (color.green + ctree_style->fg[GTK_STATE_SELECTED].green) / 2;
+		style->fg[GTK_STATE_SELECTED].blue  = (color.blue  + ctree_style->fg[GTK_STATE_SELECTED].blue ) / 2;
+	}
+
+	gtk_ctree_node_set_row_style(ctree, node, style);
+}
+
+void summary_set_colorlabel(SummaryView *summaryview, guint labelcolor,
+			    GtkWidget *widget)
+{
+	GtkCTree *ctree = GTK_CTREE(summaryview->ctree);
+	GtkCList *clist = GTK_CLIST(summaryview->ctree);
+	GList *cur;
+
+	for (cur = clist->selection; cur != NULL; cur = cur->next)
+		summary_set_colorlabel_color(ctree, GTK_CTREE_NODE(cur->data),
+					     labelcolor);
+}
+
+static void summary_colorlabel_menu_item_activate_item_cb(GtkMenuItem *menuitem,
+							  gpointer data)
+{
+	SummaryView *summaryview;
+	GtkMenuShell *menu;
+	GtkCheckMenuItem **items;
+	gint n;
+	GList *cur, *sel;
+
+	summaryview = (SummaryView *)data;
+	g_return_if_fail(summaryview != NULL);
+
+	sel = GTK_CLIST(summaryview->ctree)->selection;
+	if (!sel) return;
+
+	menu = GTK_MENU_SHELL(summaryview->colorlabel_menu);
+	g_return_if_fail(menu != NULL);
+
+	Xalloca(items, (N_COLOR_LABELS + 1) * sizeof(GtkWidget *), return);
+
+	/* NOTE: don't return prematurely because we set the "dont_toggle"
+	 * state for check menu items */
+	gtk_object_set_data(GTK_OBJECT(menu), "dont_toggle",
+			    GINT_TO_POINTER(1));
+
+	/* clear items. get item pointers. */
+	for (n = 0, cur = menu->children; cur != NULL; cur = cur->next) {
+		if (GTK_IS_CHECK_MENU_ITEM(cur->data)) {
+			gtk_check_menu_item_set_state
+				(GTK_CHECK_MENU_ITEM(cur->data), FALSE);
+			items[n] = GTK_CHECK_MENU_ITEM(cur->data);
+			n++;
+		}
+	}
+
+	if (n == (N_COLOR_LABELS + 1)) {
+		/* iterate all messages and set the state of the appropriate
+		 * items */
+		for (; sel != NULL; sel = sel->next) {
+			MsgInfo *msginfo;
+			gint clabel;
+
+			msginfo = gtk_ctree_node_get_row_data
+				(GTK_CTREE(summaryview->ctree),
+				 GTK_CTREE_NODE(sel->data));
+			if (msginfo) {
+				clabel = MSG_GET_COLORLABEL_VALUE(msginfo->flags);
+				if (!items[clabel]->active)
+					gtk_check_menu_item_set_state
+						(items[clabel], TRUE);
+			}
+		}
+	} else
+		g_warning("invalid number of color elements (%d)\n", n);
+
+	/* reset "dont_toggle" state */
+	gtk_object_set_data(GTK_OBJECT(menu), "dont_toggle",
+			    GINT_TO_POINTER(0));
+}
+
+static void summary_colorlabel_menu_create(SummaryView *summaryview)
+{
+	GtkWidget *label_menuitem;
+	GtkWidget *menu;
+	GtkWidget *item;
+	gint i;
+
+	label_menuitem = gtk_item_factory_get_item(summaryview->popupfactory,
+						   "/Color label");
+	gtk_signal_connect(GTK_OBJECT(label_menuitem), "activate",
+			   GTK_SIGNAL_FUNC(summary_colorlabel_menu_item_activate_item_cb),
+			   summaryview);
+	gtk_widget_show(label_menuitem);
+
+	menu = gtk_menu_new();
+
+	/* create sub items. for the menu item activation callback we pass the
+	 * index of label_colors[] as data parameter. for the None color we
+	 * pass an invalid (high) value. also we attach a data pointer so we
+	 * can always get back the SummaryView pointer. */
+
+	item = gtk_check_menu_item_new_with_label(_("None"));
+	gtk_menu_append(GTK_MENU(menu), item);
+	gtk_signal_connect(GTK_OBJECT(item), "activate",
+			   GTK_SIGNAL_FUNC(summary_colorlabel_menu_item_activate_cb),
+			   GUINT_TO_POINTER(0));
+	gtk_object_set_data(GTK_OBJECT(item), "summaryview", summaryview);
+	gtk_widget_show(item);
+
+	item = gtk_menu_item_new();
+	gtk_menu_append(GTK_MENU(menu), item);
+	gtk_widget_show(item);
+
+	/* create pixmap/label menu items */
+	for (i = 0; i < N_COLOR_LABELS; i++) {
+		item = colorlabel_create_check_color_menu_item(i);
+		gtk_menu_append(GTK_MENU(menu), item);
+		gtk_signal_connect(GTK_OBJECT(item), "activate",
+				   GTK_SIGNAL_FUNC(summary_colorlabel_menu_item_activate_cb),
+				   GUINT_TO_POINTER(i + 1));
+		gtk_object_set_data(GTK_OBJECT(item), "summaryview",
+				    summaryview);
+		gtk_widget_show(item);
+	}
+
+	gtk_widget_show(menu);
+	gtk_menu_item_set_submenu(GTK_MENU_ITEM(label_menuitem), menu);
+	summaryview->colorlabel_menu = menu;
+}
+
+/* callback functions */
+
+static void summary_toggle_pressed(GtkWidget *eventbox, GdkEventButton *event,
+				   SummaryView *summaryview)
+{
+	if (!event)
+		return;
+
+	if (!summaryview->msg_is_toggled_on && summaryview->selected)
+		summary_display_msg(summaryview, summaryview->selected, FALSE);
+	else
+		summary_toggle_view(summaryview);
+}
+
+static void summary_button_pressed(GtkWidget *ctree, GdkEventButton *event,
+				   SummaryView *summaryview)
+{
+	if (!event) return;
+
+	if (event->button == 3) {
+		/* right clicked */
+		//summary_set_add_sender_menu(summaryview);
+		gtk_menu_popup(GTK_MENU(summaryview->popupmenu), NULL, NULL,
+			       NULL, NULL, event->button, event->time);
+	} else if (event->button == 2) {
+		summaryview->display_msg = TRUE;
+	} else if (event->button == 1) {
+		if (!prefs_common.emulate_emacs &&
+		    summaryview->msg_is_toggled_on)
+			summaryview->display_msg = TRUE;
+	}
+}
+
+static void summary_button_released(GtkWidget *ctree, GdkEventButton *event,
+				    SummaryView *summaryview)
+{
+}
+
+void summary_pass_key_press_event(SummaryView *summaryview, GdkEventKey *event)
+{
+	summary_key_pressed(summaryview->ctree, event, summaryview);
+}
+
+#define BREAK_ON_MODIFIER_KEY() \
+	if ((event->state & (GDK_MOD1_MASK|GDK_CONTROL_MASK)) != 0) break
+
+#define RETURN_IF_LOCKED() \
+	if (summaryview->mainwin->lock_count) return
+
+#define KEY_PRESS_EVENT_STOP() \
+	if (gtk_signal_n_emissions_by_name \
+		(GTK_OBJECT(ctree), "key_press_event") > 0) { \
+		gtk_signal_emit_stop_by_name(GTK_OBJECT(ctree), \
+					     "key_press_event"); \
+	}
+
+static void summary_key_pressed(GtkWidget *widget, GdkEventKey *event,
+				SummaryView *summaryview)
+{
+	GtkCTree *ctree = GTK_CTREE(widget);
+	GtkCTreeNode *node;
+	FolderItem *to_folder;
+
+	if (!event) return;
+
+	switch (event->keyval) {
+	case GDK_g:		/* Go */
+	case GDK_G:
+		RETURN_IF_LOCKED();
+		BREAK_ON_MODIFIER_KEY();
+		KEY_PRESS_EVENT_STOP();
+		to_folder = foldersel_folder_sel(NULL, NULL);
+		if (to_folder) {
+			debug_print(_("Go to %s\n"), to_folder->path);
+			folderview_select(summaryview->folderview, to_folder);
+		}
+		return;
+	case GDK_w:		/* Write new message */
+		BREAK_ON_MODIFIER_KEY();
+		if (summaryview->folder_item) {
+			PrefsAccount *ac;
+			ac = summaryview->folder_item->folder->account;
+			if (ac && ac->protocol == A_NNTP)
+				compose_new_with_recipient
+					(ac, summaryview->folder_item->path);
+			else
+				compose_new(ac);
+		} else
+			compose_new(NULL);
+		return;
+	case GDK_D:		/* Empty trash */
+		RETURN_IF_LOCKED();
+		BREAK_ON_MODIFIER_KEY();
+		KEY_PRESS_EVENT_STOP();
+		main_window_empty_trash(summaryview->mainwin, TRUE);
+		return;
+	case GDK_Q:		/* Quit */
+		RETURN_IF_LOCKED();
+		BREAK_ON_MODIFIER_KEY();
+
+		if (prefs_common.confirm_on_exit) {
+			if (alertpanel(_("Exit"), _("Exit this program?"),
+				       _("OK"), _("Cancel"), NULL)
+				       == G_ALERTDEFAULT) {
+				manage_window_focus_in
+					(summaryview->mainwin->window,
+					 NULL, NULL);
+				app_will_exit(NULL, summaryview->mainwin);
+			}
+		}
+		return;
+	case GDK_Left:		/* Move focus */
+	case GDK_Escape:
+		gtk_widget_grab_focus(summaryview->folderview->ctree);
+		return;
+	default:
+	}
+
+	if (!summaryview->selected) {
+		node = gtk_ctree_node_nth(ctree, 0);
+		if (node)
+			gtk_ctree_select(ctree, node);
+		else
+			return;
+	}
+
+	switch (event->keyval) {
+	case GDK_space:		/* Page down or go to the next */
+		if (summaryview->displayed != summaryview->selected) {
+			summary_display_msg(summaryview,
+					    summaryview->selected, FALSE);
+			break;
+		}
+		if (!textview_scroll_page(summaryview->messageview->textview,
+					  FALSE))
+			summary_select_next_unread(summaryview);
+		break;
+	case GDK_n:		/* Next */
+	case GDK_N:
+		BREAK_ON_MODIFIER_KEY();
+		summary_step(summaryview, GTK_SCROLL_STEP_FORWARD);
+		break;
+	case GDK_BackSpace:	/* Page up */
+	case GDK_Delete:
+		textview_scroll_page(summaryview->messageview->textview, TRUE);
+		break;
+	case GDK_p:		/* Prev */
+	case GDK_P:
+		BREAK_ON_MODIFIER_KEY();
+		summary_step(summaryview, GTK_SCROLL_STEP_BACKWARD);
+		break;
+	case GDK_v:		/* Toggle summary mode / message mode */
+	case GDK_V:
+		BREAK_ON_MODIFIER_KEY();
+
+		if (!summaryview->msg_is_toggled_on && summaryview->selected)
+			summary_display_msg(summaryview,
+					    summaryview->selected, FALSE);
+		else
+			summary_toggle_view(summaryview);
+		break;
+	case GDK_Return:	/* Scroll up/down one line */
+		if (summaryview->displayed != summaryview->selected) {
+			summary_display_msg(summaryview,
+					    summaryview->selected, FALSE);
+			break;
+		}
+		textview_scroll_one_line(summaryview->messageview->textview,
+					 (event->state & GDK_MOD1_MASK) != 0);
+		break;
+	case GDK_asterisk:	/* Mark */
+		summary_mark(summaryview);
+		break;
+	case GDK_exclam:	/* Mark as unread */
+		summary_mark_as_unread(summaryview);
+		break;
+	case GDK_d:		/* Delete */
+		RETURN_IF_LOCKED();
+		BREAK_ON_MODIFIER_KEY();
+		summary_delete(summaryview);
+		break;
+	case GDK_u:		/* Unmark */
+	case GDK_U:
+		BREAK_ON_MODIFIER_KEY();
+		summary_unmark(summaryview);
+		break;
+	case GDK_o:		/* Move */
+		RETURN_IF_LOCKED();
+		BREAK_ON_MODIFIER_KEY();
+		summary_move_to(summaryview);
+		break;
+	case GDK_O:		/* Copy */
+		RETURN_IF_LOCKED();
+		BREAK_ON_MODIFIER_KEY();
+		summary_copy_to(summaryview);
+		break;
+	case GDK_x:		/* Execute */
+	case GDK_X:
+		RETURN_IF_LOCKED();
+		BREAK_ON_MODIFIER_KEY();
+		KEY_PRESS_EVENT_STOP();
+		summary_execute(summaryview);
+		break;
+	case GDK_a:		/* Reply to the message */
+		BREAK_ON_MODIFIER_KEY();
+		summary_reply_cb(summaryview,
+				 COMPOSE_REPLY_TO_ALL_WITHOUT_QUOTE, NULL);
+		break;
+	case GDK_A:		/* Reply to the message with quotation */
+		BREAK_ON_MODIFIER_KEY();
+		summary_reply_cb(summaryview,
+				 COMPOSE_REPLY_TO_ALL_WITH_QUOTE, NULL);
+		break;
+	case GDK_f:		/* Forward the message */
+		BREAK_ON_MODIFIER_KEY();
+		summary_reply_cb(summaryview, COMPOSE_FORWARD, NULL);
+		break;
+	case GDK_F:
+		BREAK_ON_MODIFIER_KEY();
+		summary_reply_cb(summaryview, COMPOSE_FORWARD_AS_ATTACH, NULL);
+		break;
+	case GDK_y:		/* Save the message */
+		BREAK_ON_MODIFIER_KEY();
+		summary_save_as(summaryview);
+		break;
+	default:
+	}
+}
+
+#undef BREAK_ON_MODIFIER_KEY
+#undef RETURN_IF_LOCKED
+#undef KEY_PRESS_EVENT_STOP
+
+static void summary_open_row(GtkSCTree *sctree, SummaryView *summaryview)
+{
+	if (summaryview->folder_item->stype == F_DRAFT ||
+	    summaryview->folder_item->stype == F_QUEUE)
+		summary_reedit(summaryview);
+	else
+		summary_open_msg(summaryview);
+
+	summaryview->display_msg = FALSE;
+}
+
+static void summary_tree_expanded(GtkCTree *ctree, GtkCTreeNode *node,
+				  SummaryView *summaryview)
+{
+	summary_set_row_marks(summaryview, node);
+}
+
+static void summary_tree_collapsed(GtkCTree *ctree, GtkCTreeNode *node,
+				   SummaryView *summaryview)
+{
+	summary_set_row_marks(summaryview, node);
+}
+
+static void summary_selected(GtkCTree *ctree, GtkCTreeNode *row,
+			     gint column, SummaryView *summaryview)
+{
+	MsgInfo *msginfo;
+
+	summary_status_show(summaryview);
+	summary_set_menu_sensitive(summaryview);
+
+	if (GTK_CLIST(ctree)->selection &&
+	     GTK_CLIST(ctree)->selection->next) {
+		summaryview->display_msg = FALSE;
+		return;
+	}
+
+	summaryview->selected = row;
+
+	msginfo = gtk_ctree_node_get_row_data(ctree, row);
+
+	switch (column) {
+	case S_COL_MARK:
+		if (MSG_IS_MARKED(msginfo->flags)) {
+			MSG_UNSET_PERM_FLAGS(msginfo->flags, MSG_MARKED);
+			summary_set_row_marks(summaryview, row);
+		} else
+			summary_mark_row(summaryview, row);
+		break;
+	case S_COL_UNREAD:
+		if (MSG_IS_UNREAD(msginfo->flags)) {
+			summary_mark_row_as_read(summaryview, row);
+			summary_status_show(summaryview);
+		} else if (!MSG_IS_REPLIED(msginfo->flags) &&
+			 !MSG_IS_FORWARDED(msginfo->flags)) {
+			summary_mark_row_as_unread(summaryview, row);
+			summary_status_show(summaryview);
+		}
+		break;
+	default:
+	}
+
+	if (summaryview->display_msg)
+		summary_display_msg(summaryview, row, FALSE);
+
+	summaryview->display_msg = FALSE;
+}
+
+static void summary_col_resized(GtkCList *clist, gint column, gint width,
+				SummaryView *summaryview)
+{
+	switch (column) {
+	case S_COL_MARK:
+		prefs_common.summary_col_mark = width;
+		break;
+	case S_COL_UNREAD:
+		prefs_common.summary_col_unread = width;
+		break;
+	case S_COL_MIME:
+		prefs_common.summary_col_mime = width;
+		break;
+	case S_COL_NUMBER:
+		prefs_common.summary_col_number = width;
+		break;
+	case S_COL_SIZE:
+		prefs_common.summary_col_size = width;
+		break;
+	case S_COL_DATE:
+		prefs_common.summary_col_date = width;
+		break;
+	case S_COL_FROM:
+		prefs_common.summary_col_from = width;
+		break;
+	case S_COL_SUBJECT:
+		prefs_common.summary_col_subject = width;
+		break;
+	default:
+	}
+}
+
+static void summary_reply_cb(SummaryView *summaryview, guint action,
+			     GtkWidget *widget)
+{
+	MsgInfo *msginfo;
+
+	msginfo = gtk_ctree_node_get_row_data(GTK_CTREE(summaryview->ctree),
+					      summaryview->selected);
+	if (!msginfo) return;
+
+	switch ((ComposeMode)action) {
+	case COMPOSE_REPLY:
+		compose_reply(msginfo, prefs_common.reply_with_quote,
+			      FALSE, FALSE);
+		break;
+	case COMPOSE_REPLY_WITH_QUOTE:
+		compose_reply(msginfo, TRUE, FALSE, FALSE);
+		break;
+	case COMPOSE_REPLY_WITHOUT_QUOTE:
+		compose_reply(msginfo, FALSE, FALSE, FALSE);
+		break;
+	case COMPOSE_REPLY_TO_SENDER:
+		compose_reply(msginfo, prefs_common.reply_with_quote,
+			      FALSE, TRUE);
+		break;
+	case COMPOSE_REPLY_TO_SENDER_WITH_QUOTE:
+		compose_reply(msginfo, TRUE, FALSE, TRUE);
+		break;
+	case COMPOSE_REPLY_TO_SENDER_WITHOUT_QUOTE:
+		compose_reply(msginfo, FALSE, FALSE, TRUE);
+		break;
+	case COMPOSE_REPLY_TO_ALL:
+		compose_reply(msginfo, prefs_common.reply_with_quote,
+			      TRUE, FALSE);
+		break;
+	case COMPOSE_REPLY_TO_ALL_WITH_QUOTE:
+		compose_reply(msginfo, TRUE, TRUE, FALSE);
+		break;
+	case COMPOSE_REPLY_TO_ALL_WITHOUT_QUOTE:
+		compose_reply(msginfo, FALSE, TRUE, FALSE);
+		break;
+	case COMPOSE_FORWARD:
+		compose_forward(msginfo, FALSE);
+		break;
+	case COMPOSE_FORWARD_AS_ATTACH:
+		compose_forward(msginfo, TRUE);
+		break;
+	default:
+		g_warning("summary_reply_cb(): invalid action: %d\n", action);
+	}
+
+	summary_set_marks_selected(summaryview);
+}
+
+static void summary_show_all_header_cb(SummaryView *summaryview,
+				       guint action, GtkWidget *widget)
+{
+	header_window_show_cb(summaryview->mainwin, action, widget);
+}
+
+static void summary_add_address_cb(SummaryView *summaryview,
+				   guint action, GtkWidget *widget)
+{
+	summary_add_address(summaryview);
+}
+
+static void summary_mark_clicked(GtkWidget *button, SummaryView *summaryview)
+{
+	summary_sort(summaryview, SORT_BY_MARK);
+}
+
+static void summary_unread_clicked(GtkWidget *button, SummaryView *summaryview)
+{
+	summary_sort(summaryview, SORT_BY_UNREAD);
+}
+
+static void summary_mime_clicked(GtkWidget *button, SummaryView *summaryview)
+{
+	summary_sort(summaryview, SORT_BY_MIME);
+}
+
+static void summary_num_clicked(GtkWidget *button, SummaryView *summaryview)
+{
+	summary_sort(summaryview, SORT_BY_NUMBER);
+}
+
+static void summary_size_clicked(GtkWidget *button, SummaryView *summaryview)
+{
+	summary_sort(summaryview, SORT_BY_SIZE);
+}
+
+static void summary_date_clicked(GtkWidget *button, SummaryView *summaryview)
+{
+	summary_sort(summaryview, SORT_BY_DATE);
+}
+
+static void summary_from_clicked(GtkWidget *button, SummaryView *summaryview)
+{
+	summary_sort(summaryview, SORT_BY_FROM);
+}
+
+static void summary_subject_clicked(GtkWidget *button,
+				    SummaryView *summaryview)
+{
+	summary_sort(summaryview, SORT_BY_SUBJECT);
+}
+
+void summary_change_display_item(SummaryView *summaryview)
+{
+	GtkCList *clist = GTK_CLIST(summaryview->ctree);
+
+	gtk_clist_set_column_visibility(clist, S_COL_MARK, prefs_common.show_mark);
+	gtk_clist_set_column_visibility(clist, S_COL_UNREAD, prefs_common.show_unread);
+	gtk_clist_set_column_visibility(clist, S_COL_MIME, prefs_common.show_mime);
+	gtk_clist_set_column_visibility(clist, S_COL_NUMBER, prefs_common.show_number);
+	gtk_clist_set_column_visibility(clist, S_COL_SIZE, prefs_common.show_size);
+	gtk_clist_set_column_visibility(clist, S_COL_DATE, prefs_common.show_date);
+	gtk_clist_set_column_visibility(clist, S_COL_FROM, prefs_common.show_from);
+	gtk_clist_set_column_visibility(clist, S_COL_SUBJECT, prefs_common.show_subject);
+}
+
+static void summary_start_drag(GtkWidget *widget, gint button, GdkEvent *event,
+			       SummaryView *summaryview)
+{
+	GtkTargetList *list;
+	GdkDragContext *context;
+
+	g_return_if_fail(summaryview != NULL);
+	g_return_if_fail(summaryview->folder_item != NULL);
+	g_return_if_fail(summaryview->folder_item->folder != NULL);
+	if (summaryview->folder_item->folder->type == F_NEWS ||
+	    summaryview->selected == NULL)
+		return;
+
+	list = gtk_target_list_new(summary_drag_types, 1);
+
+	context = gtk_drag_begin(widget, list,
+				 GDK_ACTION_MOVE, button, event);
+	gtk_drag_set_icon_default(context);
+}
+
+static void summary_drag_data_get(GtkWidget        *widget,
+				  GdkDragContext   *drag_context,
+				  GtkSelectionData *selection_data,
+				  guint             info,
+				  guint             time,
+				  SummaryView      *summaryview)
+{
+	if (info == TARGET_MAIL_URI_LIST) {
+		GtkCTree *ctree = GTK_CTREE(summaryview->ctree);
+		GList *cur;
+		MsgInfo *msginfo;
+		gchar *mail_list = NULL, *tmp1, *tmp2;
+
+		for (cur = GTK_CLIST(ctree)->selection;
+		     cur != NULL; cur = cur->next) {
+			msginfo = gtk_ctree_node_get_row_data
+				(ctree, GTK_CTREE_NODE(cur->data));
+			tmp2 = procmsg_get_message_file_path(msginfo);
+			if (!tmp2) continue;
+			tmp1 = g_strconcat("file:/", tmp2, NULL);
+			g_free(tmp2);
+
+			if (!mail_list) {
+				mail_list = tmp1;
+			} else {
+				tmp2 = g_strconcat(mail_list, tmp1, NULL);
+				g_free(mail_list);
+				g_free(tmp1);
+				mail_list = tmp2;
+			}
+		}
+
+		if (mail_list != NULL) {
+			gtk_selection_data_set(selection_data,
+					       selection_data->target, 8,
+					       mail_list, strlen(mail_list));
+			g_free(mail_list);
+		} 
+	} else if (info == TARGET_DUMMY) {
+		if (GTK_CLIST(summaryview->ctree)->selection)
+			gtk_selection_data_set(selection_data,
+					       selection_data->target, 8,
+					       "Dummy", 6);
+	}
+}
+
+
+/* custom compare functions for sorting */
+
+static gint summary_cmp_by_mark(GtkCList *clist,
+				gconstpointer ptr1, gconstpointer ptr2)
+{
+	MsgInfo *msginfo1 = ((GtkCListRow *)ptr1)->data;
+	MsgInfo *msginfo2 = ((GtkCListRow *)ptr2)->data;
+
+	return MSG_IS_MARKED(msginfo1->flags) - MSG_IS_MARKED(msginfo2->flags);
+}
+
+static gint summary_cmp_by_unread(GtkCList *clist,
+				  gconstpointer ptr1, gconstpointer ptr2)
+{
+	MsgInfo *msginfo1 = ((GtkCListRow *)ptr1)->data;
+	MsgInfo *msginfo2 = ((GtkCListRow *)ptr2)->data;
+
+	return MSG_IS_UNREAD(msginfo1->flags) - MSG_IS_UNREAD(msginfo2->flags);
+}
+
+static gint summary_cmp_by_mime(GtkCList *clist,
+				gconstpointer ptr1, gconstpointer ptr2)
+{
+	MsgInfo *msginfo1 = ((GtkCListRow *)ptr1)->data;
+	MsgInfo *msginfo2 = ((GtkCListRow *)ptr2)->data;
+
+	return MSG_IS_MIME(msginfo1->flags) - MSG_IS_MIME(msginfo2->flags);
+}
+
+static gint summary_cmp_by_num(GtkCList *clist,
+			       gconstpointer ptr1, gconstpointer ptr2)
+{
+	MsgInfo *msginfo1 = ((GtkCListRow *)ptr1)->data;
+	MsgInfo *msginfo2 = ((GtkCListRow *)ptr2)->data;
+
+	return msginfo1->msgnum - msginfo2->msgnum;
+}
+
+static gint summary_cmp_by_size(GtkCList *clist,
+				gconstpointer ptr1, gconstpointer ptr2)
+{
+	MsgInfo *msginfo1 = ((GtkCListRow *)ptr1)->data;
+	MsgInfo *msginfo2 = ((GtkCListRow *)ptr2)->data;
+
+	return msginfo1->size - msginfo2->size;
+}
+
+static gint summary_cmp_by_date(GtkCList *clist,
+			       gconstpointer ptr1, gconstpointer ptr2)
+{
+	MsgInfo *msginfo1 = ((GtkCListRow *)ptr1)->data;
+	MsgInfo *msginfo2 = ((GtkCListRow *)ptr2)->data;
+
+	return msginfo1->date_t - msginfo2->date_t;
+}
+
+static gint summary_cmp_by_from(GtkCList *clist,
+			       gconstpointer ptr1, gconstpointer ptr2)
+{
+	MsgInfo *msginfo1 = ((GtkCListRow *)ptr1)->data;
+	MsgInfo *msginfo2 = ((GtkCListRow *)ptr2)->data;
+
+	if (!msginfo1->fromname)
+		return (msginfo2->fromname != NULL);
+	if (!msginfo2->fromname)
+		return -1;
+
+	return strcasecmp(msginfo1->fromname, msginfo2->fromname);
+}
+
+static gint summary_cmp_by_subject(GtkCList *clist,
+			       gconstpointer ptr1, gconstpointer ptr2)
+{
+	MsgInfo *msginfo1 = ((GtkCListRow *)ptr1)->data;
+	MsgInfo *msginfo2 = ((GtkCListRow *)ptr2)->data;
+
+	if (!msginfo1->subject)
+		return (msginfo2->subject != NULL);
+	if (!msginfo2->subject)
+		return -1;
+
+	return strcasecmp(msginfo1->subject, msginfo2->subject);
+}
+
+static gint summary_cmp_by_label(GtkCList *clist,
+				 gconstpointer ptr1, gconstpointer ptr2)
+{
+	MsgInfo *msginfo1 = ((GtkCListRow *)ptr1)->data;
+	MsgInfo *msginfo2 = ((GtkCListRow *)ptr2)->data;
+
+	return MSG_GET_COLORLABEL(msginfo1->flags) -
+		MSG_GET_COLORLABEL(msginfo2->flags);
+}
