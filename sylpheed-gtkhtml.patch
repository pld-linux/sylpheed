diff -urN sylpheed-0.4.66.orig/acconfig.h sylpheed-0.4.66/acconfig.h
--- sylpheed-0.4.66.orig/acconfig.h	Wed Apr 25 06:49:21 2001
+++ sylpheed-0.4.66/acconfig.h	Fri May 11 10:31:16 2001
@@ -7,6 +7,8 @@
 #undef HAVE_GDK_PIXBUF
 #undef HAVE_GDK_IMLIB
 
+#undef HAVE_GTKHTML
+
 /* Whether to use multithread or not  */
 #undef USE_THREADS
 
diff -urN sylpheed-0.4.66.orig/configure.in sylpheed-0.4.66/configure.in
--- sylpheed-0.4.66.orig/configure.in	Tue May  8 07:10:27 2001
+++ sylpheed-0.4.66/configure.in	Fri May 11 10:31:16 2001
@@ -106,6 +106,25 @@
 	AC_CHECK_LIB(jconv, jconv_alloc_conv)
 fi
 
+dnl Check for gtkhtml
+AC_ARG_ENABLE(gtkhtml,
+	[  --disable-gtkhtml         Do not use gtkhtml],
+	[ac_cv_disable_gtkhtml=disable], [ac_cv_disable_gtkhtml=no])
+AC_MSG_CHECKING([whether to use GtkHTML])
+if test "$ac_cv_disable_gtkhtml" = no; then
+	AC_MSG_RESULT(yes)
+	AC_CHECK_LIB(gtkhtml, gtk_html_new, ac_cv_gtkhtml_lib=yes, ac_cv_gtkhtml_lib=no, -lunicode)
+	AC_CHECK_HEADER(gtkhtml/gtkhtml.h, ac_cv_gtkhtml_h=yes, ac_cv_gtkhtml_h=no)
+	if test "$ac_cv_gtkhtml_lib" = yes -a "$ac_cv_gtkhtml_h" = yes; then 
+		LIBS="$LIBS -lgtkhtml -lunicode"
+		AC_DEFINE(HAVE_GTKHTML)
+	else
+		AC_MSG_WARN([Unable to find GtkHTML])
+	fi
+else
+	AC_MSG_RESULT(no)
+fi
+
 AC_CHECK_LIB(xpg4, setlocale)
 dnl AC_CHECK_LIB(kcc, KCC_filter)
 
diff -urN sylpheed-0.4.66.orig/configure.in.orig sylpheed-0.4.66/configure.in.orig
--- sylpheed-0.4.66.orig/configure.in.orig	Thu Jan  1 01:00:00 1970
+++ sylpheed-0.4.66/configure.in.orig	Tue May  8 07:10:27 2001
@@ -0,0 +1,200 @@
+dnl Process this file with autoconf to produce a configure script.
+AC_INIT(src/main.c)
+PACKAGE=sylpheed
+
+dnl version number
+MAJOR_VERSION=0
+MINOR_VERSION=4
+MICRO_VERSION=66
+INTERFACE_AGE=66
+BINARY_AGE=66
+EXTRA_VERSION=
+VERSION=$MAJOR_VERSION.$MINOR_VERSION.$MICRO_VERSION$EXTRA_VERSION
+
+dnl
+AM_INIT_AUTOMAKE($PACKAGE, $VERSION, no-define)
+AC_DEFINE_UNQUOTED(PACKAGE, "$PACKAGE")
+AC_DEFINE_UNQUOTED(VERSION, "$VERSION")
+
+dnl libtool versioning
+LT_RELEASE=$MAJOR_VERSION.$MINOR_VERSION
+LT_CURRENT=`expr $MICRO_VERSION - $INTERFACE_AGE`
+LT_REVISION=$INTERFACE_AGE
+LT_AGE=`expr $BINARY_AGE - $INTERFACE_AGE`
+AC_SUBST(LT_RELEASE)
+AC_SUBST(LT_CURRENT)
+AC_SUBST(LT_REVISION)
+AC_SUBST(LT_AGE)
+
+dnl Specify a header configuration file
+AM_CONFIG_HEADER(config.h)
+
+AM_PROG_LIBTOOL
+AM_MAINTAINER_MODE
+
+dnl Checks for programs.
+AC_ARG_PROGRAM
+AC_PROG_CC
+AC_ISC_POSIX
+AM_PROG_CC_STDC
+AC_PROG_INSTALL
+AC_PROG_LN_S
+AC_PROG_MAKE_SET
+AC_PROG_CPP
+dnl AC_PROG_RANLIB
+
+SYLPHEED_ACLOCAL_INCLUDE(ac)
+
+dnl for gettext
+ALL_LINGUAS="cs de el es fr it ja ko nl pt_BR ru zh_CN.GB2312 zh_TW.Big5"
+AM_GNU_GETTEXT
+dnl AC_CHECK_FUNC(gettext, AC_CHECK_LIB(intl, gettext))
+localedir='${prefix}/${DATADIRNAME}/locale'
+AC_SUBST(localedir)
+
+manualdir='${prefix}/${DATADIRNAME}/${PACKAGE}/manual'
+AC_SUBST(manualdir)
+
+dnl Checks for libraries.
+AM_PATH_GLIB(1.2.6,,
+	AC_MSG_ERROR(Test for GLIB failed. See the file 'INSTALL' for help.),
+	gthread)
+AM_PATH_GTK(1.2.6,,
+	AC_MSG_ERROR(Test for GTK failed. See the file 'INSTALL' for help.))
+
+dnl Check for built-in image view support
+AC_ARG_ENABLE(gdk-pixbuf,
+	[  --disable-gdk-pixbuf    Do not use gdk-pixbuf],
+	[ac_cv_disable_gdk_pixbuf=disable], [ac_cv_disable_gdk_pixbuf=no])
+AC_ARG_ENABLE(imlib,
+	[  --disable-imlib         Do not use imlib],
+	[ac_cv_disable_imlib=disable], [ac_cv_disable_imlib=no])
+
+if test "$ac_cv_disable_gdk_pixbuf" = no; then
+	AM_PATH_GDK_PIXBUF(0.8.0,
+		AC_DEFINE(HAVE_GDK_PIXBUF), [ac_cv_disable_gdk_pixbuf=disable])
+fi
+if test "$ac_cv_disable_gdk_pixbuf" = disable -a "$ac_cv_disable_imlib" = no; then
+	AM_PATH_GDK_IMLIB(1.9,
+		AC_DEFINE(HAVE_GDK_IMLIB), [ac_cv_disable_imlib=disable])
+fi
+if test "$ac_cv_disable_gdk_pixbuf" = disable -a "$ac_cv_disable_imlib" = disable; then
+	AC_MSG_WARN(*** Built-in image view will not be supported ***)
+fi
+
+dnl GPGME is used to support OpenPGP 
+AC_ARG_ENABLE(gpgme,
+	[  --enable-gpgme          Enable GnuPG support using GPGME [default=no]],
+	[ac_cv_enable_gpgme=$enableval], [ac_cv_enable_gpgme=no])
+if test $ac_cv_enable_gpgme = yes; then
+	AM_PATH_GPGME(0.2.1, AC_DEFINE(USE_GPGME), [use_gpgme=no])
+fi
+
+dnl Check for X-Face support
+AC_ARG_ENABLE(compface,
+	[  --disable-compface      Do not use compface (X-Face)],
+	[ac_cv_disable_compface=disable], [ac_cv_disable_compface=no])
+if test "$ac_cv_disable_compface" = no; then
+	AC_CHECK_LIB(compface, uncompface)
+fi
+
+dnl Check for libjconv
+AC_ARG_ENABLE(jconv,
+	[  --disable-jconv         Do not use libjconv],
+	[ac_cv_disable_jconv=disable], [ac_cv_disable_jconv=no])
+if test "$ac_cv_disable_jconv" = no; then
+	AC_CHECK_LIB(jconv, jconv_alloc_conv)
+fi
+
+AC_CHECK_LIB(xpg4, setlocale)
+dnl AC_CHECK_LIB(kcc, KCC_filter)
+
+dnl for GThread support
+AC_ARG_ENABLE(threads,
+	[  --enable-threads        Enable multithread support [default=no]],
+	[use_threads=$enableval], [use_threads=no])
+
+AC_MSG_CHECKING([whether to use threads])
+if test x"$use_threads" = xyes ; then
+	AC_MSG_RESULT(yes)
+	if test ! -z `$GLIB_CONFIG --help 2>&1 |grep 'gthread'` ; then
+		CFLAGS="$CFLAGS `$GLIB_CONFIG --cflags gthread`"
+		LIBS="$LIBS `$GLIB_CONFIG --libs gthread`"
+		AC_DEFINE(USE_THREADS)
+	else
+		AC_MSG_ERROR([Sylpheed requires GThread from GLib to use threading.])
+	fi
+else
+	AC_MSG_RESULT(no)
+fi
+
+dnl check for IPv6 option
+AC_ARG_ENABLE(ipv6,
+	[  --enable-ipv6           Enable IPv6 support [default=no]],
+	[ac_cv_enableipv6=$enableval], [ac_cv_enableipv6=no])
+
+dnl automated checks for IPv6 support.
+if test x"$ac_cv_enableipv6" = xyes; then
+	AC_MSG_CHECKING([for IPv6 support])
+	AC_CACHE_VAL(ac_cv_ipv6,[
+		AC_TRY_COMPILE([#define INET6
+				#include <sys/types.h>
+				#include <netinet/in.h>],
+			[int x = IPPROTO_IPV6; struct in6_addr a;],
+			ac_cv_ipv6=yes, ac_cv_ipv6=no)
+	])
+	AC_MSG_RESULT($ac_cv_ipv6)
+	if test $ac_cv_ipv6 = yes; then
+		AC_DEFINE(INET6)
+	fi
+fi
+
+dnl Checks for header files.
+AC_HEADER_DIRENT
+AC_HEADER_STDC
+AC_HEADER_SYS_WAIT
+AC_CHECK_HEADERS(fcntl.h sys/file.h unistd.h paths.h \
+		 sys/param.h sys/utsname.h \
+		 wchar.h wctype.h)
+
+dnl Checks for typedefs, structures, and compiler characteristics.
+AC_C_CONST
+AC_TYPE_OFF_T
+AC_TYPE_PID_T
+AC_TYPE_SIZE_T
+AC_STRUCT_TM
+
+dnl AC_CHECK_TYPE(wint_t, unsigned int) does not work because wint_t
+dnl may be defined only in wchar.h (this happens with gcc-2.96).
+dnl So we need to use this extended macro.
+SYLPHEED_CHECK_TYPE(wint_t, unsigned int,
+[
+#if HAVE_WCHAR_H
+#include <wchar.h>
+#endif
+])
+
+GNUPG_CHECK_TYPEDEF(u32, HAVE_U32_TYPEDEF)
+AC_CHECK_SIZEOF(unsigned short, 2)
+AC_CHECK_SIZEOF(unsigned int, 4)
+AC_CHECK_SIZEOF(unsigned long, 4)
+
+dnl Checks for library functions.
+AC_FUNC_ALLOCA
+AC_CHECK_FUNCS(gethostname mkdir mktime socket strstr \
+	       wcsstr wcswcs iswalnum iswspace towlower \
+	       wcslen wcscpy wcsncpy \
+	       uname flock lockf inet_aton inet_addr \
+	       fchmod mkstemp)
+
+AC_OUTPUT([
+Makefile
+sylpheed.spec
+intl/Makefile
+ac/Makefile
+po/Makefile.in
+libkcc/Makefile
+src/Makefile
+manual/Makefile
+manual/ja/Makefile
+])
diff -urN sylpheed-0.4.66.orig/src/Makefile.am sylpheed-0.4.66/src/Makefile.am
--- sylpheed-0.4.66.orig/src/Makefile.am	Mon May  7 03:51:03 2001
+++ sylpheed-0.4.66/src/Makefile.am	Fri May 11 10:31:16 2001
@@ -11,6 +11,7 @@
 	headerview.c headerview.h \
 	textview.c textview.h \
 	imageview.c imageview.h \
+	htmlview.c htmlview.h \
 	mimeview.c mimeview.h \
 	summary_search.c summary_search.h \
 	folder.c folder.h \
diff -urN sylpheed-0.4.66.orig/src/htmlview.c sylpheed-0.4.66/src/htmlview.c
--- sylpheed-0.4.66.orig/src/htmlview.c	Thu Jan  1 01:00:00 1970
+++ sylpheed-0.4.66/src/htmlview.c	Tue Jan  9 23:40:57 2001
@@ -0,0 +1,117 @@
+/*
+ * Sylpheed -- a GTK+ based, lightweight, and fast e-mail client
+ * Copyright (C) 1999,2000 Hiroyuki Yamamoto
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifdef HAVE_CONFIG_H
+#  include "config.h"
+#endif
+
+#include <glib.h>
+#include <gtk/gtkscrolledwindow.h>
+#include <gtk/gtkpixmap.h>
+#include <gtk/gtktext.h>
+
+#ifdef HAVE_GTKHTML
+#  include <gtkhtml/gtkhtml.h>
+#endif /* HAVE_GTKHTML */
+
+#include "intl.h"
+#include "mainwindow.h"
+#include "prefs_common.h"
+#include "procmime.h"
+#include "htmlview.h"
+#include "utils.h"
+
+HTMLView *htmlview_create(void)
+{
+	HTMLView *htmlview;
+	GtkWidget *scrolledwin;
+	GtkWidget *html_widget;
+
+	debug_print(_("Creating html view...\n"));
+	htmlview = g_new0(HTMLView, 1);
+
+	scrolledwin = gtk_scrolled_window_new(NULL, NULL);
+	gtk_scrolled_window_set_policy(GTK_SCROLLED_WINDOW(scrolledwin),
+				       GTK_POLICY_NEVER,
+				       GTK_POLICY_ALWAYS);
+	gtk_widget_set_usize(scrolledwin, prefs_common.mainview_width, -1);
+
+#ifdef HAVE_GTKHTML
+	html_widget = gtk_html_new();
+	gtk_container_add (GTK_CONTAINER (scrolledwin), html_widget);
+#endif
+
+	gtk_widget_show_all(scrolledwin);
+
+	htmlview->scrolledwin  = scrolledwin;
+	htmlview->html_widget  = html_widget;
+	return htmlview;
+}
+
+void htmlview_init(HTMLView *htmlview)
+{
+}
+
+void htmlview_show_html(HTMLView *htmlview, MimeInfo *mimeinfo,
+			const gchar *file)
+{
+#ifdef HAVE_GTKHTML
+        GtkHTMLStream *handle;
+	GtkHTML *html;
+	FILE *fp;
+	char *buf, *c;
+	int bufsize;
+	const int maxbuf = 512; /* Read 512 bytes at a time */
+	
+	html = GTK_HTML(htmlview->html_widget);
+	if (!html) {
+		g_warning(_("Bad htmlview param."));
+		return;
+	} 
+	/* Open the file */
+	fp = fopen(file, "rt");
+	if (!fp) {
+		g_warning(_("Can't open HTML attachment."));
+		return;
+	}
+
+	buf = malloc(maxbuf);
+	if (!buf) {
+		g_warning(_("Can't allocate buffer for HTML."));
+		return;
+	}
+	
+	gtk_html_load_empty(html); 
+	handle = gtk_html_begin(html);
+	while (!feof(fp)) {
+	    bufsize = fread(buf, 1, maxbuf, fp);
+	    if (bufsize>0) {
+		gtk_html_write(html, handle, buf, bufsize);
+	    }
+	}
+	gtk_html_end(html, handle, GTK_HTML_STREAM_OK); 
+	free(buf);
+
+#endif
+}
+
+void htmlview_destroy(HTMLView *htmlview)
+{
+	g_free(htmlview);
+}
diff -urN sylpheed-0.4.66.orig/src/htmlview.h sylpheed-0.4.66/src/htmlview.h
--- sylpheed-0.4.66.orig/src/htmlview.h	Thu Jan  1 01:00:00 1970
+++ sylpheed-0.4.66/src/htmlview.h	Tue Jan  9 23:41:01 2001
@@ -0,0 +1,46 @@
+/*
+ * Sylpheed -- a GTK+ based, lightweight, and fast e-mail client
+ * Copyright (C) 1999,2000 Hiroyuki Yamamoto
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef __HTMLVIEW_H__
+#define __HTMLVIEW_H__
+
+#include <glib.h>
+#include <gtk/gtkwidget.h>
+
+typedef struct _HTMLView	HTMLView;
+
+#include "messageview.h"
+#include "procmime.h"
+
+struct _HTMLView
+{
+	GtkWidget *scrolledwin;
+	GtkWidget *html_widget;
+
+	MessageView *messageview;
+};
+
+HTMLView *htmlview_create	(void);
+void htmlview_init		(HTMLView	*htmlview);
+void htmlview_show_html		(HTMLView	*htmlview,
+				 MimeInfo	*mimeinfo,
+				 const gchar	*file);
+void htmlview_destroy		(HTMLView	*htmlview);
+
+#endif /* __HTMLVIEW_H__ */
diff -urN sylpheed-0.4.66.orig/src/messageview.c sylpheed-0.4.66/src/messageview.c
--- sylpheed-0.4.66.orig/src/messageview.c	Sun Jan 21 08:36:10 2001
+++ sylpheed-0.4.66/src/messageview.c	Fri May 11 10:31:16 2001
@@ -36,6 +36,7 @@
 #include "headerview.h"
 #include "textview.h"
 #include "imageview.h"
+#include "htmlview.h"
 #include "mimeview.h"
 #include "procmsg.h"
 #include "procheader.h"
@@ -62,6 +63,7 @@
 	HeaderView *headerview;
 	TextView *textview;
 	ImageView *imageview;
+	HTMLView *htmlview;
 	MimeView *mimeview;
 
 	debug_print(_("Creating message view...\n"));
@@ -77,9 +79,13 @@
 	imageview = imageview_create();
 	imageview->messageview = messageview;
 
+	htmlview = htmlview_create();
+	htmlview->messageview = messageview;
+
 	mimeview = mimeview_create();
 	mimeview->textview = textview;
 	mimeview->imageview = imageview;
+	mimeview->htmlview = htmlview;
 	mimeview->messageview = messageview;
 
 	vbox = gtk_vbox_new(FALSE, 0);
@@ -91,6 +97,7 @@
 	/* to remove without destroyed */
 	gtk_widget_ref(GTK_WIDGET_PTR(textview));
 	gtk_widget_ref(GTK_WIDGET_PTR(imageview));
+	gtk_widget_ref(GTK_WIDGET_PTR(htmlview));
 	gtk_widget_ref(GTK_WIDGET_PTR(mimeview));
 
 	messageview->vbox       = vbox;
@@ -99,6 +106,7 @@
 	messageview->headerview = headerview;
 	messageview->textview   = textview;
 	messageview->imageview  = imageview;
+	messageview->htmlview   = htmlview;
 	messageview->mimeview   = mimeview;
 
 	return messageview;
@@ -142,6 +150,7 @@
 	headerview_init(messageview->headerview);
 	textview_init(messageview->textview);
 	imageview_init(messageview->imageview);
+	htmlview_init(messageview->htmlview);
 	mimeview_init(messageview->mimeview);
 	//messageview_set_font(messageview);
 }
@@ -212,6 +221,7 @@
 {
 	TextView *textview = messageview->textview;
 	ImageView *imageview = messageview->imageview;
+	HTMLView *htmlview = messageview->htmlview;
 	MimeView *mimeview = messageview->mimeview;
 
 	if (messageview->type == type) return;
@@ -233,6 +243,9 @@
 		if (mimeview->vbox == GTK_WIDGET_PTR(textview)->parent) {
 			gtk_container_remove(GTK_CONTAINER(mimeview->vbox),
 					     GTK_WIDGET_PTR(textview));
+		} else if (mimeview->vbox == GTK_WIDGET_PTR(htmlview)->parent){
+			gtk_container_remove(GTK_CONTAINER(mimeview->vbox),
+					     GTK_WIDGET_PTR(htmlview));
 		} else {
 			gtk_container_remove(GTK_CONTAINER(mimeview->vbox),
 					     GTK_WIDGET_PTR(imageview));
@@ -257,17 +270,20 @@
 {
 	GtkWidget *textview  = GTK_WIDGET_PTR(messageview->textview);
 	GtkWidget *imageview = GTK_WIDGET_PTR(messageview->imageview);
+	GtkWidget *htmlview = GTK_WIDGET_PTR(messageview->htmlview);
 	GtkWidget *mimeview  = GTK_WIDGET_PTR(messageview->mimeview);
 
 	headerview_destroy(messageview->headerview);
 	textview_destroy(messageview->textview);
 	imageview_destroy(messageview->imageview);
+	htmlview_destroy(messageview->htmlview);
 	mimeview_destroy(messageview->mimeview);
 
 	g_free(messageview);
 
 	gtk_widget_unref(textview);
 	gtk_widget_unref(imageview);
+	gtk_widget_unref(htmlview);
 	gtk_widget_unref(mimeview);
 }
 
diff -urN sylpheed-0.4.66.orig/src/messageview.c.orig sylpheed-0.4.66/src/messageview.c.orig
--- sylpheed-0.4.66.orig/src/messageview.c.orig	Thu Jan  1 01:00:00 1970
+++ sylpheed-0.4.66/src/messageview.c.orig	Sun Jan 21 08:36:10 2001
@@ -0,0 +1,321 @@
+/*
+ * Sylpheed -- a GTK+ based, lightweight, and fast e-mail client
+ * Copyright (C) 1999,2000 Hiroyuki Yamamoto
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include "defs.h"
+
+#include <glib.h>
+#include <gdk/gdkkeysyms.h>
+#include <gtk/gtkvbox.h>
+#include <gtk/gtkcontainer.h>
+#include <gtk/gtkeditable.h>
+#include <gtk/gtkwindow.h>
+#include <gtk/gtktext.h>
+#include <stdio.h>
+#include <ctype.h>
+#include <string.h>
+
+#include "intl.h"
+#include "main.h"
+#include "messageview.h"
+#include "headerview.h"
+#include "textview.h"
+#include "imageview.h"
+#include "mimeview.h"
+#include "procmsg.h"
+#include "procheader.h"
+#include "procmime.h"
+#include "prefs_common.h"
+#include "gtkutils.h"
+#include "utils.h"
+#include "rfc2015.h"
+
+static void messageview_change_view_type(MessageView	*messageview,
+					 MessageType	 type);
+static void messageview_destroy_cb	(GtkWidget	*widget,
+					 MessageView	*messageview);
+static void messageview_size_allocate_cb(GtkWidget	*widget,
+					 GtkAllocation	*allocation);
+static void key_pressed			(GtkWidget	*widget,
+					 GdkEventKey	*event,
+					 MessageView	*messageview);
+
+MessageView *messageview_create(void)
+{
+	MessageView *messageview;
+	GtkWidget *vbox;
+	HeaderView *headerview;
+	TextView *textview;
+	ImageView *imageview;
+	MimeView *mimeview;
+
+	debug_print(_("Creating message view...\n"));
+	messageview = g_new0(MessageView, 1);
+
+	messageview->type = MVIEW_TEXT;
+
+	headerview = headerview_create();
+
+	textview = textview_create();
+	textview->messageview = messageview;
+
+	imageview = imageview_create();
+	imageview->messageview = messageview;
+
+	mimeview = mimeview_create();
+	mimeview->textview = textview;
+	mimeview->imageview = imageview;
+	mimeview->messageview = messageview;
+
+	vbox = gtk_vbox_new(FALSE, 0);
+	gtk_box_pack_start(GTK_BOX(vbox), GTK_WIDGET_PTR(headerview),
+			   FALSE, FALSE, 0);
+	gtk_box_pack_start(GTK_BOX(vbox), GTK_WIDGET_PTR(textview),
+			   TRUE, TRUE, 0);
+
+	/* to remove without destroyed */
+	gtk_widget_ref(GTK_WIDGET_PTR(textview));
+	gtk_widget_ref(GTK_WIDGET_PTR(imageview));
+	gtk_widget_ref(GTK_WIDGET_PTR(mimeview));
+
+	messageview->vbox       = vbox;
+	messageview->new_window = FALSE;
+	messageview->window     = NULL;
+	messageview->headerview = headerview;
+	messageview->textview   = textview;
+	messageview->imageview  = imageview;
+	messageview->mimeview   = mimeview;
+
+	return messageview;
+}
+
+MessageView *messageview_create_with_new_window(void)
+{
+	GtkWidget *window;
+	MessageView *msgview;
+
+	window = gtk_window_new(GTK_WINDOW_TOPLEVEL);
+	gtk_window_set_title(GTK_WINDOW(window), "Message");
+	gtk_window_set_policy(GTK_WINDOW(window), TRUE, TRUE, FALSE);
+	gtk_widget_set_usize(window, prefs_common.msgwin_width,
+			     prefs_common.msgwin_height);
+
+	msgview = messageview_create();
+
+	gtk_signal_connect(GTK_OBJECT(window), "size_allocate",
+			   GTK_SIGNAL_FUNC(messageview_size_allocate_cb),
+			   msgview);
+	gtk_signal_connect(GTK_OBJECT(window), "destroy",
+			   GTK_SIGNAL_FUNC(messageview_destroy_cb), msgview);
+	gtk_signal_connect(GTK_OBJECT(window), "key_press_event",
+			   GTK_SIGNAL_FUNC(key_pressed), msgview);
+
+	gtk_container_add(GTK_CONTAINER(window), GTK_WIDGET_PTR(msgview));
+	gtk_widget_grab_focus(msgview->textview->text);
+	gtk_widget_show_all(window);
+
+	msgview->new_window = TRUE;
+	msgview->window = window;
+
+	messageview_init(msgview);
+
+	return msgview;
+}
+
+void messageview_init(MessageView *messageview)
+{
+	headerview_init(messageview->headerview);
+	textview_init(messageview->textview);
+	imageview_init(messageview->imageview);
+	mimeview_init(messageview->mimeview);
+	//messageview_set_font(messageview);
+}
+
+void messageview_show(MessageView *messageview, MsgInfo *msginfo)
+{
+	FILE *fp;
+	gchar *file;
+	MimeInfo *mimeinfo;
+	MsgInfo *tmpmsginfo;
+
+	g_return_if_fail(msginfo != NULL);
+
+#if USE_GPGME
+	for (;;) {
+		if ((fp = procmsg_open_message(msginfo)) == NULL) return;
+		mimeinfo = procmime_scan_mime_header(fp);
+		if (!mimeinfo) break;
+
+		if (!MSG_IS_ENCRYPTED(msginfo->flags) &&
+		    rfc2015_is_encrypted(mimeinfo)) {
+			MSG_SET_FLAGS(msginfo->flags, MSG_ENCRYPTED);
+		}
+		if (MSG_IS_ENCRYPTED(msginfo->flags) &&
+		    !msginfo->plaintext_file  &&
+		    !msginfo->decryption_failed) {
+			/* This is an encrypted message but it has not yet
+			 * been decrypted and there was no unsuccessful
+			 * decryption attempt */
+			rfc2015_decrypt_message(msginfo, mimeinfo, fp);
+			if (msginfo->plaintext_file &&
+			    !msginfo->decryption_failed) {
+				fclose(fp);
+				continue;
+			}
+		}
+
+		break;
+	}
+#else /* !USE_GPGME */
+	if ((fp = procmsg_open_message(msginfo)) == NULL) return;
+	mimeinfo = procmime_scan_mime_header(fp);
+#endif /* USE_GPGME */
+	fclose(fp);
+	if (!mimeinfo) return;
+
+	file = procmsg_get_message_file_path(msginfo);
+	g_return_if_fail(file != NULL);
+
+	tmpmsginfo = procheader_parse(file, msginfo->flags, TRUE);
+	headerview_show(messageview->headerview, tmpmsginfo);
+	procmsg_msginfo_free(tmpmsginfo);
+
+	if (mimeinfo->mime_type != MIME_TEXT) {
+		messageview_change_view_type(messageview, MVIEW_MIME);
+		mimeview_show_message(messageview->mimeview, mimeinfo, file);
+	} else {
+		messageview_change_view_type(messageview, MVIEW_TEXT);
+		textview_show_message(messageview->textview, mimeinfo, file);
+		procmime_mimeinfo_free(mimeinfo);
+	}
+
+	g_free(file);
+}
+
+static void messageview_change_view_type(MessageView *messageview,
+					 MessageType type)
+{
+	TextView *textview = messageview->textview;
+	ImageView *imageview = messageview->imageview;
+	MimeView *mimeview = messageview->mimeview;
+
+	if (messageview->type == type) return;
+
+	if (type == MVIEW_MIME) {
+		gtk_container_remove
+			(GTK_CONTAINER(GTK_WIDGET_PTR(messageview)),
+			 GTK_WIDGET_PTR(textview));
+		gtk_box_pack_start(GTK_BOX(messageview->vbox),
+				   GTK_WIDGET_PTR(mimeview), TRUE, TRUE, 0);
+		gtk_container_add(GTK_CONTAINER(mimeview->vbox),
+				  GTK_WIDGET_PTR(textview));
+		mimeview->type = MIMEVIEW_TEXT;
+	} else if (type == MVIEW_TEXT) {
+		gtk_container_remove
+			(GTK_CONTAINER(GTK_WIDGET_PTR(messageview)),
+			 GTK_WIDGET_PTR(mimeview));
+
+		if (mimeview->vbox == GTK_WIDGET_PTR(textview)->parent) {
+			gtk_container_remove(GTK_CONTAINER(mimeview->vbox),
+					     GTK_WIDGET_PTR(textview));
+		} else {
+			gtk_container_remove(GTK_CONTAINER(mimeview->vbox),
+					     GTK_WIDGET_PTR(imageview));
+		}
+
+		gtk_box_pack_start(GTK_BOX(messageview->vbox),
+				   GTK_WIDGET_PTR(textview), TRUE, TRUE, 0);
+	} else
+		return;
+
+	messageview->type = type;
+}
+
+void messageview_clear(MessageView *messageview)
+{
+	messageview_change_view_type(messageview, MVIEW_TEXT);
+	headerview_clear(messageview->headerview);
+	textview_clear(messageview->textview);
+}
+
+void messageview_destroy(MessageView *messageview)
+{
+	GtkWidget *textview  = GTK_WIDGET_PTR(messageview->textview);
+	GtkWidget *imageview = GTK_WIDGET_PTR(messageview->imageview);
+	GtkWidget *mimeview  = GTK_WIDGET_PTR(messageview->mimeview);
+
+	headerview_destroy(messageview->headerview);
+	textview_destroy(messageview->textview);
+	imageview_destroy(messageview->imageview);
+	mimeview_destroy(messageview->mimeview);
+
+	g_free(messageview);
+
+	gtk_widget_unref(textview);
+	gtk_widget_unref(imageview);
+	gtk_widget_unref(mimeview);
+}
+
+void messageview_quote_color_set(void)
+{
+}
+
+void messageview_set_font(MessageView *messageview)
+{
+	textview_set_font(messageview->textview, NULL);
+}
+
+void messageview_copy_clipboard(MessageView *messageview)
+{
+	if (messageview->type == MVIEW_TEXT)
+		gtk_editable_copy_clipboard
+			(GTK_EDITABLE(messageview->textview->text));
+}
+
+void messageview_select_all(MessageView *messageview)
+{
+	if (messageview->type == MVIEW_TEXT)
+		gtk_editable_select_region
+			(GTK_EDITABLE(messageview->textview->text), 0, -1);
+}
+
+GtkWidget *messageview_get_text_widget(MessageView *messageview)
+{
+	return messageview->textview->text;
+}
+
+static void messageview_destroy_cb(GtkWidget *widget, MessageView *messageview)
+{
+	messageview_destroy(messageview);
+}
+
+static void messageview_size_allocate_cb(GtkWidget *widget,
+					 GtkAllocation *allocation)
+{
+	g_return_if_fail(allocation != NULL);
+
+	prefs_common.msgwin_width  = allocation->width;
+	prefs_common.msgwin_height = allocation->height;
+}
+
+static void key_pressed(GtkWidget *widget, GdkEventKey *event,
+			MessageView *messageview)
+{
+	if (event && event->keyval == GDK_Escape && messageview->window)
+		gtk_widget_destroy(messageview->window);
+}
diff -urN sylpheed-0.4.66.orig/src/messageview.h sylpheed-0.4.66/src/messageview.h
--- sylpheed-0.4.66.orig/src/messageview.h	Thu Nov  2 10:27:51 2000
+++ sylpheed-0.4.66/src/messageview.h	Fri May 11 10:31:16 2001
@@ -29,6 +29,7 @@
 #include "headerview.h"
 #include "textview.h"
 #include "imageview.h"
+#include "htmlview.h"
 #include "mimeview.h"
 #include "procmsg.h"
 
@@ -49,6 +50,7 @@
 	HeaderView *headerview;
 	TextView *textview;
 	ImageView *imageview;
+	HTMLView *htmlview;
 	MimeView *mimeview;
 
 	MainWindow *mainwin;
diff -urN sylpheed-0.4.66.orig/src/mimeview.c sylpheed-0.4.66/src/mimeview.c
--- sylpheed-0.4.66.orig/src/mimeview.c	Wed Apr 25 08:56:38 2001
+++ sylpheed-0.4.66/src/mimeview.c	Fri May 11 10:31:16 2001
@@ -418,23 +418,64 @@
 	g_free(filename);
 }
 
+static void mimeview_show_html_part(MimeView *mimeview, MimeInfo *partinfo)
+{
+	gchar *name;
+	gchar *filename;
+
+	if (!partinfo) return;
+
+	name = partinfo->filename ? partinfo->filename
+		: partinfo->name ? partinfo->name : "tmpfile";
+	filename = g_strconcat(get_mime_tmp_dir(), G_DIR_SEPARATOR_S,
+			       name, NULL);
+
+	if (procmime_get_part(filename, mimeview->file, partinfo) < 0)
+		alertpanel_error
+			(_("Can't get the part of multipart message."));
+	else {
+		mimeview_change_view_type(mimeview, MIMEVIEW_HTML);
+		htmlview_show_html(mimeview->htmlview, partinfo, filename);
+	}
+
+	g_free(filename);
+}
+
 static void mimeview_change_view_type(MimeView *mimeview, MimeViewType type)
 {
 	TextView  *textview  = mimeview->textview;
 	ImageView *imageview = mimeview->imageview;
+	HTMLView *htmlview = mimeview->htmlview;
 
 	if (mimeview->type == type) return;
 
-	switch (type) {
+	switch(mimeview->type) {
 	case MIMEVIEW_IMAGE:
 		gtk_container_remove(GTK_CONTAINER(mimeview->vbox),
+				     GTK_WIDGET_PTR(imageview));
+		break;
+	case MIMEVIEW_HTML:
+  	        gtk_container_remove(GTK_CONTAINER(mimeview->vbox),
+				     GTK_WIDGET_PTR(htmlview));
+		break;
+	case MIMEVIEW_TEXT:
+		gtk_container_remove(GTK_CONTAINER(mimeview->vbox),
 				     GTK_WIDGET_PTR(textview));
+		break;
+	default:
+  	        return;
+	}
+
+	switch (type) {
+	case MIMEVIEW_IMAGE:
 		gtk_container_add(GTK_CONTAINER(mimeview->vbox),
 				  GTK_WIDGET_PTR(imageview));
 		break;
+	case MIMEVIEW_HTML:
+		gtk_container_add(GTK_CONTAINER(mimeview->vbox),
+				  GTK_WIDGET_PTR(htmlview));
+		break;
 	case MIMEVIEW_TEXT:
-		gtk_container_remove(GTK_CONTAINER(mimeview->vbox),
-				     GTK_WIDGET_PTR(imageview));
 		gtk_container_add(GTK_CONTAINER(mimeview->vbox),
 				  GTK_WIDGET_PTR(textview));
 		break;
@@ -475,7 +516,6 @@
 
 	switch (partinfo->mime_type) {
 	case MIME_TEXT:
-	case MIME_TEXT_HTML:
 	case MIME_MESSAGE_RFC822:
 	case MIME_MULTIPART:
 		mimeview_show_message_part(mimeview, partinfo);
@@ -485,6 +525,13 @@
 		mimeview_show_image_part(mimeview, partinfo);
 		break;
 #endif
+	case MIME_TEXT_HTML:
+#if (HAVE_GTKHTML)
+	        mimeview_show_html_part(mimeview, partinfo);
+#else
+		mimeview_show_message_part(mimeview, partinfo);
+#endif		
+		break;
 	default:
 		mimeview_change_view_type(mimeview, MIMEVIEW_TEXT);
 #if USE_GPGME
diff -urN sylpheed-0.4.66.orig/src/mimeview.c.orig sylpheed-0.4.66/src/mimeview.c.orig
--- sylpheed-0.4.66.orig/src/mimeview.c.orig	Thu Jan  1 01:00:00 1970
+++ sylpheed-0.4.66/src/mimeview.c.orig	Wed Apr 25 08:56:38 2001
@@ -0,0 +1,858 @@
+/*
+ * Sylpheed -- a GTK+ based, lightweight, and fast e-mail client
+ * Copyright (C) 1999,2000 Hiroyuki Yamamoto
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifdef HAVE_CONFIG_H
+#  include "config.h"
+#endif
+
+#include "defs.h"
+
+#include <glib.h>
+#include <gdk/gdkkeysyms.h>
+#include <gtk/gtkscrolledwindow.h>
+#include <gtk/gtkctree.h>
+#include <gtk/gtkvbox.h>
+#include <gtk/gtkvpaned.h>
+#include <gtk/gtktext.h>
+#include <gtk/gtksignal.h>
+#include <gtk/gtkmenu.h>
+#include <gtk/gtkdnd.h>
+#include <gtk/gtkselection.h>
+#include <stdio.h>
+#include <unistd.h>
+
+#include "intl.h"
+#include "main.h"
+#include "mimeview.h"
+#include "textview.h"
+#include "procmime.h"
+#include "summaryview.h"
+#include "menu.h"
+#include "filesel.h"
+#include "alertpanel.h"
+#include "utils.h"
+#include "gtkutils.h"
+#include "prefs_common.h"
+#include "rfc2015.h"
+
+typedef enum
+{
+	COL_MIMETYPE = 0,
+	COL_SIZE     = 1,
+	COL_NAME     = 2
+} MimeViewColumnPos;
+
+#define N_MIMEVIEW_COLS	3
+
+static void mimeview_set_multipart_tree		(MimeView	*mimeview,
+						 MimeInfo	*mimeinfo,
+						 GtkCTreeNode	*parent);
+static GtkCTreeNode *mimeview_append_part	(MimeView	*mimeview,
+						 MimeInfo	*partinfo,
+						 GtkCTreeNode	*parent);
+static void mimeview_show_message_part		(MimeView	*mimeview,
+						 MimeInfo	*partinfo);
+static void mimeview_show_image_part		(MimeView	*mimeview,
+						 MimeInfo	*partinfo);
+static void mimeview_change_view_type		(MimeView	*mimeview,
+						 ContentType	 type);
+static void mimeview_clear			(MimeView	*mimeview);
+
+static void mimeview_selected		(GtkCTree	*ctree,
+					 GtkCTreeNode	*node,
+					 gint		 column,
+					 MimeView	*mimeview);
+static void mimeview_start_drag 	(GtkWidget	*widget,
+					 gint		 button,
+					 GdkEvent	*event,
+					 MimeView	*mimeview);
+static void mimeview_button_pressed	(GtkWidget	*widget,
+					 GdkEventButton	*event,
+					 MimeView	*mimeview);
+static void mimeview_key_pressed	(GtkWidget	*widget,
+					 GdkEventKey	*event,
+					 MimeView	*mimeview);
+
+static void mimeview_drag_data_get      (GtkWidget	  *widget,
+					 GdkDragContext   *drag_context,
+					 GtkSelectionData *selection_data,
+					 guint		   info,
+					 guint		   time,
+					 MimeView	  *mimeview);
+
+static void mimeview_display_as_text	(MimeView	*mimeview);
+static void mimeview_save_as		(MimeView	*mimeview);
+static void mimeview_launch		(MimeView	*mimeview);
+static void mimeview_view_file		(const gchar	*filename,
+					 MimeInfo	*partinfo);
+#if USE_GPGME
+static void mimeview_check_signature	(MimeView	*mimeview);
+#endif
+
+static GtkItemFactoryEntry mimeview_popup_entries[] =
+{
+	{N_("/_Open"),		  NULL, mimeview_launch,	  0, NULL},
+	{N_("/_Display as text"), NULL, mimeview_display_as_text, 0, NULL},
+	{N_("/_Save as..."),	  NULL, mimeview_save_as,	  0, NULL}
+#if USE_GPGME
+        ,
+        {N_("/_Check signature"), NULL, mimeview_check_signature, 0, NULL}
+#endif
+};
+
+static GtkTargetEntry mimeview_mime_types[] =
+{
+	{"text/uri-list", 0, 0}
+};
+
+MimeView *mimeview_create(void)
+{
+	MimeView *mimeview;
+
+	GtkWidget *paned;
+	GtkWidget *scrolledwin;
+	GtkWidget *ctree;
+	GtkWidget *vbox;
+	GtkWidget *popupmenu;
+	GtkItemFactory *popupfactory;
+
+	gchar *titles[] = {_("MIME Type"), _("Size"), _("Name")};
+	gint n_entries;
+	gint i;
+
+	debug_print(_("Creating MIME view...\n"));
+	mimeview = g_new0(MimeView, 1);
+
+	scrolledwin = gtk_scrolled_window_new(NULL, NULL);
+	gtk_scrolled_window_set_policy(GTK_SCROLLED_WINDOW(scrolledwin),
+				       GTK_POLICY_AUTOMATIC,
+				       GTK_POLICY_ALWAYS);
+	gtk_widget_set_usize(scrolledwin, -1, 80);
+
+	ctree = gtk_sctree_new_with_titles(N_MIMEVIEW_COLS, 0, titles);
+	gtk_clist_set_selection_mode(GTK_CLIST(ctree), GTK_SELECTION_BROWSE);//SINGLE);
+	gtk_ctree_set_line_style(GTK_CTREE(ctree), GTK_CTREE_LINES_NONE);
+	gtk_clist_set_column_justification(GTK_CLIST(ctree), COL_SIZE,
+					   GTK_JUSTIFY_RIGHT);
+	gtk_clist_set_column_width(GTK_CLIST(ctree), COL_MIMETYPE, 240);
+	gtk_clist_set_column_width(GTK_CLIST(ctree), COL_SIZE, 64);
+	for (i = 0; i < N_MIMEVIEW_COLS; i++)
+		GTK_WIDGET_UNSET_FLAGS(GTK_CLIST(ctree)->column[i].button,
+				       GTK_CAN_FOCUS);
+	gtk_container_add(GTK_CONTAINER(scrolledwin), ctree);
+
+	gtk_signal_connect(GTK_OBJECT(ctree), "tree_select_row",
+			   GTK_SIGNAL_FUNC(mimeview_selected), mimeview);
+	gtk_signal_connect(GTK_OBJECT(ctree), "button_press_event",
+			   GTK_SIGNAL_FUNC(mimeview_button_pressed), mimeview);
+	gtk_signal_connect(GTK_OBJECT(ctree), "key_press_event",
+			   GTK_SIGNAL_FUNC(mimeview_key_pressed), mimeview);
+	gtk_signal_connect(GTK_OBJECT (ctree),"start_drag",
+			   GTK_SIGNAL_FUNC (mimeview_start_drag), mimeview);
+	gtk_signal_connect(GTK_OBJECT(ctree), "drag_data_get",
+			   GTK_SIGNAL_FUNC(mimeview_drag_data_get), mimeview);
+    
+	vbox = gtk_vbox_new(FALSE, 0);
+
+	paned = gtk_vpaned_new();
+	gtk_paned_add1(GTK_PANED(paned), scrolledwin);
+	gtk_paned_add2(GTK_PANED(paned), vbox);
+	gtk_widget_show_all(paned);
+
+	n_entries = sizeof(mimeview_popup_entries) /
+		sizeof(mimeview_popup_entries[0]);
+	popupmenu = menu_create_items(mimeview_popup_entries, n_entries,
+				      "<MimeView>", &popupfactory, mimeview);
+
+	mimeview->paned       = paned;
+	mimeview->scrolledwin = scrolledwin;
+	mimeview->ctree       = ctree;
+	mimeview->vbox        = vbox;
+	mimeview->popupmenu   = popupmenu;
+	mimeview->popupfactory = popupfactory;
+
+	return mimeview;
+}
+
+void mimeview_init(MimeView *mimeview)
+{
+}
+
+/* 
+ * Check whether the message is OpenPGP signed
+ */
+#if USE_GPGME
+static gboolean mimeview_is_signed(MimeView *mimeview)
+{
+	MimeInfo *partinfo;
+
+        debug_print("mimeview_is signed of %p\n", mimeview);
+
+        if (!mimeview) return FALSE;
+	if (!mimeview->opened) return FALSE;
+
+        debug_print("mimeview_is_signed: open\n" );
+
+	if (!mimeview->file) return FALSE;
+
+        debug_print("mimeview_is_signed: file\n" );
+
+	partinfo = gtk_ctree_node_get_row_data
+		(GTK_CTREE(mimeview->ctree), mimeview->opened);
+	g_return_val_if_fail(partinfo != NULL, FALSE);
+
+	/* walk the tree and see whether there is a signature somewhere */
+	do {
+		if (rfc2015_has_signature(partinfo))
+			return TRUE;
+        } while ((partinfo = partinfo->parent) != NULL);
+
+	debug_print("mimeview_is_signed: FALSE\n" );
+
+	return FALSE;
+}
+
+static void set_unchecked_signature(MimeInfo *mimeinfo)
+{
+	MimeInfo *sig_partinfo;
+
+	sig_partinfo = rfc2015_find_signature(mimeinfo);
+	if (sig_partinfo == NULL) return;
+
+	g_free(sig_partinfo->sigstatus);
+	sig_partinfo->sigstatus =
+		g_strdup(_("Select \"Check signature\" to check"));
+
+	g_free(sig_partinfo->sigstatus_full);
+	sig_partinfo->sigstatus_full = NULL;
+}
+#endif /* USE_GPGME */
+
+void mimeview_show_message(MimeView *mimeview, MimeInfo *mimeinfo,
+			   const gchar *file)
+{
+	GtkCTree *ctree = GTK_CTREE(mimeview->ctree);
+	GtkCTreeNode *node;
+	gchar buf[BUFFSIZE];
+	FILE *fp;
+
+	mimeview_clear(mimeview);
+
+	g_return_if_fail(file != NULL);
+	g_return_if_fail(mimeinfo != NULL);
+
+	mimeview->mimeinfo = mimeinfo;
+
+	if ((fp = fopen(file, "r")) == NULL) {
+		FILE_OP_ERROR(file, "fopen");
+		return;
+	}
+	mimeview->file = g_strdup(file);
+
+	/* skip headers */
+	if (mimeinfo->mime_type == MIME_MULTIPART) {
+		if (fseek(fp, mimeinfo->fpos, SEEK_SET) < 0)
+		perror("fseek");
+		while (fgets(buf, sizeof(buf), fp) != NULL)
+			if (buf[0] == '\r' || buf[0] == '\n') break;
+	}
+
+	procmime_scan_multipart_message(mimeinfo, fp);
+#if USE_GPGME
+	if (prefs_common.auto_check_signatures)
+		rfc2015_check_signature(mimeinfo, fp);
+	else
+		set_unchecked_signature(mimeinfo);
+#endif
+	fclose(fp);
+
+	gtk_signal_handler_block_by_func(GTK_OBJECT(ctree), mimeview_selected,
+					 mimeview);
+
+	mimeview_set_multipart_tree(mimeview, mimeinfo, NULL);
+
+	gtk_signal_handler_unblock_by_func(GTK_OBJECT(ctree),
+					   mimeview_selected, mimeview);
+
+	if ((node = gtk_ctree_node_nth(ctree, 0))) {
+		gtk_ctree_select(ctree, node);
+		gtk_widget_grab_focus(mimeview->ctree);
+	}
+}
+
+void mimeview_destroy(MimeView *mimeview)
+{
+	procmime_mimeinfo_free_all(mimeview->mimeinfo);
+	g_free(mimeview->file);
+	g_free(mimeview);
+}
+
+static void mimeview_set_multipart_tree(MimeView *mimeview,
+					MimeInfo *mimeinfo,
+					GtkCTreeNode *parent)
+{
+	g_return_if_fail(mimeinfo != NULL);
+
+	if (!mimeinfo->main && mimeinfo->parent)
+		parent = mimeview_append_part(mimeview, mimeinfo, parent);
+
+	if (mimeinfo->sub && mimeinfo->sub->children)
+		mimeview_set_multipart_tree(mimeview, mimeinfo->sub, parent);
+
+	if (mimeinfo->children) {
+		MimeInfo *child;
+
+		child = mimeinfo->children;
+		while (child) {
+			mimeview_set_multipart_tree(mimeview, child, parent);
+			child = child->next;
+		}
+	}
+}
+
+static gchar *get_part_name(MimeInfo *partinfo)
+{
+#if USE_GPGME
+	if (partinfo->sigstatus)
+		return partinfo->sigstatus;
+	else
+#endif
+	if (partinfo->name)
+		return partinfo->name;
+	else if (partinfo->filename)
+		return partinfo->filename;
+	else
+		return "";
+}
+
+static GtkCTreeNode *mimeview_append_part(MimeView *mimeview,
+					  MimeInfo *partinfo,
+					  GtkCTreeNode *parent)
+{
+	GtkCTree *ctree = GTK_CTREE(mimeview->ctree);
+	GtkCTreeNode *node;
+	gchar *str[N_MIMEVIEW_COLS];
+
+	str[COL_MIMETYPE] =
+		partinfo->content_type ? partinfo->content_type : "";
+	str[COL_SIZE] = to_human_readable(partinfo->size);
+	str[COL_NAME] = get_part_name(partinfo);
+
+	node = gtk_ctree_insert_node(ctree, parent, NULL, str, 0,
+				     NULL, NULL, NULL, NULL,
+				     FALSE, TRUE);
+	gtk_ctree_node_set_row_data(ctree, node, partinfo);
+
+	return node;
+}
+
+static void mimeview_show_message_part(MimeView *mimeview, MimeInfo *partinfo)
+{
+	FILE *fp;
+	const gchar *fname;
+#if USE_GPGME
+	MimeInfo *pi;
+#endif
+
+	if (!partinfo) return;
+
+#if USE_GPGME
+	for (pi = partinfo; pi && !pi->plaintextfile ; pi = pi->parent)
+		;
+	fname = pi ? pi->plaintextfile : mimeview->file;
+#else
+	fname = mimeview->file;
+#endif /* USE_GPGME */
+	if (!fname) return;
+
+	if ((fp = fopen(fname, "r")) == NULL) {
+		FILE_OP_ERROR(fname, "fopen");
+		return;
+	}
+
+	if (fseek(fp, partinfo->fpos, SEEK_SET) < 0) {
+		FILE_OP_ERROR(mimeview->file, "fseek");
+		fclose(fp);
+		return;
+	}
+
+	mimeview_change_view_type(mimeview, MIMEVIEW_TEXT);
+	textview_show_part(mimeview->textview, partinfo, fp);
+
+	fclose(fp);
+}
+
+static void mimeview_show_image_part(MimeView *mimeview, MimeInfo *partinfo)
+{
+	gchar *filename;
+
+	if (!partinfo) return;
+
+	filename = procmime_get_tmp_file_name(partinfo);
+
+	if (procmime_get_part(filename, mimeview->file, partinfo) < 0)
+		alertpanel_error
+			(_("Can't get the part of multipart message."));
+	else {
+		mimeview_change_view_type(mimeview, MIMEVIEW_IMAGE);
+		imageview_show_image(mimeview->imageview, partinfo, filename);
+		unlink(filename);
+	}
+
+	g_free(filename);
+}
+
+static void mimeview_change_view_type(MimeView *mimeview, MimeViewType type)
+{
+	TextView  *textview  = mimeview->textview;
+	ImageView *imageview = mimeview->imageview;
+
+	if (mimeview->type == type) return;
+
+	switch (type) {
+	case MIMEVIEW_IMAGE:
+		gtk_container_remove(GTK_CONTAINER(mimeview->vbox),
+				     GTK_WIDGET_PTR(textview));
+		gtk_container_add(GTK_CONTAINER(mimeview->vbox),
+				  GTK_WIDGET_PTR(imageview));
+		break;
+	case MIMEVIEW_TEXT:
+		gtk_container_remove(GTK_CONTAINER(mimeview->vbox),
+				     GTK_WIDGET_PTR(imageview));
+		gtk_container_add(GTK_CONTAINER(mimeview->vbox),
+				  GTK_WIDGET_PTR(textview));
+		break;
+	default:
+		return;
+	}
+
+	mimeview->type = type;
+}
+
+static void mimeview_clear(MimeView *mimeview)
+{
+	GtkCList *clist = GTK_CLIST(mimeview->ctree);
+
+	procmime_mimeinfo_free_all(mimeview->mimeinfo);
+	mimeview->mimeinfo = NULL;
+
+	gtk_clist_clear(clist);
+	textview_clear(mimeview->textview);
+
+	mimeview->opened = NULL;
+
+	g_free(mimeview->file);
+	mimeview->file = NULL;
+}
+
+static void mimeview_selected(GtkCTree *ctree, GtkCTreeNode *node, gint column,
+			      MimeView *mimeview)
+{
+	MimeInfo *partinfo;
+
+	if (mimeview->opened == node) return;
+	mimeview->opened = node;
+	gtk_ctree_node_moveto(ctree, node, -1, 0.5, 0);
+
+	partinfo = gtk_ctree_node_get_row_data(ctree, node);
+	if (!partinfo) return;
+
+	switch (partinfo->mime_type) {
+	case MIME_TEXT:
+	case MIME_TEXT_HTML:
+	case MIME_MESSAGE_RFC822:
+	case MIME_MULTIPART:
+		mimeview_show_message_part(mimeview, partinfo);
+		break;
+#if (HAVE_GDK_PIXBUF || HAVE_GDK_IMLIB)
+	case MIME_IMAGE:
+		mimeview_show_image_part(mimeview, partinfo);
+		break;
+#endif
+	default:
+		mimeview_change_view_type(mimeview, MIMEVIEW_TEXT);
+#if USE_GPGME
+		if (g_strcasecmp(partinfo->content_type,
+				 "application/pgp-signature") == 0)
+			textview_show_signature_part(mimeview->textview,
+						     partinfo);
+		else
+#endif
+			textview_show_mime_part(mimeview->textview, partinfo);
+		break;
+	}
+}
+
+static void mimeview_start_drag (GtkWidget *widget, gint button,
+				 GdkEvent *event, MimeView *mimeview)
+{
+	GtkTargetList *list;
+	GdkDragContext *context;
+	MimeInfo *partinfo;
+	GtkCTree *ctree;
+
+	g_return_if_fail(mimeview != NULL);
+	ctree = GTK_CTREE(mimeview->ctree);
+	partinfo = gtk_ctree_node_get_row_data(ctree, mimeview->opened);
+	if (partinfo->filename == NULL && partinfo->name == NULL) return;
+
+	list = gtk_target_list_new(mimeview_mime_types, 1);
+	context = gtk_drag_begin(widget, list,
+				 GDK_ACTION_COPY, button, event);
+	gtk_drag_set_icon_default(context);
+}
+
+static void mimeview_button_pressed(GtkWidget *widget, GdkEventButton *event,
+				    MimeView *mimeview)
+{
+	GtkCList *clist = GTK_CLIST(widget);
+	MimeInfo *partinfo;
+	gint row, column;
+
+	if (!event) return;
+
+	if (event->button == 2 || event->button == 3) {
+		if (!gtk_clist_get_selection_info(clist, event->x, event->y,
+						  &row, &column))
+			return;
+		gtk_clist_unselect_all(clist);
+		gtk_clist_select_row(clist, row, column);
+		gtkut_clist_set_focus_row(clist, row);
+	}
+
+	if (event->button == 2 ||
+	    (event->button == 1 && event->type == GDK_2BUTTON_PRESS)) {
+		/* call external program for image, audio or html */
+		mimeview_launch(mimeview);
+	} else if (event->button == 3) {
+		partinfo = gtk_ctree_node_get_row_data
+			(GTK_CTREE(mimeview->ctree), mimeview->opened);
+		if (partinfo && (partinfo->mime_type == MIME_TEXT ||
+				 partinfo->mime_type == MIME_TEXT_HTML ||
+				 partinfo->mime_type == MIME_MESSAGE_RFC822 ||
+				 partinfo->mime_type == MIME_IMAGE ||
+				 partinfo->mime_type == MIME_MULTIPART))
+			menu_set_sensitive(mimeview->popupfactory,
+					   "/Display as text", FALSE);
+		else
+			menu_set_sensitive(mimeview->popupfactory,
+					   "/Display as text", TRUE);
+#if USE_GPGME
+		menu_set_sensitive(mimeview->popupfactory,
+				   "/Check signature",
+				   mimeview_is_signed(mimeview));
+#endif
+
+		gtk_menu_popup(GTK_MENU(mimeview->popupmenu),
+			       NULL, NULL, NULL, NULL,
+			       event->button, event->time);
+	}
+}
+
+#define BREAK_ON_MODIFIER_KEY() \
+	if ((event->state & (GDK_MOD1_MASK|GDK_CONTROL_MASK)) != 0) break
+
+static void mimeview_key_pressed(GtkWidget *widget, GdkEventKey *event,
+				 MimeView *mimeview)
+{
+	SummaryView *summaryview;
+	GtkCTree *ctree = GTK_CTREE(mimeview->ctree);
+	GtkCTreeNode *node;
+
+	if (!event) return;
+	if (!mimeview->opened) return;
+
+	switch (event->keyval) {
+	case GDK_space:
+		if (textview_scroll_page(mimeview->textview, FALSE)) return;
+
+		node = GTK_CTREE_NODE_NEXT(mimeview->opened);
+		if (node) {
+			gtk_sctree_unselect_all(GTK_SCTREE(ctree));
+			gtk_sctree_select(GTK_SCTREE(ctree), node);
+			return;
+		}
+		break;
+	case GDK_BackSpace:
+	case GDK_Delete:
+		textview_scroll_page(mimeview->textview, TRUE);
+		return;
+	case GDK_Return:
+		textview_scroll_one_line(mimeview->textview,
+					 (event->state & GDK_MOD1_MASK) != 0);
+		return;
+	case GDK_n:
+	case GDK_N:
+		BREAK_ON_MODIFIER_KEY();
+		if (!GTK_CTREE_NODE_NEXT(mimeview->opened)) break;
+
+		gtk_signal_emit_by_name(GTK_OBJECT(ctree), "scroll_vertical",
+					GTK_SCROLL_STEP_FORWARD, 0.0);
+		return;
+	case GDK_p:
+	case GDK_P:
+		BREAK_ON_MODIFIER_KEY();
+		if (!GTK_CTREE_NODE_PREV(mimeview->opened)) break;
+
+		gtk_signal_emit_by_name(GTK_OBJECT(ctree), "scroll_vertical",
+					GTK_SCROLL_STEP_BACKWARD, 0.0);
+		return;
+	case GDK_y:
+		BREAK_ON_MODIFIER_KEY();
+		mimeview_save_as(mimeview);
+		return;
+	case GDK_t:
+		BREAK_ON_MODIFIER_KEY();
+		mimeview_display_as_text(mimeview);
+		return;
+	case GDK_l:
+		BREAK_ON_MODIFIER_KEY();
+		mimeview_launch(mimeview);
+		return;
+	default:
+	}
+
+	if (!mimeview->messageview->mainwin) return;
+	summaryview = mimeview->messageview->mainwin->summaryview;
+	summary_pass_key_press_event(summaryview, event);
+}
+
+static void mimeview_drag_data_get(GtkWidget	    *widget,
+				   GdkDragContext   *drag_context,
+				   GtkSelectionData *selection_data,
+				   guint	     info,
+				   guint	     time,
+				   MimeView	    *mimeview)
+{
+	gchar *filename, *uriname;
+	MimeInfo *partinfo;
+
+	if (!mimeview->opened) return;
+	if (!mimeview->file) return;
+
+	partinfo = gtk_ctree_node_get_row_data
+		(GTK_CTREE(mimeview->ctree), mimeview->opened);
+	if (!partinfo) return;
+	if (!partinfo->filename && !partinfo->name) return;
+
+	filename = partinfo->filename ? partinfo->filename : partinfo->name;
+	filename = g_basename(filename);
+	if (*filename == '\0') return;
+
+	filename = g_strconcat(get_mime_tmp_dir(), G_DIR_SEPARATOR_S,
+			       filename, NULL);
+
+	if (procmime_get_part(filename, mimeview->file, partinfo) < 0)
+		alertpanel_error
+			(_("Can't save the part of multipart message."));
+
+	uriname = g_strconcat("file:/", filename, NULL);
+	gtk_selection_data_set(selection_data, selection_data->target, 8,
+			       uriname, strlen(uriname));
+
+	g_free(uriname);
+	g_free(filename);
+}
+
+static void mimeview_display_as_text(MimeView *mimeview)
+{
+	MimeInfo *partinfo;
+
+	if (!mimeview->opened) return;
+
+	partinfo = gtk_ctree_node_get_row_data
+		(GTK_CTREE(mimeview->ctree), mimeview->opened);
+	mimeview_show_message_part(mimeview, partinfo);
+}
+
+static void mimeview_save_as(MimeView *mimeview)
+{
+	gchar *filename;
+	MimeInfo *partinfo;
+
+	if (!mimeview->opened) return;
+	if (!mimeview->file) return;
+
+	partinfo = gtk_ctree_node_get_row_data
+		(GTK_CTREE(mimeview->ctree), mimeview->opened);
+	g_return_if_fail(partinfo != NULL);
+
+	filename = filesel_select_file
+		(_("Save as"),
+		 partinfo->filename ? partinfo->filename : partinfo->name);
+	if (!filename) return;
+	if (is_file_exist(filename)) {
+		AlertValue aval;
+
+		aval = alertpanel(_("Overwrite"),
+				  _("Overwrite existing file?"),
+				  _("OK"), _("Cancel"), NULL);
+		if (G_ALERTDEFAULT != aval) return;
+	}
+
+	if (procmime_get_part(filename, mimeview->file, partinfo) < 0)
+		alertpanel_error
+			(_("Can't save the part of multipart message."));
+}
+
+static void mimeview_launch(MimeView *mimeview)
+{
+	MimeInfo *partinfo;
+	gchar *filename;
+
+	if (!mimeview->opened) return;
+	if (!mimeview->file) return;
+
+	partinfo = gtk_ctree_node_get_row_data
+		(GTK_CTREE(mimeview->ctree), mimeview->opened);
+	g_return_if_fail(partinfo != NULL);
+
+	filename = procmime_get_tmp_file_name(partinfo);
+
+	if (procmime_get_part(filename, mimeview->file, partinfo) < 0)
+		alertpanel_error
+			(_("Can't save the part of multipart message."));
+	else
+		mimeview_view_file(filename, partinfo);
+
+	g_free(filename);
+}
+
+static void mimeview_view_file(const gchar *filename, MimeInfo *partinfo)
+{
+	static gchar *default_image_cmdline = "display '%s'";
+	static gchar *default_audio_cmdline = "play '%s'";
+	static gchar *default_html_cmdline =
+		"netscape -remote 'openURL(%s,raise)'";
+	static gchar *mime_cmdline = "metamail -d -b -c %s '%s'";
+	gchar buf[1024];
+	gchar m_buf[1024];
+	gchar *cmd;
+	gchar *def_cmd;
+	gchar *p;
+
+	if (MIME_APPLICATION_OCTET_STREAM == partinfo->mime_type) {
+		return;
+	} else if (MIME_IMAGE == partinfo->mime_type) {
+		cmd = prefs_common.mime_image_viewer;
+		def_cmd = default_image_cmdline;
+	} else if (MIME_AUDIO == partinfo->mime_type) {
+		cmd = prefs_common.mime_audio_player;
+		def_cmd = default_audio_cmdline;
+	} else if (MIME_TEXT_HTML == partinfo->mime_type) {
+		cmd = prefs_common.uri_cmd;
+		def_cmd = default_html_cmdline;
+	} else {
+		g_snprintf(m_buf, sizeof(m_buf), mime_cmdline,
+			   partinfo->content_type, "%s");
+		cmd = m_buf;
+		def_cmd = NULL;
+	}
+
+	if (cmd && (p = strchr(cmd, '%')) && *(p + 1) == 's' &&
+	    !strchr(p + 2, '%'))
+		g_snprintf(buf, sizeof(buf), cmd, filename);
+	else {
+		if (cmd)
+			g_warning(_("MIME viewer command line is invalid: `%s'"), cmd);
+		if (def_cmd)
+			g_snprintf(buf, sizeof(buf), def_cmd, filename);
+		else
+			return;
+	}
+
+	execute_command_line(buf);
+}
+
+#if USE_GPGME
+static void update_node_name(GtkCTree *ctree, GtkCTreeNode *node,
+			     gpointer data)
+{
+	MimeInfo *partinfo;
+	gchar *part_name;
+
+	partinfo = gtk_ctree_node_get_row_data(ctree, node);
+	g_return_if_fail(partinfo != NULL);
+
+	part_name = get_part_name(partinfo);
+	gtk_ctree_node_set_text(ctree, node, COL_NAME, part_name);
+}
+
+static void mimeview_update_names(MimeView *mimeview)
+{
+	GtkCTree *ctree = GTK_CTREE(mimeview->ctree);
+
+	gtk_ctree_pre_recursive(ctree, NULL, update_node_name, NULL);
+}
+
+static void mimeview_update_signature_info(MimeView *mimeview)
+{
+	MimeInfo *partinfo;
+
+	if (!mimeview) return;
+	if (!mimeview->opened) return;
+
+	partinfo = gtk_ctree_node_get_row_data
+		(GTK_CTREE(mimeview->ctree), mimeview->opened);
+	if (!partinfo) return;
+
+	if (g_strcasecmp(partinfo->content_type,
+			 "application/pgp-signature") == 0) {
+		mimeview_change_view_type(mimeview, MIMEVIEW_TEXT);
+		textview_show_signature_part(mimeview->textview, partinfo);
+	}
+}
+
+static void mimeview_check_signature(MimeView *mimeview)
+{
+	MimeInfo *mimeinfo;
+	gchar buf[BUFFSIZE];
+	FILE *fp;
+
+	g_return_if_fail (mimeview_is_signed(mimeview));
+
+	mimeinfo = gtk_ctree_node_get_row_data
+		(GTK_CTREE(mimeview->ctree), mimeview->opened);
+	g_return_if_fail(mimeinfo != NULL);
+	g_return_if_fail(mimeview->file != NULL);
+
+	while (mimeinfo->parent)
+		mimeinfo = mimeinfo->parent;
+
+	if ((fp = fopen(mimeview->file, "r")) == NULL) {
+		FILE_OP_ERROR(mimeview->file, "fopen");
+		return;
+	}
+
+	/* skip headers */
+	if (mimeinfo->mime_type == MIME_MULTIPART) {
+		if (fseek(fp, mimeinfo->fpos, SEEK_SET) < 0)
+		FILE_OP_ERROR(mimeview->file, "fseek");
+		while (fgets(buf, sizeof(buf), fp) != NULL)
+			if (buf[0] == '\r' || buf[0] == '\n') break;
+	}
+
+	procmime_scan_multipart_message(mimeinfo, fp);
+	rfc2015_check_signature(mimeinfo, fp);
+	fclose(fp);
+
+	mimeview_update_names(mimeview);
+	mimeview_update_signature_info(mimeview);
+}
+#endif /* USE_GPGME */
diff -urN sylpheed-0.4.66.orig/src/mimeview.h sylpheed-0.4.66/src/mimeview.h
--- sylpheed-0.4.66.orig/src/mimeview.h	Mon Sep 25 17:25:47 2000
+++ sylpheed-0.4.66/src/mimeview.h	Fri May 11 10:31:16 2001
@@ -28,13 +28,15 @@
 
 #include "textview.h"
 #include "imageview.h"
+#include "htmlview.h"
 #include "messageview.h"
 #include "procmime.h"
 
 typedef enum
 {
 	MIMEVIEW_TEXT,
-	MIMEVIEW_IMAGE
+	MIMEVIEW_IMAGE,
+	MIMEVIEW_HTML
 } MimeViewType;
 
 struct _MimeView
@@ -54,6 +56,7 @@
 
 	TextView *textview;
 	ImageView *imageview;
+	HTMLView *htmlview;
 
 	MessageView *messageview;
 
